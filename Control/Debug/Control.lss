
Control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00005d84  00005e18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005d84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002e6  00800110  00800110  00005e28  2**0
                  ALLOC
  3 .stab         00007068  00000000  00000000  00005e28  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004171  00000000  00000000  0000ce90  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 b1 1c 	jmp	0x3962	; 0x3962 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e4 e8       	ldi	r30, 0x84	; 132
      a0:	fd e5       	ldi	r31, 0x5D	; 93
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a0 31       	cpi	r26, 0x10	; 16
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	13 e0       	ldi	r17, 0x03	; 3
      b4:	a0 e1       	ldi	r26, 0x10	; 16
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 3f       	cpi	r26, 0xF6	; 246
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <main>
      c6:	0c 94 c0 2e 	jmp	0x5d80	; 0x5d80 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <body_rates>:
      ce:	ef 92       	push	r14
      d0:	ff 92       	push	r15
      d2:	0f 93       	push	r16
      d4:	1f 93       	push	r17
      d6:	df 93       	push	r29
      d8:	cf 93       	push	r28
      da:	cd b7       	in	r28, 0x3d	; 61
      dc:	de b7       	in	r29, 0x3e	; 62
      de:	60 97       	sbiw	r28, 0x10	; 16
      e0:	0f b6       	in	r0, 0x3f	; 63
      e2:	f8 94       	cli
      e4:	de bf       	out	0x3e, r29	; 62
      e6:	0f be       	out	0x3f, r0	; 63
      e8:	cd bf       	out	0x3d, r28	; 61
      ea:	98 8b       	std	Y+16, r25	; 0x10
      ec:	8f 87       	std	Y+15, r24	; 0x0f
      ee:	8f 85       	ldd	r24, Y+15	; 0x0f
      f0:	98 89       	ldd	r25, Y+16	; 0x10
      f2:	9e 87       	std	Y+14, r25	; 0x0e
      f4:	8d 87       	std	Y+13, r24	; 0x0d
      f6:	8d 85       	ldd	r24, Y+13	; 0x0d
      f8:	9e 85       	ldd	r25, Y+14	; 0x0e
      fa:	fc 01       	movw	r30, r24
      fc:	e4 58       	subi	r30, 0x84	; 132
      fe:	ff 4f       	sbci	r31, 0xFF	; 255
     100:	80 81       	ld	r24, Z
     102:	91 81       	ldd	r25, Z+1	; 0x01
     104:	a2 81       	ldd	r26, Z+2	; 0x02
     106:	b3 81       	ldd	r27, Z+3	; 0x03
     108:	ed 85       	ldd	r30, Y+13	; 0x0d
     10a:	fe 85       	ldd	r31, Y+14	; 0x0e
     10c:	24 ad       	ldd	r18, Z+60	; 0x3c
     10e:	35 ad       	ldd	r19, Z+61	; 0x3d
     110:	46 ad       	ldd	r20, Z+62	; 0x3e
     112:	57 ad       	ldd	r21, Z+63	; 0x3f
     114:	bc 01       	movw	r22, r24
     116:	cd 01       	movw	r24, r26
     118:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     11c:	dc 01       	movw	r26, r24
     11e:	cb 01       	movw	r24, r22
     120:	89 87       	std	Y+9, r24	; 0x09
     122:	9a 87       	std	Y+10, r25	; 0x0a
     124:	ab 87       	std	Y+11, r26	; 0x0b
     126:	bc 87       	std	Y+12, r27	; 0x0c
     128:	8d 85       	ldd	r24, Y+13	; 0x0d
     12a:	9e 85       	ldd	r25, Y+14	; 0x0e
     12c:	fc 01       	movw	r30, r24
     12e:	e0 58       	subi	r30, 0x80	; 128
     130:	ff 4f       	sbci	r31, 0xFF	; 255
     132:	e0 80       	ld	r14, Z
     134:	f1 80       	ldd	r15, Z+1	; 0x01
     136:	02 81       	ldd	r16, Z+2	; 0x02
     138:	13 81       	ldd	r17, Z+3	; 0x03
     13a:	8d 85       	ldd	r24, Y+13	; 0x0d
     13c:	9e 85       	ldd	r25, Y+14	; 0x0e
     13e:	fc 01       	movw	r30, r24
     140:	e0 5c       	subi	r30, 0xC0	; 192
     142:	ff 4f       	sbci	r31, 0xFF	; 255
     144:	20 81       	ld	r18, Z
     146:	31 81       	ldd	r19, Z+1	; 0x01
     148:	42 81       	ldd	r20, Z+2	; 0x02
     14a:	53 81       	ldd	r21, Z+3	; 0x03
     14c:	c8 01       	movw	r24, r16
     14e:	b7 01       	movw	r22, r14
     150:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     154:	dc 01       	movw	r26, r24
     156:	cb 01       	movw	r24, r22
     158:	8d 83       	std	Y+5, r24	; 0x05
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	af 83       	std	Y+7, r26	; 0x07
     15e:	b8 87       	std	Y+8, r27	; 0x08
     160:	8d 85       	ldd	r24, Y+13	; 0x0d
     162:	9e 85       	ldd	r25, Y+14	; 0x0e
     164:	fc 01       	movw	r30, r24
     166:	ec 57       	subi	r30, 0x7C	; 124
     168:	ff 4f       	sbci	r31, 0xFF	; 255
     16a:	e0 80       	ld	r14, Z
     16c:	f1 80       	ldd	r15, Z+1	; 0x01
     16e:	02 81       	ldd	r16, Z+2	; 0x02
     170:	13 81       	ldd	r17, Z+3	; 0x03
     172:	8d 85       	ldd	r24, Y+13	; 0x0d
     174:	9e 85       	ldd	r25, Y+14	; 0x0e
     176:	fc 01       	movw	r30, r24
     178:	ec 5b       	subi	r30, 0xBC	; 188
     17a:	ff 4f       	sbci	r31, 0xFF	; 255
     17c:	20 81       	ld	r18, Z
     17e:	31 81       	ldd	r19, Z+1	; 0x01
     180:	42 81       	ldd	r20, Z+2	; 0x02
     182:	53 81       	ldd	r21, Z+3	; 0x03
     184:	c8 01       	movw	r24, r16
     186:	b7 01       	movw	r22, r14
     188:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     18c:	dc 01       	movw	r26, r24
     18e:	cb 01       	movw	r24, r22
     190:	89 83       	std	Y+1, r24	; 0x01
     192:	9a 83       	std	Y+2, r25	; 0x02
     194:	ab 83       	std	Y+3, r26	; 0x03
     196:	bc 83       	std	Y+4, r27	; 0x04
     198:	80 91 05 01 	lds	r24, 0x0105
     19c:	88 2f       	mov	r24, r24
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	aa 27       	eor	r26, r26
     1a2:	97 fd       	sbrc	r25, 7
     1a4:	a0 95       	com	r26
     1a6:	ba 2f       	mov	r27, r26
     1a8:	bc 01       	movw	r22, r24
     1aa:	cd 01       	movw	r24, r26
     1ac:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     1b0:	dc 01       	movw	r26, r24
     1b2:	cb 01       	movw	r24, r22
     1b4:	bc 01       	movw	r22, r24
     1b6:	cd 01       	movw	r24, r26
     1b8:	29 85       	ldd	r18, Y+9	; 0x09
     1ba:	3a 85       	ldd	r19, Y+10	; 0x0a
     1bc:	4b 85       	ldd	r20, Y+11	; 0x0b
     1be:	5c 85       	ldd	r21, Y+12	; 0x0c
     1c0:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     1c4:	dc 01       	movw	r26, r24
     1c6:	cb 01       	movw	r24, r22
     1c8:	9c 01       	movw	r18, r24
     1ca:	ad 01       	movw	r20, r26
     1cc:	8d 85       	ldd	r24, Y+13	; 0x0d
     1ce:	9e 85       	ldd	r25, Y+14	; 0x0e
     1d0:	fc 01       	movw	r30, r24
     1d2:	e8 5b       	subi	r30, 0xB8	; 184
     1d4:	ff 4f       	sbci	r31, 0xFF	; 255
     1d6:	20 83       	st	Z, r18
     1d8:	31 83       	std	Z+1, r19	; 0x01
     1da:	42 83       	std	Z+2, r20	; 0x02
     1dc:	53 83       	std	Z+3, r21	; 0x03
     1de:	80 91 05 01 	lds	r24, 0x0105
     1e2:	88 2f       	mov	r24, r24
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	aa 27       	eor	r26, r26
     1e8:	97 fd       	sbrc	r25, 7
     1ea:	a0 95       	com	r26
     1ec:	ba 2f       	mov	r27, r26
     1ee:	bc 01       	movw	r22, r24
     1f0:	cd 01       	movw	r24, r26
     1f2:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     1f6:	dc 01       	movw	r26, r24
     1f8:	cb 01       	movw	r24, r22
     1fa:	bc 01       	movw	r22, r24
     1fc:	cd 01       	movw	r24, r26
     1fe:	2d 81       	ldd	r18, Y+5	; 0x05
     200:	3e 81       	ldd	r19, Y+6	; 0x06
     202:	4f 81       	ldd	r20, Y+7	; 0x07
     204:	58 85       	ldd	r21, Y+8	; 0x08
     206:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     20a:	dc 01       	movw	r26, r24
     20c:	cb 01       	movw	r24, r22
     20e:	9c 01       	movw	r18, r24
     210:	ad 01       	movw	r20, r26
     212:	8d 85       	ldd	r24, Y+13	; 0x0d
     214:	9e 85       	ldd	r25, Y+14	; 0x0e
     216:	fc 01       	movw	r30, r24
     218:	e4 5b       	subi	r30, 0xB4	; 180
     21a:	ff 4f       	sbci	r31, 0xFF	; 255
     21c:	20 83       	st	Z, r18
     21e:	31 83       	std	Z+1, r19	; 0x01
     220:	42 83       	std	Z+2, r20	; 0x02
     222:	53 83       	std	Z+3, r21	; 0x03
     224:	80 91 05 01 	lds	r24, 0x0105
     228:	88 2f       	mov	r24, r24
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	aa 27       	eor	r26, r26
     22e:	97 fd       	sbrc	r25, 7
     230:	a0 95       	com	r26
     232:	ba 2f       	mov	r27, r26
     234:	bc 01       	movw	r22, r24
     236:	cd 01       	movw	r24, r26
     238:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     23c:	dc 01       	movw	r26, r24
     23e:	cb 01       	movw	r24, r22
     240:	bc 01       	movw	r22, r24
     242:	cd 01       	movw	r24, r26
     244:	29 81       	ldd	r18, Y+1	; 0x01
     246:	3a 81       	ldd	r19, Y+2	; 0x02
     248:	4b 81       	ldd	r20, Y+3	; 0x03
     24a:	5c 81       	ldd	r21, Y+4	; 0x04
     24c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     250:	dc 01       	movw	r26, r24
     252:	cb 01       	movw	r24, r22
     254:	9c 01       	movw	r18, r24
     256:	ad 01       	movw	r20, r26
     258:	8d 85       	ldd	r24, Y+13	; 0x0d
     25a:	9e 85       	ldd	r25, Y+14	; 0x0e
     25c:	fc 01       	movw	r30, r24
     25e:	e0 5b       	subi	r30, 0xB0	; 176
     260:	ff 4f       	sbci	r31, 0xFF	; 255
     262:	20 83       	st	Z, r18
     264:	31 83       	std	Z+1, r19	; 0x01
     266:	42 83       	std	Z+2, r20	; 0x02
     268:	53 83       	std	Z+3, r21	; 0x03
     26a:	80 91 06 01 	lds	r24, 0x0106
     26e:	88 2f       	mov	r24, r24
     270:	90 e0       	ldi	r25, 0x00	; 0
     272:	aa 27       	eor	r26, r26
     274:	97 fd       	sbrc	r25, 7
     276:	a0 95       	com	r26
     278:	ba 2f       	mov	r27, r26
     27a:	bc 01       	movw	r22, r24
     27c:	cd 01       	movw	r24, r26
     27e:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     282:	7b 01       	movw	r14, r22
     284:	8c 01       	movw	r16, r24
     286:	8d 85       	ldd	r24, Y+13	; 0x0d
     288:	9e 85       	ldd	r25, Y+14	; 0x0e
     28a:	fc 01       	movw	r30, r24
     28c:	e8 5b       	subi	r30, 0xB8	; 184
     28e:	ff 4f       	sbci	r31, 0xFF	; 255
     290:	20 81       	ld	r18, Z
     292:	31 81       	ldd	r19, Z+1	; 0x01
     294:	42 81       	ldd	r20, Z+2	; 0x02
     296:	53 81       	ldd	r21, Z+3	; 0x03
     298:	c8 01       	movw	r24, r16
     29a:	b7 01       	movw	r22, r14
     29c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     2a0:	dc 01       	movw	r26, r24
     2a2:	cb 01       	movw	r24, r22
     2a4:	9c 01       	movw	r18, r24
     2a6:	ad 01       	movw	r20, r26
     2a8:	8d 85       	ldd	r24, Y+13	; 0x0d
     2aa:	9e 85       	ldd	r25, Y+14	; 0x0e
     2ac:	fc 01       	movw	r30, r24
     2ae:	e4 57       	subi	r30, 0x74	; 116
     2b0:	ff 4f       	sbci	r31, 0xFF	; 255
     2b2:	20 83       	st	Z, r18
     2b4:	31 83       	std	Z+1, r19	; 0x01
     2b6:	42 83       	std	Z+2, r20	; 0x02
     2b8:	53 83       	std	Z+3, r21	; 0x03
     2ba:	80 91 07 01 	lds	r24, 0x0107
     2be:	88 2f       	mov	r24, r24
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	aa 27       	eor	r26, r26
     2c4:	97 fd       	sbrc	r25, 7
     2c6:	a0 95       	com	r26
     2c8:	ba 2f       	mov	r27, r26
     2ca:	bc 01       	movw	r22, r24
     2cc:	cd 01       	movw	r24, r26
     2ce:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     2d2:	7b 01       	movw	r14, r22
     2d4:	8c 01       	movw	r16, r24
     2d6:	8d 85       	ldd	r24, Y+13	; 0x0d
     2d8:	9e 85       	ldd	r25, Y+14	; 0x0e
     2da:	fc 01       	movw	r30, r24
     2dc:	e4 5b       	subi	r30, 0xB4	; 180
     2de:	ff 4f       	sbci	r31, 0xFF	; 255
     2e0:	20 81       	ld	r18, Z
     2e2:	31 81       	ldd	r19, Z+1	; 0x01
     2e4:	42 81       	ldd	r20, Z+2	; 0x02
     2e6:	53 81       	ldd	r21, Z+3	; 0x03
     2e8:	c8 01       	movw	r24, r16
     2ea:	b7 01       	movw	r22, r14
     2ec:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     2f0:	dc 01       	movw	r26, r24
     2f2:	cb 01       	movw	r24, r22
     2f4:	9c 01       	movw	r18, r24
     2f6:	ad 01       	movw	r20, r26
     2f8:	8d 85       	ldd	r24, Y+13	; 0x0d
     2fa:	9e 85       	ldd	r25, Y+14	; 0x0e
     2fc:	fc 01       	movw	r30, r24
     2fe:	e0 57       	subi	r30, 0x70	; 112
     300:	ff 4f       	sbci	r31, 0xFF	; 255
     302:	20 83       	st	Z, r18
     304:	31 83       	std	Z+1, r19	; 0x01
     306:	42 83       	std	Z+2, r20	; 0x02
     308:	53 83       	std	Z+3, r21	; 0x03
     30a:	80 91 08 01 	lds	r24, 0x0108
     30e:	88 2f       	mov	r24, r24
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	aa 27       	eor	r26, r26
     314:	97 fd       	sbrc	r25, 7
     316:	a0 95       	com	r26
     318:	ba 2f       	mov	r27, r26
     31a:	bc 01       	movw	r22, r24
     31c:	cd 01       	movw	r24, r26
     31e:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     322:	7b 01       	movw	r14, r22
     324:	8c 01       	movw	r16, r24
     326:	8d 85       	ldd	r24, Y+13	; 0x0d
     328:	9e 85       	ldd	r25, Y+14	; 0x0e
     32a:	fc 01       	movw	r30, r24
     32c:	e0 5b       	subi	r30, 0xB0	; 176
     32e:	ff 4f       	sbci	r31, 0xFF	; 255
     330:	20 81       	ld	r18, Z
     332:	31 81       	ldd	r19, Z+1	; 0x01
     334:	42 81       	ldd	r20, Z+2	; 0x02
     336:	53 81       	ldd	r21, Z+3	; 0x03
     338:	c8 01       	movw	r24, r16
     33a:	b7 01       	movw	r22, r14
     33c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     340:	dc 01       	movw	r26, r24
     342:	cb 01       	movw	r24, r22
     344:	9c 01       	movw	r18, r24
     346:	ad 01       	movw	r20, r26
     348:	8d 85       	ldd	r24, Y+13	; 0x0d
     34a:	9e 85       	ldd	r25, Y+14	; 0x0e
     34c:	fc 01       	movw	r30, r24
     34e:	ec 56       	subi	r30, 0x6C	; 108
     350:	ff 4f       	sbci	r31, 0xFF	; 255
     352:	20 83       	st	Z, r18
     354:	31 83       	std	Z+1, r19	; 0x01
     356:	42 83       	std	Z+2, r20	; 0x02
     358:	53 83       	std	Z+3, r21	; 0x03
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskDelay>
     362:	c9 ce       	rjmp	.-622    	; 0xf6 <body_rates+0x28>

00000364 <roll_pitch>:
	ptr->u4 = Izz * ptr->r_dot;
	vTaskDelay(1);
	}
}
void roll_pitch(void *pt)
{
     364:	af 92       	push	r10
     366:	bf 92       	push	r11
     368:	cf 92       	push	r12
     36a:	df 92       	push	r13
     36c:	ef 92       	push	r14
     36e:	ff 92       	push	r15
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	df 93       	push	r29
     376:	cf 93       	push	r28
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	c0 54       	subi	r28, 0x40	; 64
     37e:	d0 40       	sbci	r29, 0x00	; 0
     380:	0f b6       	in	r0, 0x3f	; 63
     382:	f8 94       	cli
     384:	de bf       	out	0x3e, r29	; 62
     386:	0f be       	out	0x3f, r0	; 63
     388:	cd bf       	out	0x3d, r28	; 61
     38a:	fe 01       	movw	r30, r28
     38c:	ff 96       	adiw	r30, 0x3f	; 63
     38e:	91 83       	std	Z+1, r25	; 0x01
     390:	80 83       	st	Z, r24
	parameters * ptr = pt;
     392:	fe 01       	movw	r30, r28
     394:	ff 96       	adiw	r30, 0x3f	; 63
     396:	80 81       	ld	r24, Z
     398:	91 81       	ldd	r25, Z+1	; 0x01
     39a:	9e af       	std	Y+62, r25	; 0x3e
     39c:	8d af       	std	Y+61, r24	; 0x3d
	while(1)
	{f32 dt = 0.001, b_x_dot_cmd, b_y_dot_cmd, taw=1/kp_bank;
     39e:	8f e6       	ldi	r24, 0x6F	; 111
     3a0:	92 e1       	ldi	r25, 0x12	; 18
     3a2:	a3 e8       	ldi	r26, 0x83	; 131
     3a4:	ba e3       	ldi	r27, 0x3A	; 58
     3a6:	89 af       	std	Y+57, r24	; 0x39
     3a8:	9a af       	std	Y+58, r25	; 0x3a
     3aa:	ab af       	std	Y+59, r26	; 0x3b
     3ac:	bc af       	std	Y+60, r27	; 0x3c
     3ae:	80 91 0a 01 	lds	r24, 0x010A
     3b2:	28 2f       	mov	r18, r24
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	b9 01       	movw	r22, r18
     3bc:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <__divmodhi4>
     3c0:	cb 01       	movw	r24, r22
     3c2:	aa 27       	eor	r26, r26
     3c4:	97 fd       	sbrc	r25, 7
     3c6:	a0 95       	com	r26
     3c8:	ba 2f       	mov	r27, r26
     3ca:	bc 01       	movw	r22, r24
     3cc:	cd 01       	movw	r24, r26
     3ce:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     3d2:	dc 01       	movw	r26, r24
     3d4:	cb 01       	movw	r24, r22
     3d6:	8d a7       	std	Y+45, r24	; 0x2d
     3d8:	9e a7       	std	Y+46, r25	; 0x2e
     3da:	af a7       	std	Y+47, r26	; 0x2f
     3dc:	b8 ab       	std	Y+48, r27	; 0x30
	f32 R11 = 1;
     3de:	80 e0       	ldi	r24, 0x00	; 0
     3e0:	90 e0       	ldi	r25, 0x00	; 0
     3e2:	a0 e8       	ldi	r26, 0x80	; 128
     3e4:	bf e3       	ldi	r27, 0x3F	; 63
     3e6:	89 a7       	std	Y+41, r24	; 0x29
     3e8:	9a a7       	std	Y+42, r25	; 0x2a
     3ea:	ab a7       	std	Y+43, r26	; 0x2b
     3ec:	bc a7       	std	Y+44, r27	; 0x2c
	f32 R12 = sine(ptr->phi) * sine(ptr->theta) / cosine(ptr->theta);
     3ee:	ed ad       	ldd	r30, Y+61	; 0x3d
     3f0:	fe ad       	ldd	r31, Y+62	; 0x3e
     3f2:	84 a1       	ldd	r24, Z+36	; 0x24
     3f4:	95 a1       	ldd	r25, Z+37	; 0x25
     3f6:	a6 a1       	ldd	r26, Z+38	; 0x26
     3f8:	b7 a1       	ldd	r27, Z+39	; 0x27
     3fa:	bc 01       	movw	r22, r24
     3fc:	cd 01       	movw	r24, r26
     3fe:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
     402:	7b 01       	movw	r14, r22
     404:	8c 01       	movw	r16, r24
     406:	ed ad       	ldd	r30, Y+61	; 0x3d
     408:	fe ad       	ldd	r31, Y+62	; 0x3e
     40a:	80 a5       	ldd	r24, Z+40	; 0x28
     40c:	91 a5       	ldd	r25, Z+41	; 0x29
     40e:	a2 a5       	ldd	r26, Z+42	; 0x2a
     410:	b3 a5       	ldd	r27, Z+43	; 0x2b
     412:	bc 01       	movw	r22, r24
     414:	cd 01       	movw	r24, r26
     416:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
     41a:	9b 01       	movw	r18, r22
     41c:	ac 01       	movw	r20, r24
     41e:	c8 01       	movw	r24, r16
     420:	b7 01       	movw	r22, r14
     422:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     426:	dc 01       	movw	r26, r24
     428:	cb 01       	movw	r24, r22
     42a:	7c 01       	movw	r14, r24
     42c:	8d 01       	movw	r16, r26
     42e:	ed ad       	ldd	r30, Y+61	; 0x3d
     430:	fe ad       	ldd	r31, Y+62	; 0x3e
     432:	80 a5       	ldd	r24, Z+40	; 0x28
     434:	91 a5       	ldd	r25, Z+41	; 0x29
     436:	a2 a5       	ldd	r26, Z+42	; 0x2a
     438:	b3 a5       	ldd	r27, Z+43	; 0x2b
     43a:	bc 01       	movw	r22, r24
     43c:	cd 01       	movw	r24, r26
     43e:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     442:	9b 01       	movw	r18, r22
     444:	ac 01       	movw	r20, r24
     446:	c8 01       	movw	r24, r16
     448:	b7 01       	movw	r22, r14
     44a:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     44e:	dc 01       	movw	r26, r24
     450:	cb 01       	movw	r24, r22
     452:	8d a3       	std	Y+37, r24	; 0x25
     454:	9e a3       	std	Y+38, r25	; 0x26
     456:	af a3       	std	Y+39, r26	; 0x27
     458:	b8 a7       	std	Y+40, r27	; 0x28
	f32 R13= cosine(ptr->phi) * sine(ptr->theta) / cosine(ptr->theta);
     45a:	ed ad       	ldd	r30, Y+61	; 0x3d
     45c:	fe ad       	ldd	r31, Y+62	; 0x3e
     45e:	84 a1       	ldd	r24, Z+36	; 0x24
     460:	95 a1       	ldd	r25, Z+37	; 0x25
     462:	a6 a1       	ldd	r26, Z+38	; 0x26
     464:	b7 a1       	ldd	r27, Z+39	; 0x27
     466:	bc 01       	movw	r22, r24
     468:	cd 01       	movw	r24, r26
     46a:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     46e:	7b 01       	movw	r14, r22
     470:	8c 01       	movw	r16, r24
     472:	ed ad       	ldd	r30, Y+61	; 0x3d
     474:	fe ad       	ldd	r31, Y+62	; 0x3e
     476:	80 a5       	ldd	r24, Z+40	; 0x28
     478:	91 a5       	ldd	r25, Z+41	; 0x29
     47a:	a2 a5       	ldd	r26, Z+42	; 0x2a
     47c:	b3 a5       	ldd	r27, Z+43	; 0x2b
     47e:	bc 01       	movw	r22, r24
     480:	cd 01       	movw	r24, r26
     482:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
     486:	9b 01       	movw	r18, r22
     488:	ac 01       	movw	r20, r24
     48a:	c8 01       	movw	r24, r16
     48c:	b7 01       	movw	r22, r14
     48e:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     492:	dc 01       	movw	r26, r24
     494:	cb 01       	movw	r24, r22
     496:	7c 01       	movw	r14, r24
     498:	8d 01       	movw	r16, r26
     49a:	ed ad       	ldd	r30, Y+61	; 0x3d
     49c:	fe ad       	ldd	r31, Y+62	; 0x3e
     49e:	80 a5       	ldd	r24, Z+40	; 0x28
     4a0:	91 a5       	ldd	r25, Z+41	; 0x29
     4a2:	a2 a5       	ldd	r26, Z+42	; 0x2a
     4a4:	b3 a5       	ldd	r27, Z+43	; 0x2b
     4a6:	bc 01       	movw	r22, r24
     4a8:	cd 01       	movw	r24, r26
     4aa:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     4ae:	9b 01       	movw	r18, r22
     4b0:	ac 01       	movw	r20, r24
     4b2:	c8 01       	movw	r24, r16
     4b4:	b7 01       	movw	r22, r14
     4b6:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     4ba:	dc 01       	movw	r26, r24
     4bc:	cb 01       	movw	r24, r22
     4be:	89 a3       	std	Y+33, r24	; 0x21
     4c0:	9a a3       	std	Y+34, r25	; 0x22
     4c2:	ab a3       	std	Y+35, r26	; 0x23
     4c4:	bc a3       	std	Y+36, r27	; 0x24
	f32 R21 = 0;
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	a0 e0       	ldi	r26, 0x00	; 0
     4cc:	b0 e0       	ldi	r27, 0x00	; 0
     4ce:	8d 8f       	std	Y+29, r24	; 0x1d
     4d0:	9e 8f       	std	Y+30, r25	; 0x1e
     4d2:	af 8f       	std	Y+31, r26	; 0x1f
     4d4:	b8 a3       	std	Y+32, r27	; 0x20
	f32 R22 = cosine(ptr->phi);
     4d6:	ed ad       	ldd	r30, Y+61	; 0x3d
     4d8:	fe ad       	ldd	r31, Y+62	; 0x3e
     4da:	84 a1       	ldd	r24, Z+36	; 0x24
     4dc:	95 a1       	ldd	r25, Z+37	; 0x25
     4de:	a6 a1       	ldd	r26, Z+38	; 0x26
     4e0:	b7 a1       	ldd	r27, Z+39	; 0x27
     4e2:	bc 01       	movw	r22, r24
     4e4:	cd 01       	movw	r24, r26
     4e6:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     4ea:	dc 01       	movw	r26, r24
     4ec:	cb 01       	movw	r24, r22
     4ee:	89 8f       	std	Y+25, r24	; 0x19
     4f0:	9a 8f       	std	Y+26, r25	; 0x1a
     4f2:	ab 8f       	std	Y+27, r26	; 0x1b
     4f4:	bc 8f       	std	Y+28, r27	; 0x1c
	f32 R23= -sine(ptr->phi);
     4f6:	ed ad       	ldd	r30, Y+61	; 0x3d
     4f8:	fe ad       	ldd	r31, Y+62	; 0x3e
     4fa:	84 a1       	ldd	r24, Z+36	; 0x24
     4fc:	95 a1       	ldd	r25, Z+37	; 0x25
     4fe:	a6 a1       	ldd	r26, Z+38	; 0x26
     500:	b7 a1       	ldd	r27, Z+39	; 0x27
     502:	bc 01       	movw	r22, r24
     504:	cd 01       	movw	r24, r26
     506:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
     50a:	dc 01       	movw	r26, r24
     50c:	cb 01       	movw	r24, r22
     50e:	b0 58       	subi	r27, 0x80	; 128
     510:	8d 8b       	std	Y+21, r24	; 0x15
     512:	9e 8b       	std	Y+22, r25	; 0x16
     514:	af 8b       	std	Y+23, r26	; 0x17
     516:	b8 8f       	std	Y+24, r27	; 0x18
	f32 R31 = 0;
     518:	80 e0       	ldi	r24, 0x00	; 0
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	a0 e0       	ldi	r26, 0x00	; 0
     51e:	b0 e0       	ldi	r27, 0x00	; 0
     520:	89 8b       	std	Y+17, r24	; 0x11
     522:	9a 8b       	std	Y+18, r25	; 0x12
     524:	ab 8b       	std	Y+19, r26	; 0x13
     526:	bc 8b       	std	Y+20, r27	; 0x14
	f32 R32 = sine(ptr->phi) / cosine(ptr->theta);
     528:	ed ad       	ldd	r30, Y+61	; 0x3d
     52a:	fe ad       	ldd	r31, Y+62	; 0x3e
     52c:	84 a1       	ldd	r24, Z+36	; 0x24
     52e:	95 a1       	ldd	r25, Z+37	; 0x25
     530:	a6 a1       	ldd	r26, Z+38	; 0x26
     532:	b7 a1       	ldd	r27, Z+39	; 0x27
     534:	bc 01       	movw	r22, r24
     536:	cd 01       	movw	r24, r26
     538:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
     53c:	7b 01       	movw	r14, r22
     53e:	8c 01       	movw	r16, r24
     540:	ed ad       	ldd	r30, Y+61	; 0x3d
     542:	fe ad       	ldd	r31, Y+62	; 0x3e
     544:	80 a5       	ldd	r24, Z+40	; 0x28
     546:	91 a5       	ldd	r25, Z+41	; 0x29
     548:	a2 a5       	ldd	r26, Z+42	; 0x2a
     54a:	b3 a5       	ldd	r27, Z+43	; 0x2b
     54c:	bc 01       	movw	r22, r24
     54e:	cd 01       	movw	r24, r26
     550:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     554:	9b 01       	movw	r18, r22
     556:	ac 01       	movw	r20, r24
     558:	c8 01       	movw	r24, r16
     55a:	b7 01       	movw	r22, r14
     55c:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     560:	dc 01       	movw	r26, r24
     562:	cb 01       	movw	r24, r22
     564:	8d 87       	std	Y+13, r24	; 0x0d
     566:	9e 87       	std	Y+14, r25	; 0x0e
     568:	af 87       	std	Y+15, r26	; 0x0f
     56a:	b8 8b       	std	Y+16, r27	; 0x10
	f32 R33 = cosine(ptr->phi) / cosine(ptr->theta);
     56c:	ed ad       	ldd	r30, Y+61	; 0x3d
     56e:	fe ad       	ldd	r31, Y+62	; 0x3e
     570:	84 a1       	ldd	r24, Z+36	; 0x24
     572:	95 a1       	ldd	r25, Z+37	; 0x25
     574:	a6 a1       	ldd	r26, Z+38	; 0x26
     576:	b7 a1       	ldd	r27, Z+39	; 0x27
     578:	bc 01       	movw	r22, r24
     57a:	cd 01       	movw	r24, r26
     57c:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     580:	7b 01       	movw	r14, r22
     582:	8c 01       	movw	r16, r24
     584:	ed ad       	ldd	r30, Y+61	; 0x3d
     586:	fe ad       	ldd	r31, Y+62	; 0x3e
     588:	80 a5       	ldd	r24, Z+40	; 0x28
     58a:	91 a5       	ldd	r25, Z+41	; 0x29
     58c:	a2 a5       	ldd	r26, Z+42	; 0x2a
     58e:	b3 a5       	ldd	r27, Z+43	; 0x2b
     590:	bc 01       	movw	r22, r24
     592:	cd 01       	movw	r24, r26
     594:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     598:	9b 01       	movw	r18, r22
     59a:	ac 01       	movw	r20, r24
     59c:	c8 01       	movw	r24, r16
     59e:	b7 01       	movw	r22, r14
     5a0:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     5a4:	dc 01       	movw	r26, r24
     5a6:	cb 01       	movw	r24, r22
     5a8:	89 87       	std	Y+9, r24	; 0x09
     5aa:	9a 87       	std	Y+10, r25	; 0x0a
     5ac:	ab 87       	std	Y+11, r26	; 0x0b
     5ae:	bc 87       	std	Y+12, r27	; 0x0c
	f32 R13_cmd= ptr->x_dot_dot_cmd*m/ptr->u1;
     5b0:	8d ad       	ldd	r24, Y+61	; 0x3d
     5b2:	9e ad       	ldd	r25, Y+62	; 0x3e
     5b4:	fc 01       	movw	r30, r24
     5b6:	e4 59       	subi	r30, 0x94	; 148
     5b8:	ff 4f       	sbci	r31, 0xFF	; 255
     5ba:	e0 80       	ld	r14, Z
     5bc:	f1 80       	ldd	r15, Z+1	; 0x01
     5be:	02 81       	ldd	r16, Z+2	; 0x02
     5c0:	13 81       	ldd	r17, Z+3	; 0x03
     5c2:	80 91 09 01 	lds	r24, 0x0109
     5c6:	88 2f       	mov	r24, r24
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	aa 27       	eor	r26, r26
     5cc:	97 fd       	sbrc	r25, 7
     5ce:	a0 95       	com	r26
     5d0:	ba 2f       	mov	r27, r26
     5d2:	bc 01       	movw	r22, r24
     5d4:	cd 01       	movw	r24, r26
     5d6:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     5da:	9b 01       	movw	r18, r22
     5dc:	ac 01       	movw	r20, r24
     5de:	c8 01       	movw	r24, r16
     5e0:	b7 01       	movw	r22, r14
     5e2:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     5e6:	dc 01       	movw	r26, r24
     5e8:	cb 01       	movw	r24, r22
     5ea:	7c 01       	movw	r14, r24
     5ec:	8d 01       	movw	r16, r26
     5ee:	8d ad       	ldd	r24, Y+61	; 0x3d
     5f0:	9e ad       	ldd	r25, Y+62	; 0x3e
     5f2:	fc 01       	movw	r30, r24
     5f4:	e8 57       	subi	r30, 0x78	; 120
     5f6:	ff 4f       	sbci	r31, 0xFF	; 255
     5f8:	20 81       	ld	r18, Z
     5fa:	31 81       	ldd	r19, Z+1	; 0x01
     5fc:	42 81       	ldd	r20, Z+2	; 0x02
     5fe:	53 81       	ldd	r21, Z+3	; 0x03
     600:	c8 01       	movw	r24, r16
     602:	b7 01       	movw	r22, r14
     604:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     608:	dc 01       	movw	r26, r24
     60a:	cb 01       	movw	r24, r22
     60c:	8d 83       	std	Y+5, r24	; 0x05
     60e:	9e 83       	std	Y+6, r25	; 0x06
     610:	af 83       	std	Y+7, r26	; 0x07
     612:	b8 87       	std	Y+8, r27	; 0x08
	f32 R23_cmd= ptr->y_dot_dot_cmd*m/ptr->u1;
     614:	8d ad       	ldd	r24, Y+61	; 0x3d
     616:	9e ad       	ldd	r25, Y+62	; 0x3e
     618:	fc 01       	movw	r30, r24
     61a:	e0 59       	subi	r30, 0x90	; 144
     61c:	ff 4f       	sbci	r31, 0xFF	; 255
     61e:	e0 80       	ld	r14, Z
     620:	f1 80       	ldd	r15, Z+1	; 0x01
     622:	02 81       	ldd	r16, Z+2	; 0x02
     624:	13 81       	ldd	r17, Z+3	; 0x03
     626:	80 91 09 01 	lds	r24, 0x0109
     62a:	88 2f       	mov	r24, r24
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	aa 27       	eor	r26, r26
     630:	97 fd       	sbrc	r25, 7
     632:	a0 95       	com	r26
     634:	ba 2f       	mov	r27, r26
     636:	bc 01       	movw	r22, r24
     638:	cd 01       	movw	r24, r26
     63a:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     63e:	9b 01       	movw	r18, r22
     640:	ac 01       	movw	r20, r24
     642:	c8 01       	movw	r24, r16
     644:	b7 01       	movw	r22, r14
     646:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     64a:	dc 01       	movw	r26, r24
     64c:	cb 01       	movw	r24, r22
     64e:	7c 01       	movw	r14, r24
     650:	8d 01       	movw	r16, r26
     652:	8d ad       	ldd	r24, Y+61	; 0x3d
     654:	9e ad       	ldd	r25, Y+62	; 0x3e
     656:	fc 01       	movw	r30, r24
     658:	e8 57       	subi	r30, 0x78	; 120
     65a:	ff 4f       	sbci	r31, 0xFF	; 255
     65c:	20 81       	ld	r18, Z
     65e:	31 81       	ldd	r19, Z+1	; 0x01
     660:	42 81       	ldd	r20, Z+2	; 0x02
     662:	53 81       	ldd	r21, Z+3	; 0x03
     664:	c8 01       	movw	r24, r16
     666:	b7 01       	movw	r22, r14
     668:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     66c:	dc 01       	movw	r26, r24
     66e:	cb 01       	movw	r24, r22
     670:	89 83       	std	Y+1, r24	; 0x01
     672:	9a 83       	std	Y+2, r25	; 0x02
     674:	ab 83       	std	Y+3, r26	; 0x03
     676:	bc 83       	std	Y+4, r27	; 0x04
    ptr->psi_dot = ptr-> q * R32 + ptr->r * R33;
    ptr->phi += ptr->phi_dot * dt;
    ptr->theta += ptr->theta_dot * dt;
    ptr->psi += ptr->psi_dot * dt;
*/
    b_x_dot_cmd= (R13-R13_cmd)/taw;
     678:	69 a1       	ldd	r22, Y+33	; 0x21
     67a:	7a a1       	ldd	r23, Y+34	; 0x22
     67c:	8b a1       	ldd	r24, Y+35	; 0x23
     67e:	9c a1       	ldd	r25, Y+36	; 0x24
     680:	2d 81       	ldd	r18, Y+5	; 0x05
     682:	3e 81       	ldd	r19, Y+6	; 0x06
     684:	4f 81       	ldd	r20, Y+7	; 0x07
     686:	58 85       	ldd	r21, Y+8	; 0x08
     688:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     68c:	dc 01       	movw	r26, r24
     68e:	cb 01       	movw	r24, r22
     690:	bc 01       	movw	r22, r24
     692:	cd 01       	movw	r24, r26
     694:	2d a5       	ldd	r18, Y+45	; 0x2d
     696:	3e a5       	ldd	r19, Y+46	; 0x2e
     698:	4f a5       	ldd	r20, Y+47	; 0x2f
     69a:	58 a9       	ldd	r21, Y+48	; 0x30
     69c:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     6a0:	dc 01       	movw	r26, r24
     6a2:	cb 01       	movw	r24, r22
     6a4:	8d ab       	std	Y+53, r24	; 0x35
     6a6:	9e ab       	std	Y+54, r25	; 0x36
     6a8:	af ab       	std	Y+55, r26	; 0x37
     6aa:	b8 af       	std	Y+56, r27	; 0x38
    b_y_dot_cmd= (R23-R23_cmd)/taw;
     6ac:	6d 89       	ldd	r22, Y+21	; 0x15
     6ae:	7e 89       	ldd	r23, Y+22	; 0x16
     6b0:	8f 89       	ldd	r24, Y+23	; 0x17
     6b2:	98 8d       	ldd	r25, Y+24	; 0x18
     6b4:	29 81       	ldd	r18, Y+1	; 0x01
     6b6:	3a 81       	ldd	r19, Y+2	; 0x02
     6b8:	4b 81       	ldd	r20, Y+3	; 0x03
     6ba:	5c 81       	ldd	r21, Y+4	; 0x04
     6bc:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     6c0:	dc 01       	movw	r26, r24
     6c2:	cb 01       	movw	r24, r22
     6c4:	bc 01       	movw	r22, r24
     6c6:	cd 01       	movw	r24, r26
     6c8:	2d a5       	ldd	r18, Y+45	; 0x2d
     6ca:	3e a5       	ldd	r19, Y+46	; 0x2e
     6cc:	4f a5       	ldd	r20, Y+47	; 0x2f
     6ce:	58 a9       	ldd	r21, Y+48	; 0x30
     6d0:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     6d4:	dc 01       	movw	r26, r24
     6d6:	cb 01       	movw	r24, r22
     6d8:	89 ab       	std	Y+49, r24	; 0x31
     6da:	9a ab       	std	Y+50, r25	; 0x32
     6dc:	ab ab       	std	Y+51, r26	; 0x33
     6de:	bc ab       	std	Y+52, r27	; 0x34

    ptr->p_cmd = 1/R33 * (R21*b_x_dot_cmd - R11*b_y_dot_cmd);
     6e0:	60 e0       	ldi	r22, 0x00	; 0
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	80 e8       	ldi	r24, 0x80	; 128
     6e6:	9f e3       	ldi	r25, 0x3F	; 63
     6e8:	29 85       	ldd	r18, Y+9	; 0x09
     6ea:	3a 85       	ldd	r19, Y+10	; 0x0a
     6ec:	4b 85       	ldd	r20, Y+11	; 0x0b
     6ee:	5c 85       	ldd	r21, Y+12	; 0x0c
     6f0:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     6f4:	dc 01       	movw	r26, r24
     6f6:	cb 01       	movw	r24, r22
     6f8:	5c 01       	movw	r10, r24
     6fa:	6d 01       	movw	r12, r26
     6fc:	6d 8d       	ldd	r22, Y+29	; 0x1d
     6fe:	7e 8d       	ldd	r23, Y+30	; 0x1e
     700:	8f 8d       	ldd	r24, Y+31	; 0x1f
     702:	98 a1       	ldd	r25, Y+32	; 0x20
     704:	2d a9       	ldd	r18, Y+53	; 0x35
     706:	3e a9       	ldd	r19, Y+54	; 0x36
     708:	4f a9       	ldd	r20, Y+55	; 0x37
     70a:	58 ad       	ldd	r21, Y+56	; 0x38
     70c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     710:	dc 01       	movw	r26, r24
     712:	cb 01       	movw	r24, r22
     714:	7c 01       	movw	r14, r24
     716:	8d 01       	movw	r16, r26
     718:	69 a5       	ldd	r22, Y+41	; 0x29
     71a:	7a a5       	ldd	r23, Y+42	; 0x2a
     71c:	8b a5       	ldd	r24, Y+43	; 0x2b
     71e:	9c a5       	ldd	r25, Y+44	; 0x2c
     720:	29 a9       	ldd	r18, Y+49	; 0x31
     722:	3a a9       	ldd	r19, Y+50	; 0x32
     724:	4b a9       	ldd	r20, Y+51	; 0x33
     726:	5c a9       	ldd	r21, Y+52	; 0x34
     728:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     72c:	dc 01       	movw	r26, r24
     72e:	cb 01       	movw	r24, r22
     730:	9c 01       	movw	r18, r24
     732:	ad 01       	movw	r20, r26
     734:	c8 01       	movw	r24, r16
     736:	b7 01       	movw	r22, r14
     738:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     73c:	dc 01       	movw	r26, r24
     73e:	cb 01       	movw	r24, r22
     740:	9c 01       	movw	r18, r24
     742:	ad 01       	movw	r20, r26
     744:	c6 01       	movw	r24, r12
     746:	b5 01       	movw	r22, r10
     748:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     74c:	dc 01       	movw	r26, r24
     74e:	cb 01       	movw	r24, r22
     750:	9c 01       	movw	r18, r24
     752:	ad 01       	movw	r20, r26
     754:	8d ad       	ldd	r24, Y+61	; 0x3d
     756:	9e ad       	ldd	r25, Y+62	; 0x3e
     758:	fc 01       	movw	r30, r24
     75a:	e4 58       	subi	r30, 0x84	; 132
     75c:	ff 4f       	sbci	r31, 0xFF	; 255
     75e:	20 83       	st	Z, r18
     760:	31 83       	std	Z+1, r19	; 0x01
     762:	42 83       	std	Z+2, r20	; 0x02
     764:	53 83       	std	Z+3, r21	; 0x03
    ptr->q_cmd = 1/R33 * (R22*b_x_dot_cmd - R12*b_y_dot_cmd);
     766:	60 e0       	ldi	r22, 0x00	; 0
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	80 e8       	ldi	r24, 0x80	; 128
     76c:	9f e3       	ldi	r25, 0x3F	; 63
     76e:	29 85       	ldd	r18, Y+9	; 0x09
     770:	3a 85       	ldd	r19, Y+10	; 0x0a
     772:	4b 85       	ldd	r20, Y+11	; 0x0b
     774:	5c 85       	ldd	r21, Y+12	; 0x0c
     776:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     77a:	dc 01       	movw	r26, r24
     77c:	cb 01       	movw	r24, r22
     77e:	5c 01       	movw	r10, r24
     780:	6d 01       	movw	r12, r26
     782:	69 8d       	ldd	r22, Y+25	; 0x19
     784:	7a 8d       	ldd	r23, Y+26	; 0x1a
     786:	8b 8d       	ldd	r24, Y+27	; 0x1b
     788:	9c 8d       	ldd	r25, Y+28	; 0x1c
     78a:	2d a9       	ldd	r18, Y+53	; 0x35
     78c:	3e a9       	ldd	r19, Y+54	; 0x36
     78e:	4f a9       	ldd	r20, Y+55	; 0x37
     790:	58 ad       	ldd	r21, Y+56	; 0x38
     792:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     796:	dc 01       	movw	r26, r24
     798:	cb 01       	movw	r24, r22
     79a:	7c 01       	movw	r14, r24
     79c:	8d 01       	movw	r16, r26
     79e:	6d a1       	ldd	r22, Y+37	; 0x25
     7a0:	7e a1       	ldd	r23, Y+38	; 0x26
     7a2:	8f a1       	ldd	r24, Y+39	; 0x27
     7a4:	98 a5       	ldd	r25, Y+40	; 0x28
     7a6:	29 a9       	ldd	r18, Y+49	; 0x31
     7a8:	3a a9       	ldd	r19, Y+50	; 0x32
     7aa:	4b a9       	ldd	r20, Y+51	; 0x33
     7ac:	5c a9       	ldd	r21, Y+52	; 0x34
     7ae:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     7b2:	dc 01       	movw	r26, r24
     7b4:	cb 01       	movw	r24, r22
     7b6:	9c 01       	movw	r18, r24
     7b8:	ad 01       	movw	r20, r26
     7ba:	c8 01       	movw	r24, r16
     7bc:	b7 01       	movw	r22, r14
     7be:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     7c2:	dc 01       	movw	r26, r24
     7c4:	cb 01       	movw	r24, r22
     7c6:	9c 01       	movw	r18, r24
     7c8:	ad 01       	movw	r20, r26
     7ca:	c6 01       	movw	r24, r12
     7cc:	b5 01       	movw	r22, r10
     7ce:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     7d2:	dc 01       	movw	r26, r24
     7d4:	cb 01       	movw	r24, r22
     7d6:	9c 01       	movw	r18, r24
     7d8:	ad 01       	movw	r20, r26
     7da:	8d ad       	ldd	r24, Y+61	; 0x3d
     7dc:	9e ad       	ldd	r25, Y+62	; 0x3e
     7de:	fc 01       	movw	r30, r24
     7e0:	e0 58       	subi	r30, 0x80	; 128
     7e2:	ff 4f       	sbci	r31, 0xFF	; 255
     7e4:	20 83       	st	Z, r18
     7e6:	31 83       	std	Z+1, r19	; 0x01
     7e8:	42 83       	std	Z+2, r20	; 0x02
     7ea:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(1);
     7ec:	81 e0       	ldi	r24, 0x01	; 1
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskDelay>
     7f4:	d4 cd       	rjmp	.-1112   	; 0x39e <roll_pitch+0x3a>

000007f6 <yaw_controller>:

	}
}
void yaw_controller(void *pt)
{
     7f6:	ef 92       	push	r14
     7f8:	ff 92       	push	r15
     7fa:	0f 93       	push	r16
     7fc:	1f 93       	push	r17
     7fe:	df 93       	push	r29
     800:	cf 93       	push	r28
     802:	00 d0       	rcall	.+0      	; 0x804 <yaw_controller+0xe>
     804:	00 d0       	rcall	.+0      	; 0x806 <yaw_controller+0x10>
     806:	cd b7       	in	r28, 0x3d	; 61
     808:	de b7       	in	r29, 0x3e	; 62
     80a:	9c 83       	std	Y+4, r25	; 0x04
     80c:	8b 83       	std	Y+3, r24	; 0x03
	parameters* ptr= pt;
     80e:	8b 81       	ldd	r24, Y+3	; 0x03
     810:	9c 81       	ldd	r25, Y+4	; 0x04
     812:	9a 83       	std	Y+2, r25	; 0x02
     814:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{ptr->r_cmd = kp_rate*(ptr->psi_cmd - ptr->psi);
     816:	80 91 05 01 	lds	r24, 0x0105
     81a:	88 2f       	mov	r24, r24
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	aa 27       	eor	r26, r26
     820:	97 fd       	sbrc	r25, 7
     822:	a0 95       	com	r26
     824:	ba 2f       	mov	r27, r26
     826:	bc 01       	movw	r22, r24
     828:	cd 01       	movw	r24, r26
     82a:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     82e:	7b 01       	movw	r14, r22
     830:	8c 01       	movw	r16, r24
     832:	89 81       	ldd	r24, Y+1	; 0x01
     834:	9a 81       	ldd	r25, Y+2	; 0x02
     836:	fc 01       	movw	r30, r24
     838:	e8 58       	subi	r30, 0x88	; 136
     83a:	ff 4f       	sbci	r31, 0xFF	; 255
     83c:	80 81       	ld	r24, Z
     83e:	91 81       	ldd	r25, Z+1	; 0x01
     840:	a2 81       	ldd	r26, Z+2	; 0x02
     842:	b3 81       	ldd	r27, Z+3	; 0x03
     844:	e9 81       	ldd	r30, Y+1	; 0x01
     846:	fa 81       	ldd	r31, Y+2	; 0x02
     848:	24 a5       	ldd	r18, Z+44	; 0x2c
     84a:	35 a5       	ldd	r19, Z+45	; 0x2d
     84c:	46 a5       	ldd	r20, Z+46	; 0x2e
     84e:	57 a5       	ldd	r21, Z+47	; 0x2f
     850:	bc 01       	movw	r22, r24
     852:	cd 01       	movw	r24, r26
     854:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     858:	dc 01       	movw	r26, r24
     85a:	cb 01       	movw	r24, r22
     85c:	9c 01       	movw	r18, r24
     85e:	ad 01       	movw	r20, r26
     860:	c8 01       	movw	r24, r16
     862:	b7 01       	movw	r22, r14
     864:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     868:	dc 01       	movw	r26, r24
     86a:	cb 01       	movw	r24, r22
     86c:	9c 01       	movw	r18, r24
     86e:	ad 01       	movw	r20, r26
     870:	89 81       	ldd	r24, Y+1	; 0x01
     872:	9a 81       	ldd	r25, Y+2	; 0x02
     874:	fc 01       	movw	r30, r24
     876:	ec 57       	subi	r30, 0x7C	; 124
     878:	ff 4f       	sbci	r31, 0xFF	; 255
     87a:	20 83       	st	Z, r18
     87c:	31 83       	std	Z+1, r19	; 0x01
     87e:	42 83       	std	Z+2, r20	; 0x02
     880:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     882:	84 e6       	ldi	r24, 0x64	; 100
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskDelay>
     88a:	c5 cf       	rjmp	.-118    	; 0x816 <yaw_controller+0x20>

0000088c <altitude_controller>:

	}
}
void altitude_controller(void *pt)
{
     88c:	af 92       	push	r10
     88e:	bf 92       	push	r11
     890:	cf 92       	push	r12
     892:	df 92       	push	r13
     894:	ef 92       	push	r14
     896:	ff 92       	push	r15
     898:	0f 93       	push	r16
     89a:	1f 93       	push	r17
     89c:	df 93       	push	r29
     89e:	cf 93       	push	r28
     8a0:	cd b7       	in	r28, 0x3d	; 61
     8a2:	de b7       	in	r29, 0x3e	; 62
     8a4:	28 97       	sbiw	r28, 0x08	; 8
     8a6:	0f b6       	in	r0, 0x3f	; 63
     8a8:	f8 94       	cli
     8aa:	de bf       	out	0x3e, r29	; 62
     8ac:	0f be       	out	0x3f, r0	; 63
     8ae:	cd bf       	out	0x3d, r28	; 61
     8b0:	98 87       	std	Y+8, r25	; 0x08
     8b2:	8f 83       	std	Y+7, r24	; 0x07
	parameters* ptr= pt;
     8b4:	8f 81       	ldd	r24, Y+7	; 0x07
     8b6:	98 85       	ldd	r25, Y+8	; 0x08
     8b8:	9e 83       	std	Y+6, r25	; 0x06
     8ba:	8d 83       	std	Y+5, r24	; 0x05
	while(1)
	{f32 R33 = cosine(ptr->phi)/cosine(ptr->theta);
     8bc:	ed 81       	ldd	r30, Y+5	; 0x05
     8be:	fe 81       	ldd	r31, Y+6	; 0x06
     8c0:	84 a1       	ldd	r24, Z+36	; 0x24
     8c2:	95 a1       	ldd	r25, Z+37	; 0x25
     8c4:	a6 a1       	ldd	r26, Z+38	; 0x26
     8c6:	b7 a1       	ldd	r27, Z+39	; 0x27
     8c8:	bc 01       	movw	r22, r24
     8ca:	cd 01       	movw	r24, r26
     8cc:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     8d0:	7b 01       	movw	r14, r22
     8d2:	8c 01       	movw	r16, r24
     8d4:	ed 81       	ldd	r30, Y+5	; 0x05
     8d6:	fe 81       	ldd	r31, Y+6	; 0x06
     8d8:	80 a5       	ldd	r24, Z+40	; 0x28
     8da:	91 a5       	ldd	r25, Z+41	; 0x29
     8dc:	a2 a5       	ldd	r26, Z+42	; 0x2a
     8de:	b3 a5       	ldd	r27, Z+43	; 0x2b
     8e0:	bc 01       	movw	r22, r24
     8e2:	cd 01       	movw	r24, r26
     8e4:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
     8e8:	9b 01       	movw	r18, r22
     8ea:	ac 01       	movw	r20, r24
     8ec:	c8 01       	movw	r24, r16
     8ee:	b7 01       	movw	r22, r14
     8f0:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     8f4:	dc 01       	movw	r26, r24
     8f6:	cb 01       	movw	r24, r22
     8f8:	89 83       	std	Y+1, r24	; 0x01
     8fa:	9a 83       	std	Y+2, r25	; 0x02
     8fc:	ab 83       	std	Y+3, r26	; 0x03
     8fe:	bc 83       	std	Y+4, r27	; 0x04
	ptr->z_dot_dot_cmd= kp_rate*(ptr->z_cmd- ptr->z) + kd*(ptr->z_dot_cmd-ptr->z_dot);
     900:	80 91 05 01 	lds	r24, 0x0105
     904:	88 2f       	mov	r24, r24
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	aa 27       	eor	r26, r26
     90a:	97 fd       	sbrc	r25, 7
     90c:	a0 95       	com	r26
     90e:	ba 2f       	mov	r27, r26
     910:	bc 01       	movw	r22, r24
     912:	cd 01       	movw	r24, r26
     914:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     918:	7b 01       	movw	r14, r22
     91a:	8c 01       	movw	r16, r24
     91c:	8d 81       	ldd	r24, Y+5	; 0x05
     91e:	9e 81       	ldd	r25, Y+6	; 0x06
     920:	fc 01       	movw	r30, r24
     922:	e4 5a       	subi	r30, 0xA4	; 164
     924:	ff 4f       	sbci	r31, 0xFF	; 255
     926:	80 81       	ld	r24, Z
     928:	91 81       	ldd	r25, Z+1	; 0x01
     92a:	a2 81       	ldd	r26, Z+2	; 0x02
     92c:	b3 81       	ldd	r27, Z+3	; 0x03
     92e:	ed 81       	ldd	r30, Y+5	; 0x05
     930:	fe 81       	ldd	r31, Y+6	; 0x06
     932:	20 85       	ldd	r18, Z+8	; 0x08
     934:	31 85       	ldd	r19, Z+9	; 0x09
     936:	42 85       	ldd	r20, Z+10	; 0x0a
     938:	53 85       	ldd	r21, Z+11	; 0x0b
     93a:	bc 01       	movw	r22, r24
     93c:	cd 01       	movw	r24, r26
     93e:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     942:	dc 01       	movw	r26, r24
     944:	cb 01       	movw	r24, r22
     946:	9c 01       	movw	r18, r24
     948:	ad 01       	movw	r20, r26
     94a:	c8 01       	movw	r24, r16
     94c:	b7 01       	movw	r22, r14
     94e:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     952:	dc 01       	movw	r26, r24
     954:	cb 01       	movw	r24, r22
     956:	5c 01       	movw	r10, r24
     958:	6d 01       	movw	r12, r26
     95a:	80 91 f5 03 	lds	r24, 0x03F5
     95e:	88 2f       	mov	r24, r24
     960:	90 e0       	ldi	r25, 0x00	; 0
     962:	aa 27       	eor	r26, r26
     964:	97 fd       	sbrc	r25, 7
     966:	a0 95       	com	r26
     968:	ba 2f       	mov	r27, r26
     96a:	bc 01       	movw	r22, r24
     96c:	cd 01       	movw	r24, r26
     96e:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     972:	7b 01       	movw	r14, r22
     974:	8c 01       	movw	r16, r24
     976:	8d 81       	ldd	r24, Y+5	; 0x05
     978:	9e 81       	ldd	r25, Y+6	; 0x06
     97a:	fc 01       	movw	r30, r24
     97c:	e8 59       	subi	r30, 0x98	; 152
     97e:	ff 4f       	sbci	r31, 0xFF	; 255
     980:	80 81       	ld	r24, Z
     982:	91 81       	ldd	r25, Z+1	; 0x01
     984:	a2 81       	ldd	r26, Z+2	; 0x02
     986:	b3 81       	ldd	r27, Z+3	; 0x03
     988:	ed 81       	ldd	r30, Y+5	; 0x05
     98a:	fe 81       	ldd	r31, Y+6	; 0x06
     98c:	24 89       	ldd	r18, Z+20	; 0x14
     98e:	35 89       	ldd	r19, Z+21	; 0x15
     990:	46 89       	ldd	r20, Z+22	; 0x16
     992:	57 89       	ldd	r21, Z+23	; 0x17
     994:	bc 01       	movw	r22, r24
     996:	cd 01       	movw	r24, r26
     998:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     99c:	dc 01       	movw	r26, r24
     99e:	cb 01       	movw	r24, r22
     9a0:	9c 01       	movw	r18, r24
     9a2:	ad 01       	movw	r20, r26
     9a4:	c8 01       	movw	r24, r16
     9a6:	b7 01       	movw	r22, r14
     9a8:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     9ac:	dc 01       	movw	r26, r24
     9ae:	cb 01       	movw	r24, r22
     9b0:	9c 01       	movw	r18, r24
     9b2:	ad 01       	movw	r20, r26
     9b4:	c6 01       	movw	r24, r12
     9b6:	b5 01       	movw	r22, r10
     9b8:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
     9bc:	dc 01       	movw	r26, r24
     9be:	cb 01       	movw	r24, r22
     9c0:	9c 01       	movw	r18, r24
     9c2:	ad 01       	movw	r20, r26
     9c4:	8d 81       	ldd	r24, Y+5	; 0x05
     9c6:	9e 81       	ldd	r25, Y+6	; 0x06
     9c8:	fc 01       	movw	r30, r24
     9ca:	ec 58       	subi	r30, 0x8C	; 140
     9cc:	ff 4f       	sbci	r31, 0xFF	; 255
     9ce:	20 83       	st	Z, r18
     9d0:	31 83       	std	Z+1, r19	; 0x01
     9d2:	42 83       	std	Z+2, r20	; 0x02
     9d4:	53 83       	std	Z+3, r21	; 0x03

	ptr->u1 = m* (ptr->z_dot_dot_cmd - g)/R33;
     9d6:	80 91 09 01 	lds	r24, 0x0109
     9da:	88 2f       	mov	r24, r24
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	aa 27       	eor	r26, r26
     9e0:	97 fd       	sbrc	r25, 7
     9e2:	a0 95       	com	r26
     9e4:	ba 2f       	mov	r27, r26
     9e6:	bc 01       	movw	r22, r24
     9e8:	cd 01       	movw	r24, r26
     9ea:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     9ee:	5b 01       	movw	r10, r22
     9f0:	6c 01       	movw	r12, r24
     9f2:	8d 81       	ldd	r24, Y+5	; 0x05
     9f4:	9e 81       	ldd	r25, Y+6	; 0x06
     9f6:	fc 01       	movw	r30, r24
     9f8:	ec 58       	subi	r30, 0x8C	; 140
     9fa:	ff 4f       	sbci	r31, 0xFF	; 255
     9fc:	e0 80       	ld	r14, Z
     9fe:	f1 80       	ldd	r15, Z+1	; 0x01
     a00:	02 81       	ldd	r16, Z+2	; 0x02
     a02:	13 81       	ldd	r17, Z+3	; 0x03
     a04:	80 91 0b 01 	lds	r24, 0x010B
     a08:	88 2f       	mov	r24, r24
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	aa 27       	eor	r26, r26
     a0e:	97 fd       	sbrc	r25, 7
     a10:	a0 95       	com	r26
     a12:	ba 2f       	mov	r27, r26
     a14:	bc 01       	movw	r22, r24
     a16:	cd 01       	movw	r24, r26
     a18:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     a1c:	9b 01       	movw	r18, r22
     a1e:	ac 01       	movw	r20, r24
     a20:	c8 01       	movw	r24, r16
     a22:	b7 01       	movw	r22, r14
     a24:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     a28:	dc 01       	movw	r26, r24
     a2a:	cb 01       	movw	r24, r22
     a2c:	9c 01       	movw	r18, r24
     a2e:	ad 01       	movw	r20, r26
     a30:	c6 01       	movw	r24, r12
     a32:	b5 01       	movw	r22, r10
     a34:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     a38:	dc 01       	movw	r26, r24
     a3a:	cb 01       	movw	r24, r22
     a3c:	bc 01       	movw	r22, r24
     a3e:	cd 01       	movw	r24, r26
     a40:	29 81       	ldd	r18, Y+1	; 0x01
     a42:	3a 81       	ldd	r19, Y+2	; 0x02
     a44:	4b 81       	ldd	r20, Y+3	; 0x03
     a46:	5c 81       	ldd	r21, Y+4	; 0x04
     a48:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
     a4c:	dc 01       	movw	r26, r24
     a4e:	cb 01       	movw	r24, r22
     a50:	9c 01       	movw	r18, r24
     a52:	ad 01       	movw	r20, r26
     a54:	8d 81       	ldd	r24, Y+5	; 0x05
     a56:	9e 81       	ldd	r25, Y+6	; 0x06
     a58:	fc 01       	movw	r30, r24
     a5a:	e8 57       	subi	r30, 0x78	; 120
     a5c:	ff 4f       	sbci	r31, 0xFF	; 255
     a5e:	20 83       	st	Z, r18
     a60:	31 83       	std	Z+1, r19	; 0x01
     a62:	42 83       	std	Z+2, r20	; 0x02
     a64:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     a66:	84 e6       	ldi	r24, 0x64	; 100
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskDelay>
     a6e:	26 cf       	rjmp	.-436    	; 0x8bc <altitude_controller+0x30>

00000a70 <lateral_controller>:
	}
}
void lateral_controller(void *pt)
{
     a70:	af 92       	push	r10
     a72:	bf 92       	push	r11
     a74:	cf 92       	push	r12
     a76:	df 92       	push	r13
     a78:	ef 92       	push	r14
     a7a:	ff 92       	push	r15
     a7c:	0f 93       	push	r16
     a7e:	1f 93       	push	r17
     a80:	df 93       	push	r29
     a82:	cf 93       	push	r28
     a84:	00 d0       	rcall	.+0      	; 0xa86 <lateral_controller+0x16>
     a86:	00 d0       	rcall	.+0      	; 0xa88 <lateral_controller+0x18>
     a88:	cd b7       	in	r28, 0x3d	; 61
     a8a:	de b7       	in	r29, 0x3e	; 62
     a8c:	9c 83       	std	Y+4, r25	; 0x04
     a8e:	8b 83       	std	Y+3, r24	; 0x03
	parameters* ptr= pt;
     a90:	8b 81       	ldd	r24, Y+3	; 0x03
     a92:	9c 81       	ldd	r25, Y+4	; 0x04
     a94:	9a 83       	std	Y+2, r25	; 0x02
     a96:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
	ptr->x_dot_dot_cmd= kp_rate*(ptr->x_cmd- ptr->z) + kd*(ptr->x_dot_cmd-ptr->x_dot);
     a98:	80 91 05 01 	lds	r24, 0x0105
     a9c:	88 2f       	mov	r24, r24
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	aa 27       	eor	r26, r26
     aa2:	97 fd       	sbrc	r25, 7
     aa4:	a0 95       	com	r26
     aa6:	ba 2f       	mov	r27, r26
     aa8:	bc 01       	movw	r22, r24
     aaa:	cd 01       	movw	r24, r26
     aac:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     ab0:	7b 01       	movw	r14, r22
     ab2:	8c 01       	movw	r16, r24
     ab4:	89 81       	ldd	r24, Y+1	; 0x01
     ab6:	9a 81       	ldd	r25, Y+2	; 0x02
     ab8:	fc 01       	movw	r30, r24
     aba:	ec 5a       	subi	r30, 0xAC	; 172
     abc:	ff 4f       	sbci	r31, 0xFF	; 255
     abe:	80 81       	ld	r24, Z
     ac0:	91 81       	ldd	r25, Z+1	; 0x01
     ac2:	a2 81       	ldd	r26, Z+2	; 0x02
     ac4:	b3 81       	ldd	r27, Z+3	; 0x03
     ac6:	e9 81       	ldd	r30, Y+1	; 0x01
     ac8:	fa 81       	ldd	r31, Y+2	; 0x02
     aca:	20 85       	ldd	r18, Z+8	; 0x08
     acc:	31 85       	ldd	r19, Z+9	; 0x09
     ace:	42 85       	ldd	r20, Z+10	; 0x0a
     ad0:	53 85       	ldd	r21, Z+11	; 0x0b
     ad2:	bc 01       	movw	r22, r24
     ad4:	cd 01       	movw	r24, r26
     ad6:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     ada:	dc 01       	movw	r26, r24
     adc:	cb 01       	movw	r24, r22
     ade:	9c 01       	movw	r18, r24
     ae0:	ad 01       	movw	r20, r26
     ae2:	c8 01       	movw	r24, r16
     ae4:	b7 01       	movw	r22, r14
     ae6:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     aea:	dc 01       	movw	r26, r24
     aec:	cb 01       	movw	r24, r22
     aee:	5c 01       	movw	r10, r24
     af0:	6d 01       	movw	r12, r26
     af2:	80 91 f5 03 	lds	r24, 0x03F5
     af6:	88 2f       	mov	r24, r24
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	aa 27       	eor	r26, r26
     afc:	97 fd       	sbrc	r25, 7
     afe:	a0 95       	com	r26
     b00:	ba 2f       	mov	r27, r26
     b02:	bc 01       	movw	r22, r24
     b04:	cd 01       	movw	r24, r26
     b06:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     b0a:	7b 01       	movw	r14, r22
     b0c:	8c 01       	movw	r16, r24
     b0e:	89 81       	ldd	r24, Y+1	; 0x01
     b10:	9a 81       	ldd	r25, Y+2	; 0x02
     b12:	fc 01       	movw	r30, r24
     b14:	e0 5a       	subi	r30, 0xA0	; 160
     b16:	ff 4f       	sbci	r31, 0xFF	; 255
     b18:	80 81       	ld	r24, Z
     b1a:	91 81       	ldd	r25, Z+1	; 0x01
     b1c:	a2 81       	ldd	r26, Z+2	; 0x02
     b1e:	b3 81       	ldd	r27, Z+3	; 0x03
     b20:	e9 81       	ldd	r30, Y+1	; 0x01
     b22:	fa 81       	ldd	r31, Y+2	; 0x02
     b24:	24 85       	ldd	r18, Z+12	; 0x0c
     b26:	35 85       	ldd	r19, Z+13	; 0x0d
     b28:	46 85       	ldd	r20, Z+14	; 0x0e
     b2a:	57 85       	ldd	r21, Z+15	; 0x0f
     b2c:	bc 01       	movw	r22, r24
     b2e:	cd 01       	movw	r24, r26
     b30:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     b34:	dc 01       	movw	r26, r24
     b36:	cb 01       	movw	r24, r22
     b38:	9c 01       	movw	r18, r24
     b3a:	ad 01       	movw	r20, r26
     b3c:	c8 01       	movw	r24, r16
     b3e:	b7 01       	movw	r22, r14
     b40:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     b44:	dc 01       	movw	r26, r24
     b46:	cb 01       	movw	r24, r22
     b48:	9c 01       	movw	r18, r24
     b4a:	ad 01       	movw	r20, r26
     b4c:	c6 01       	movw	r24, r12
     b4e:	b5 01       	movw	r22, r10
     b50:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
     b54:	dc 01       	movw	r26, r24
     b56:	cb 01       	movw	r24, r22
     b58:	9c 01       	movw	r18, r24
     b5a:	ad 01       	movw	r20, r26
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	9a 81       	ldd	r25, Y+2	; 0x02
     b60:	fc 01       	movw	r30, r24
     b62:	e4 59       	subi	r30, 0x94	; 148
     b64:	ff 4f       	sbci	r31, 0xFF	; 255
     b66:	20 83       	st	Z, r18
     b68:	31 83       	std	Z+1, r19	; 0x01
     b6a:	42 83       	std	Z+2, r20	; 0x02
     b6c:	53 83       	std	Z+3, r21	; 0x03
	ptr->y_dot_dot_cmd= kp_rate*(ptr->y_cmd- ptr->z) + kd*(ptr->y_dot_cmd-ptr->y_dot);
     b6e:	80 91 05 01 	lds	r24, 0x0105
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	aa 27       	eor	r26, r26
     b78:	97 fd       	sbrc	r25, 7
     b7a:	a0 95       	com	r26
     b7c:	ba 2f       	mov	r27, r26
     b7e:	bc 01       	movw	r22, r24
     b80:	cd 01       	movw	r24, r26
     b82:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     b86:	7b 01       	movw	r14, r22
     b88:	8c 01       	movw	r16, r24
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	9a 81       	ldd	r25, Y+2	; 0x02
     b8e:	fc 01       	movw	r30, r24
     b90:	e8 5a       	subi	r30, 0xA8	; 168
     b92:	ff 4f       	sbci	r31, 0xFF	; 255
     b94:	80 81       	ld	r24, Z
     b96:	91 81       	ldd	r25, Z+1	; 0x01
     b98:	a2 81       	ldd	r26, Z+2	; 0x02
     b9a:	b3 81       	ldd	r27, Z+3	; 0x03
     b9c:	e9 81       	ldd	r30, Y+1	; 0x01
     b9e:	fa 81       	ldd	r31, Y+2	; 0x02
     ba0:	20 85       	ldd	r18, Z+8	; 0x08
     ba2:	31 85       	ldd	r19, Z+9	; 0x09
     ba4:	42 85       	ldd	r20, Z+10	; 0x0a
     ba6:	53 85       	ldd	r21, Z+11	; 0x0b
     ba8:	bc 01       	movw	r22, r24
     baa:	cd 01       	movw	r24, r26
     bac:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     bb0:	dc 01       	movw	r26, r24
     bb2:	cb 01       	movw	r24, r22
     bb4:	9c 01       	movw	r18, r24
     bb6:	ad 01       	movw	r20, r26
     bb8:	c8 01       	movw	r24, r16
     bba:	b7 01       	movw	r22, r14
     bbc:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     bc0:	dc 01       	movw	r26, r24
     bc2:	cb 01       	movw	r24, r22
     bc4:	5c 01       	movw	r10, r24
     bc6:	6d 01       	movw	r12, r26
     bc8:	80 91 f5 03 	lds	r24, 0x03F5
     bcc:	88 2f       	mov	r24, r24
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	aa 27       	eor	r26, r26
     bd2:	97 fd       	sbrc	r25, 7
     bd4:	a0 95       	com	r26
     bd6:	ba 2f       	mov	r27, r26
     bd8:	bc 01       	movw	r22, r24
     bda:	cd 01       	movw	r24, r26
     bdc:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
     be0:	7b 01       	movw	r14, r22
     be2:	8c 01       	movw	r16, r24
     be4:	89 81       	ldd	r24, Y+1	; 0x01
     be6:	9a 81       	ldd	r25, Y+2	; 0x02
     be8:	fc 01       	movw	r30, r24
     bea:	ec 59       	subi	r30, 0x9C	; 156
     bec:	ff 4f       	sbci	r31, 0xFF	; 255
     bee:	80 81       	ld	r24, Z
     bf0:	91 81       	ldd	r25, Z+1	; 0x01
     bf2:	a2 81       	ldd	r26, Z+2	; 0x02
     bf4:	b3 81       	ldd	r27, Z+3	; 0x03
     bf6:	e9 81       	ldd	r30, Y+1	; 0x01
     bf8:	fa 81       	ldd	r31, Y+2	; 0x02
     bfa:	20 89       	ldd	r18, Z+16	; 0x10
     bfc:	31 89       	ldd	r19, Z+17	; 0x11
     bfe:	42 89       	ldd	r20, Z+18	; 0x12
     c00:	53 89       	ldd	r21, Z+19	; 0x13
     c02:	bc 01       	movw	r22, r24
     c04:	cd 01       	movw	r24, r26
     c06:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
     c0a:	dc 01       	movw	r26, r24
     c0c:	cb 01       	movw	r24, r22
     c0e:	9c 01       	movw	r18, r24
     c10:	ad 01       	movw	r20, r26
     c12:	c8 01       	movw	r24, r16
     c14:	b7 01       	movw	r22, r14
     c16:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
     c1a:	dc 01       	movw	r26, r24
     c1c:	cb 01       	movw	r24, r22
     c1e:	9c 01       	movw	r18, r24
     c20:	ad 01       	movw	r20, r26
     c22:	c6 01       	movw	r24, r12
     c24:	b5 01       	movw	r22, r10
     c26:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
     c2a:	dc 01       	movw	r26, r24
     c2c:	cb 01       	movw	r24, r22
     c2e:	9c 01       	movw	r18, r24
     c30:	ad 01       	movw	r20, r26
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	fc 01       	movw	r30, r24
     c38:	e0 59       	subi	r30, 0x90	; 144
     c3a:	ff 4f       	sbci	r31, 0xFF	; 255
     c3c:	20 83       	st	Z, r18
     c3e:	31 83       	std	Z+1, r19	; 0x01
     c40:	42 83       	std	Z+2, r20	; 0x02
     c42:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     c44:	84 e6       	ldi	r24, 0x64	; 100
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskDelay>
     c4c:	25 cf       	rjmp	.-438    	; 0xa98 <lateral_controller+0x28>

00000c4e <SetPinDir>:
#include "DDIO_128.h"
#include "STD_TYPES.h"
#include "UTILS.h"

void SetPinDir(u8 PinNumber,u8 PinDirection)
{
     c4e:	df 93       	push	r29
     c50:	cf 93       	push	r28
     c52:	00 d0       	rcall	.+0      	; 0xc54 <SetPinDir+0x6>
     c54:	00 d0       	rcall	.+0      	; 0xc56 <SetPinDir+0x8>
     c56:	0f 92       	push	r0
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
     c5c:	8a 83       	std	Y+2, r24	; 0x02
     c5e:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/8;
     c60:	8a 81       	ldd	r24, Y+2	; 0x02
     c62:	86 95       	lsr	r24
     c64:	86 95       	lsr	r24
     c66:	86 95       	lsr	r24
     c68:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter){
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
     c6c:	28 2f       	mov	r18, r24
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	3d 83       	std	Y+5, r19	; 0x05
     c72:	2c 83       	std	Y+4, r18	; 0x04
     c74:	8c 81       	ldd	r24, Y+4	; 0x04
     c76:	9d 81       	ldd	r25, Y+5	; 0x05
     c78:	83 30       	cpi	r24, 0x03	; 3
     c7a:	91 05       	cpc	r25, r1
     c7c:	09 f4       	brne	.+2      	; 0xc80 <SetPinDir+0x32>
     c7e:	bf c0       	rjmp	.+382    	; 0xdfe <SetPinDir+0x1b0>
     c80:	2c 81       	ldd	r18, Y+4	; 0x04
     c82:	3d 81       	ldd	r19, Y+5	; 0x05
     c84:	24 30       	cpi	r18, 0x04	; 4
     c86:	31 05       	cpc	r19, r1
     c88:	8c f4       	brge	.+34     	; 0xcac <SetPinDir+0x5e>
     c8a:	8c 81       	ldd	r24, Y+4	; 0x04
     c8c:	9d 81       	ldd	r25, Y+5	; 0x05
     c8e:	81 30       	cpi	r24, 0x01	; 1
     c90:	91 05       	cpc	r25, r1
     c92:	09 f4       	brne	.+2      	; 0xc96 <SetPinDir+0x48>
     c94:	50 c0       	rjmp	.+160    	; 0xd36 <SetPinDir+0xe8>
     c96:	2c 81       	ldd	r18, Y+4	; 0x04
     c98:	3d 81       	ldd	r19, Y+5	; 0x05
     c9a:	22 30       	cpi	r18, 0x02	; 2
     c9c:	31 05       	cpc	r19, r1
     c9e:	0c f0       	brlt	.+2      	; 0xca2 <SetPinDir+0x54>
     ca0:	7c c0       	rjmp	.+248    	; 0xd9a <SetPinDir+0x14c>
     ca2:	8c 81       	ldd	r24, Y+4	; 0x04
     ca4:	9d 81       	ldd	r25, Y+5	; 0x05
     ca6:	00 97       	sbiw	r24, 0x00	; 0
     ca8:	a1 f0       	breq	.+40     	; 0xcd2 <SetPinDir+0x84>
     caa:	70 c1       	rjmp	.+736    	; 0xf8c <SetPinDir+0x33e>
     cac:	2c 81       	ldd	r18, Y+4	; 0x04
     cae:	3d 81       	ldd	r19, Y+5	; 0x05
     cb0:	25 30       	cpi	r18, 0x05	; 5
     cb2:	31 05       	cpc	r19, r1
     cb4:	09 f4       	brne	.+2      	; 0xcb8 <SetPinDir+0x6a>
     cb6:	07 c1       	rjmp	.+526    	; 0xec6 <SetPinDir+0x278>
     cb8:	8c 81       	ldd	r24, Y+4	; 0x04
     cba:	9d 81       	ldd	r25, Y+5	; 0x05
     cbc:	85 30       	cpi	r24, 0x05	; 5
     cbe:	91 05       	cpc	r25, r1
     cc0:	0c f4       	brge	.+2      	; 0xcc4 <SetPinDir+0x76>
     cc2:	cf c0       	rjmp	.+414    	; 0xe62 <SetPinDir+0x214>
     cc4:	2c 81       	ldd	r18, Y+4	; 0x04
     cc6:	3d 81       	ldd	r19, Y+5	; 0x05
     cc8:	26 30       	cpi	r18, 0x06	; 6
     cca:	31 05       	cpc	r19, r1
     ccc:	09 f4       	brne	.+2      	; 0xcd0 <SetPinDir+0x82>
     cce:	2d c1       	rjmp	.+602    	; 0xf2a <SetPinDir+0x2dc>
     cd0:	5d c1       	rjmp	.+698    	; 0xf8c <SetPinDir+0x33e>
		case (0):
			if(PinDirection)
     cd2:	8b 81       	ldd	r24, Y+3	; 0x03
     cd4:	88 23       	and	r24, r24
     cd6:	b9 f0       	breq	.+46     	; 0xd06 <SetPinDir+0xb8>
			SET_BIT(DDRA,PinNumber%8);
     cd8:	aa e3       	ldi	r26, 0x3A	; 58
     cda:	b0 e0       	ldi	r27, 0x00	; 0
     cdc:	ea e3       	ldi	r30, 0x3A	; 58
     cde:	f0 e0       	ldi	r31, 0x00	; 0
     ce0:	80 81       	ld	r24, Z
     ce2:	48 2f       	mov	r20, r24
     ce4:	8a 81       	ldd	r24, Y+2	; 0x02
     ce6:	88 2f       	mov	r24, r24
     ce8:	90 e0       	ldi	r25, 0x00	; 0
     cea:	9c 01       	movw	r18, r24
     cec:	27 70       	andi	r18, 0x07	; 7
     cee:	30 70       	andi	r19, 0x00	; 0
     cf0:	81 e0       	ldi	r24, 0x01	; 1
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	02 2e       	mov	r0, r18
     cf6:	02 c0       	rjmp	.+4      	; 0xcfc <SetPinDir+0xae>
     cf8:	88 0f       	add	r24, r24
     cfa:	99 1f       	adc	r25, r25
     cfc:	0a 94       	dec	r0
     cfe:	e2 f7       	brpl	.-8      	; 0xcf8 <SetPinDir+0xaa>
     d00:	84 2b       	or	r24, r20
     d02:	8c 93       	st	X, r24
     d04:	43 c1       	rjmp	.+646    	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRA,PinNumber%8);
     d06:	aa e3       	ldi	r26, 0x3A	; 58
     d08:	b0 e0       	ldi	r27, 0x00	; 0
     d0a:	ea e3       	ldi	r30, 0x3A	; 58
     d0c:	f0 e0       	ldi	r31, 0x00	; 0
     d0e:	80 81       	ld	r24, Z
     d10:	48 2f       	mov	r20, r24
     d12:	8a 81       	ldd	r24, Y+2	; 0x02
     d14:	88 2f       	mov	r24, r24
     d16:	90 e0       	ldi	r25, 0x00	; 0
     d18:	9c 01       	movw	r18, r24
     d1a:	27 70       	andi	r18, 0x07	; 7
     d1c:	30 70       	andi	r19, 0x00	; 0
     d1e:	81 e0       	ldi	r24, 0x01	; 1
     d20:	90 e0       	ldi	r25, 0x00	; 0
     d22:	02 2e       	mov	r0, r18
     d24:	02 c0       	rjmp	.+4      	; 0xd2a <SetPinDir+0xdc>
     d26:	88 0f       	add	r24, r24
     d28:	99 1f       	adc	r25, r25
     d2a:	0a 94       	dec	r0
     d2c:	e2 f7       	brpl	.-8      	; 0xd26 <SetPinDir+0xd8>
     d2e:	80 95       	com	r24
     d30:	84 23       	and	r24, r20
     d32:	8c 93       	st	X, r24
     d34:	2b c1       	rjmp	.+598    	; 0xf8c <SetPinDir+0x33e>
			break;

		case (1):
		    if(PinDirection)
     d36:	8b 81       	ldd	r24, Y+3	; 0x03
     d38:	88 23       	and	r24, r24
     d3a:	b9 f0       	breq	.+46     	; 0xd6a <SetPinDir+0x11c>
			SET_BIT(DDRB,PinNumber%8);
     d3c:	a7 e3       	ldi	r26, 0x37	; 55
     d3e:	b0 e0       	ldi	r27, 0x00	; 0
     d40:	e7 e3       	ldi	r30, 0x37	; 55
     d42:	f0 e0       	ldi	r31, 0x00	; 0
     d44:	80 81       	ld	r24, Z
     d46:	48 2f       	mov	r20, r24
     d48:	8a 81       	ldd	r24, Y+2	; 0x02
     d4a:	88 2f       	mov	r24, r24
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	9c 01       	movw	r18, r24
     d50:	27 70       	andi	r18, 0x07	; 7
     d52:	30 70       	andi	r19, 0x00	; 0
     d54:	81 e0       	ldi	r24, 0x01	; 1
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	02 2e       	mov	r0, r18
     d5a:	02 c0       	rjmp	.+4      	; 0xd60 <SetPinDir+0x112>
     d5c:	88 0f       	add	r24, r24
     d5e:	99 1f       	adc	r25, r25
     d60:	0a 94       	dec	r0
     d62:	e2 f7       	brpl	.-8      	; 0xd5c <SetPinDir+0x10e>
     d64:	84 2b       	or	r24, r20
     d66:	8c 93       	st	X, r24
     d68:	11 c1       	rjmp	.+546    	; 0xf8c <SetPinDir+0x33e>
	        else
			CLEAR_BIT(DDRB,PinNumber%8);
     d6a:	a7 e3       	ldi	r26, 0x37	; 55
     d6c:	b0 e0       	ldi	r27, 0x00	; 0
     d6e:	e7 e3       	ldi	r30, 0x37	; 55
     d70:	f0 e0       	ldi	r31, 0x00	; 0
     d72:	80 81       	ld	r24, Z
     d74:	48 2f       	mov	r20, r24
     d76:	8a 81       	ldd	r24, Y+2	; 0x02
     d78:	88 2f       	mov	r24, r24
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	9c 01       	movw	r18, r24
     d7e:	27 70       	andi	r18, 0x07	; 7
     d80:	30 70       	andi	r19, 0x00	; 0
     d82:	81 e0       	ldi	r24, 0x01	; 1
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	02 2e       	mov	r0, r18
     d88:	02 c0       	rjmp	.+4      	; 0xd8e <SetPinDir+0x140>
     d8a:	88 0f       	add	r24, r24
     d8c:	99 1f       	adc	r25, r25
     d8e:	0a 94       	dec	r0
     d90:	e2 f7       	brpl	.-8      	; 0xd8a <SetPinDir+0x13c>
     d92:	80 95       	com	r24
     d94:	84 23       	and	r24, r20
     d96:	8c 93       	st	X, r24
     d98:	f9 c0       	rjmp	.+498    	; 0xf8c <SetPinDir+0x33e>
			break;

		case  (2):
			if(PinDirection)
     d9a:	8b 81       	ldd	r24, Y+3	; 0x03
     d9c:	88 23       	and	r24, r24
     d9e:	b9 f0       	breq	.+46     	; 0xdce <SetPinDir+0x180>
			SET_BIT(DDRC,PinNumber%8);
     da0:	a4 e3       	ldi	r26, 0x34	; 52
     da2:	b0 e0       	ldi	r27, 0x00	; 0
     da4:	e4 e3       	ldi	r30, 0x34	; 52
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	80 81       	ld	r24, Z
     daa:	48 2f       	mov	r20, r24
     dac:	8a 81       	ldd	r24, Y+2	; 0x02
     dae:	88 2f       	mov	r24, r24
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	9c 01       	movw	r18, r24
     db4:	27 70       	andi	r18, 0x07	; 7
     db6:	30 70       	andi	r19, 0x00	; 0
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	02 2e       	mov	r0, r18
     dbe:	02 c0       	rjmp	.+4      	; 0xdc4 <SetPinDir+0x176>
     dc0:	88 0f       	add	r24, r24
     dc2:	99 1f       	adc	r25, r25
     dc4:	0a 94       	dec	r0
     dc6:	e2 f7       	brpl	.-8      	; 0xdc0 <SetPinDir+0x172>
     dc8:	84 2b       	or	r24, r20
     dca:	8c 93       	st	X, r24
     dcc:	df c0       	rjmp	.+446    	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRC,PinNumber%8);
     dce:	a4 e3       	ldi	r26, 0x34	; 52
     dd0:	b0 e0       	ldi	r27, 0x00	; 0
     dd2:	e4 e3       	ldi	r30, 0x34	; 52
     dd4:	f0 e0       	ldi	r31, 0x00	; 0
     dd6:	80 81       	ld	r24, Z
     dd8:	48 2f       	mov	r20, r24
     dda:	8a 81       	ldd	r24, Y+2	; 0x02
     ddc:	88 2f       	mov	r24, r24
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	9c 01       	movw	r18, r24
     de2:	27 70       	andi	r18, 0x07	; 7
     de4:	30 70       	andi	r19, 0x00	; 0
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	02 2e       	mov	r0, r18
     dec:	02 c0       	rjmp	.+4      	; 0xdf2 <SetPinDir+0x1a4>
     dee:	88 0f       	add	r24, r24
     df0:	99 1f       	adc	r25, r25
     df2:	0a 94       	dec	r0
     df4:	e2 f7       	brpl	.-8      	; 0xdee <SetPinDir+0x1a0>
     df6:	80 95       	com	r24
     df8:	84 23       	and	r24, r20
     dfa:	8c 93       	st	X, r24
     dfc:	c7 c0       	rjmp	.+398    	; 0xf8c <SetPinDir+0x33e>
            break;

		case (3):
			if(PinDirection)
     dfe:	8b 81       	ldd	r24, Y+3	; 0x03
     e00:	88 23       	and	r24, r24
     e02:	b9 f0       	breq	.+46     	; 0xe32 <SetPinDir+0x1e4>
			SET_BIT(DDRD,PinNumber%8);
     e04:	a1 e3       	ldi	r26, 0x31	; 49
     e06:	b0 e0       	ldi	r27, 0x00	; 0
     e08:	e1 e3       	ldi	r30, 0x31	; 49
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	80 81       	ld	r24, Z
     e0e:	48 2f       	mov	r20, r24
     e10:	8a 81       	ldd	r24, Y+2	; 0x02
     e12:	88 2f       	mov	r24, r24
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	9c 01       	movw	r18, r24
     e18:	27 70       	andi	r18, 0x07	; 7
     e1a:	30 70       	andi	r19, 0x00	; 0
     e1c:	81 e0       	ldi	r24, 0x01	; 1
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	02 2e       	mov	r0, r18
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <SetPinDir+0x1da>
     e24:	88 0f       	add	r24, r24
     e26:	99 1f       	adc	r25, r25
     e28:	0a 94       	dec	r0
     e2a:	e2 f7       	brpl	.-8      	; 0xe24 <SetPinDir+0x1d6>
     e2c:	84 2b       	or	r24, r20
     e2e:	8c 93       	st	X, r24
     e30:	ad c0       	rjmp	.+346    	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRD,PinNumber%8);
     e32:	a1 e3       	ldi	r26, 0x31	; 49
     e34:	b0 e0       	ldi	r27, 0x00	; 0
     e36:	e1 e3       	ldi	r30, 0x31	; 49
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	80 81       	ld	r24, Z
     e3c:	48 2f       	mov	r20, r24
     e3e:	8a 81       	ldd	r24, Y+2	; 0x02
     e40:	88 2f       	mov	r24, r24
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	9c 01       	movw	r18, r24
     e46:	27 70       	andi	r18, 0x07	; 7
     e48:	30 70       	andi	r19, 0x00	; 0
     e4a:	81 e0       	ldi	r24, 0x01	; 1
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	02 2e       	mov	r0, r18
     e50:	02 c0       	rjmp	.+4      	; 0xe56 <SetPinDir+0x208>
     e52:	88 0f       	add	r24, r24
     e54:	99 1f       	adc	r25, r25
     e56:	0a 94       	dec	r0
     e58:	e2 f7       	brpl	.-8      	; 0xe52 <SetPinDir+0x204>
     e5a:	80 95       	com	r24
     e5c:	84 23       	and	r24, r20
     e5e:	8c 93       	st	X, r24
     e60:	95 c0       	rjmp	.+298    	; 0xf8c <SetPinDir+0x33e>
			break;

		case (4):
			if(PinDirection)
     e62:	8b 81       	ldd	r24, Y+3	; 0x03
     e64:	88 23       	and	r24, r24
     e66:	b9 f0       	breq	.+46     	; 0xe96 <SetPinDir+0x248>
			SET_BIT(DDRE,PinNumber%8);
     e68:	a2 e2       	ldi	r26, 0x22	; 34
     e6a:	b0 e0       	ldi	r27, 0x00	; 0
     e6c:	e2 e2       	ldi	r30, 0x22	; 34
     e6e:	f0 e0       	ldi	r31, 0x00	; 0
     e70:	80 81       	ld	r24, Z
     e72:	48 2f       	mov	r20, r24
     e74:	8a 81       	ldd	r24, Y+2	; 0x02
     e76:	88 2f       	mov	r24, r24
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	9c 01       	movw	r18, r24
     e7c:	27 70       	andi	r18, 0x07	; 7
     e7e:	30 70       	andi	r19, 0x00	; 0
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	02 2e       	mov	r0, r18
     e86:	02 c0       	rjmp	.+4      	; 0xe8c <SetPinDir+0x23e>
     e88:	88 0f       	add	r24, r24
     e8a:	99 1f       	adc	r25, r25
     e8c:	0a 94       	dec	r0
     e8e:	e2 f7       	brpl	.-8      	; 0xe88 <SetPinDir+0x23a>
     e90:	84 2b       	or	r24, r20
     e92:	8c 93       	st	X, r24
     e94:	7b c0       	rjmp	.+246    	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRE,PinNumber%8);
     e96:	a2 e2       	ldi	r26, 0x22	; 34
     e98:	b0 e0       	ldi	r27, 0x00	; 0
     e9a:	e2 e2       	ldi	r30, 0x22	; 34
     e9c:	f0 e0       	ldi	r31, 0x00	; 0
     e9e:	80 81       	ld	r24, Z
     ea0:	48 2f       	mov	r20, r24
     ea2:	8a 81       	ldd	r24, Y+2	; 0x02
     ea4:	88 2f       	mov	r24, r24
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	9c 01       	movw	r18, r24
     eaa:	27 70       	andi	r18, 0x07	; 7
     eac:	30 70       	andi	r19, 0x00	; 0
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	02 2e       	mov	r0, r18
     eb4:	02 c0       	rjmp	.+4      	; 0xeba <SetPinDir+0x26c>
     eb6:	88 0f       	add	r24, r24
     eb8:	99 1f       	adc	r25, r25
     eba:	0a 94       	dec	r0
     ebc:	e2 f7       	brpl	.-8      	; 0xeb6 <SetPinDir+0x268>
     ebe:	80 95       	com	r24
     ec0:	84 23       	and	r24, r20
     ec2:	8c 93       	st	X, r24
     ec4:	63 c0       	rjmp	.+198    	; 0xf8c <SetPinDir+0x33e>
			break;

		case (5):
			if(PinDirection)
     ec6:	8b 81       	ldd	r24, Y+3	; 0x03
     ec8:	88 23       	and	r24, r24
     eca:	b9 f0       	breq	.+46     	; 0xefa <SetPinDir+0x2ac>
			SET_BIT(DDRF,PinNumber%8);
     ecc:	a1 e6       	ldi	r26, 0x61	; 97
     ece:	b0 e0       	ldi	r27, 0x00	; 0
     ed0:	e1 e6       	ldi	r30, 0x61	; 97
     ed2:	f0 e0       	ldi	r31, 0x00	; 0
     ed4:	80 81       	ld	r24, Z
     ed6:	48 2f       	mov	r20, r24
     ed8:	8a 81       	ldd	r24, Y+2	; 0x02
     eda:	88 2f       	mov	r24, r24
     edc:	90 e0       	ldi	r25, 0x00	; 0
     ede:	9c 01       	movw	r18, r24
     ee0:	27 70       	andi	r18, 0x07	; 7
     ee2:	30 70       	andi	r19, 0x00	; 0
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	02 2e       	mov	r0, r18
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <SetPinDir+0x2a2>
     eec:	88 0f       	add	r24, r24
     eee:	99 1f       	adc	r25, r25
     ef0:	0a 94       	dec	r0
     ef2:	e2 f7       	brpl	.-8      	; 0xeec <SetPinDir+0x29e>
     ef4:	84 2b       	or	r24, r20
     ef6:	8c 93       	st	X, r24
     ef8:	49 c0       	rjmp	.+146    	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRF,PinNumber%8);
     efa:	a1 e6       	ldi	r26, 0x61	; 97
     efc:	b0 e0       	ldi	r27, 0x00	; 0
     efe:	e1 e6       	ldi	r30, 0x61	; 97
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 81       	ld	r24, Z
     f04:	48 2f       	mov	r20, r24
     f06:	8a 81       	ldd	r24, Y+2	; 0x02
     f08:	88 2f       	mov	r24, r24
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	9c 01       	movw	r18, r24
     f0e:	27 70       	andi	r18, 0x07	; 7
     f10:	30 70       	andi	r19, 0x00	; 0
     f12:	81 e0       	ldi	r24, 0x01	; 1
     f14:	90 e0       	ldi	r25, 0x00	; 0
     f16:	02 2e       	mov	r0, r18
     f18:	02 c0       	rjmp	.+4      	; 0xf1e <SetPinDir+0x2d0>
     f1a:	88 0f       	add	r24, r24
     f1c:	99 1f       	adc	r25, r25
     f1e:	0a 94       	dec	r0
     f20:	e2 f7       	brpl	.-8      	; 0xf1a <SetPinDir+0x2cc>
     f22:	80 95       	com	r24
     f24:	84 23       	and	r24, r20
     f26:	8c 93       	st	X, r24
     f28:	31 c0       	rjmp	.+98     	; 0xf8c <SetPinDir+0x33e>
			break;

		case (6):
			if(PinDirection)
     f2a:	8b 81       	ldd	r24, Y+3	; 0x03
     f2c:	88 23       	and	r24, r24
     f2e:	b9 f0       	breq	.+46     	; 0xf5e <SetPinDir+0x310>
			SET_BIT(DDRG,PinNumber%8);
     f30:	a4 e6       	ldi	r26, 0x64	; 100
     f32:	b0 e0       	ldi	r27, 0x00	; 0
     f34:	e4 e6       	ldi	r30, 0x64	; 100
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	48 2f       	mov	r20, r24
     f3c:	8a 81       	ldd	r24, Y+2	; 0x02
     f3e:	88 2f       	mov	r24, r24
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	9c 01       	movw	r18, r24
     f44:	27 70       	andi	r18, 0x07	; 7
     f46:	30 70       	andi	r19, 0x00	; 0
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	02 2e       	mov	r0, r18
     f4e:	02 c0       	rjmp	.+4      	; 0xf54 <SetPinDir+0x306>
     f50:	88 0f       	add	r24, r24
     f52:	99 1f       	adc	r25, r25
     f54:	0a 94       	dec	r0
     f56:	e2 f7       	brpl	.-8      	; 0xf50 <SetPinDir+0x302>
     f58:	84 2b       	or	r24, r20
     f5a:	8c 93       	st	X, r24
     f5c:	17 c0       	rjmp	.+46     	; 0xf8c <SetPinDir+0x33e>
			else
			CLEAR_BIT(DDRG,PinNumber%8);
     f5e:	a4 e6       	ldi	r26, 0x64	; 100
     f60:	b0 e0       	ldi	r27, 0x00	; 0
     f62:	e4 e6       	ldi	r30, 0x64	; 100
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	80 81       	ld	r24, Z
     f68:	48 2f       	mov	r20, r24
     f6a:	8a 81       	ldd	r24, Y+2	; 0x02
     f6c:	88 2f       	mov	r24, r24
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	9c 01       	movw	r18, r24
     f72:	27 70       	andi	r18, 0x07	; 7
     f74:	30 70       	andi	r19, 0x00	; 0
     f76:	81 e0       	ldi	r24, 0x01	; 1
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	02 2e       	mov	r0, r18
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <SetPinDir+0x334>
     f7e:	88 0f       	add	r24, r24
     f80:	99 1f       	adc	r25, r25
     f82:	0a 94       	dec	r0
     f84:	e2 f7       	brpl	.-8      	; 0xf7e <SetPinDir+0x330>
     f86:	80 95       	com	r24
     f88:	84 23       	and	r24, r20
     f8a:	8c 93       	st	X, r24
			break;


	}
}
     f8c:	0f 90       	pop	r0
     f8e:	0f 90       	pop	r0
     f90:	0f 90       	pop	r0
     f92:	0f 90       	pop	r0
     f94:	0f 90       	pop	r0
     f96:	cf 91       	pop	r28
     f98:	df 91       	pop	r29
     f9a:	08 95       	ret

00000f9c <SetPinVal>:




void SetPinVal(u8 PinNumber,u8 PinValue)
{
     f9c:	df 93       	push	r29
     f9e:	cf 93       	push	r28
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <SetPinVal+0x6>
     fa2:	00 d0       	rcall	.+0      	; 0xfa4 <SetPinVal+0x8>
     fa4:	0f 92       	push	r0
     fa6:	cd b7       	in	r28, 0x3d	; 61
     fa8:	de b7       	in	r29, 0x3e	; 62
     faa:	8a 83       	std	Y+2, r24	; 0x02
     fac:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/8;
     fae:	8a 81       	ldd	r24, Y+2	; 0x02
     fb0:	86 95       	lsr	r24
     fb2:	86 95       	lsr	r24
     fb4:	86 95       	lsr	r24
     fb6:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter){
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	28 2f       	mov	r18, r24
     fbc:	30 e0       	ldi	r19, 0x00	; 0
     fbe:	3d 83       	std	Y+5, r19	; 0x05
     fc0:	2c 83       	std	Y+4, r18	; 0x04
     fc2:	8c 81       	ldd	r24, Y+4	; 0x04
     fc4:	9d 81       	ldd	r25, Y+5	; 0x05
     fc6:	83 30       	cpi	r24, 0x03	; 3
     fc8:	91 05       	cpc	r25, r1
     fca:	09 f4       	brne	.+2      	; 0xfce <SetPinVal+0x32>
     fcc:	bf c0       	rjmp	.+382    	; 0x114c <__stack+0x4d>
     fce:	2c 81       	ldd	r18, Y+4	; 0x04
     fd0:	3d 81       	ldd	r19, Y+5	; 0x05
     fd2:	24 30       	cpi	r18, 0x04	; 4
     fd4:	31 05       	cpc	r19, r1
     fd6:	8c f4       	brge	.+34     	; 0xffa <SetPinVal+0x5e>
     fd8:	8c 81       	ldd	r24, Y+4	; 0x04
     fda:	9d 81       	ldd	r25, Y+5	; 0x05
     fdc:	81 30       	cpi	r24, 0x01	; 1
     fde:	91 05       	cpc	r25, r1
     fe0:	09 f4       	brne	.+2      	; 0xfe4 <SetPinVal+0x48>
     fe2:	50 c0       	rjmp	.+160    	; 0x1084 <SetPinVal+0xe8>
     fe4:	2c 81       	ldd	r18, Y+4	; 0x04
     fe6:	3d 81       	ldd	r19, Y+5	; 0x05
     fe8:	22 30       	cpi	r18, 0x02	; 2
     fea:	31 05       	cpc	r19, r1
     fec:	0c f0       	brlt	.+2      	; 0xff0 <SetPinVal+0x54>
     fee:	7c c0       	rjmp	.+248    	; 0x10e8 <SetPinVal+0x14c>
     ff0:	8c 81       	ldd	r24, Y+4	; 0x04
     ff2:	9d 81       	ldd	r25, Y+5	; 0x05
     ff4:	00 97       	sbiw	r24, 0x00	; 0
     ff6:	a1 f0       	breq	.+40     	; 0x1020 <SetPinVal+0x84>
     ff8:	70 c1       	rjmp	.+736    	; 0x12da <__stack+0x1db>
     ffa:	2c 81       	ldd	r18, Y+4	; 0x04
     ffc:	3d 81       	ldd	r19, Y+5	; 0x05
     ffe:	25 30       	cpi	r18, 0x05	; 5
    1000:	31 05       	cpc	r19, r1
    1002:	09 f4       	brne	.+2      	; 0x1006 <SetPinVal+0x6a>
    1004:	07 c1       	rjmp	.+526    	; 0x1214 <__stack+0x115>
    1006:	8c 81       	ldd	r24, Y+4	; 0x04
    1008:	9d 81       	ldd	r25, Y+5	; 0x05
    100a:	85 30       	cpi	r24, 0x05	; 5
    100c:	91 05       	cpc	r25, r1
    100e:	0c f4       	brge	.+2      	; 0x1012 <SetPinVal+0x76>
    1010:	cf c0       	rjmp	.+414    	; 0x11b0 <__stack+0xb1>
    1012:	2c 81       	ldd	r18, Y+4	; 0x04
    1014:	3d 81       	ldd	r19, Y+5	; 0x05
    1016:	26 30       	cpi	r18, 0x06	; 6
    1018:	31 05       	cpc	r19, r1
    101a:	09 f4       	brne	.+2      	; 0x101e <SetPinVal+0x82>
    101c:	2d c1       	rjmp	.+602    	; 0x1278 <__stack+0x179>
    101e:	5d c1       	rjmp	.+698    	; 0x12da <__stack+0x1db>
		case (0):
		   if(PinValue)
    1020:	8b 81       	ldd	r24, Y+3	; 0x03
    1022:	88 23       	and	r24, r24
    1024:	b9 f0       	breq	.+46     	; 0x1054 <SetPinVal+0xb8>
			   SET_BIT(PORTA,PinNumber%8);
    1026:	ab e3       	ldi	r26, 0x3B	; 59
    1028:	b0 e0       	ldi	r27, 0x00	; 0
    102a:	eb e3       	ldi	r30, 0x3B	; 59
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	80 81       	ld	r24, Z
    1030:	48 2f       	mov	r20, r24
    1032:	8a 81       	ldd	r24, Y+2	; 0x02
    1034:	88 2f       	mov	r24, r24
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	9c 01       	movw	r18, r24
    103a:	27 70       	andi	r18, 0x07	; 7
    103c:	30 70       	andi	r19, 0x00	; 0
    103e:	81 e0       	ldi	r24, 0x01	; 1
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	02 2e       	mov	r0, r18
    1044:	02 c0       	rjmp	.+4      	; 0x104a <SetPinVal+0xae>
    1046:	88 0f       	add	r24, r24
    1048:	99 1f       	adc	r25, r25
    104a:	0a 94       	dec	r0
    104c:	e2 f7       	brpl	.-8      	; 0x1046 <SetPinVal+0xaa>
    104e:	84 2b       	or	r24, r20
    1050:	8c 93       	st	X, r24
    1052:	43 c1       	rjmp	.+646    	; 0x12da <__stack+0x1db>
		   else
			   CLEAR_BIT(PORTA,PinNumber%8);
    1054:	ab e3       	ldi	r26, 0x3B	; 59
    1056:	b0 e0       	ldi	r27, 0x00	; 0
    1058:	eb e3       	ldi	r30, 0x3B	; 59
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	48 2f       	mov	r20, r24
    1060:	8a 81       	ldd	r24, Y+2	; 0x02
    1062:	88 2f       	mov	r24, r24
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	9c 01       	movw	r18, r24
    1068:	27 70       	andi	r18, 0x07	; 7
    106a:	30 70       	andi	r19, 0x00	; 0
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	02 2e       	mov	r0, r18
    1072:	02 c0       	rjmp	.+4      	; 0x1078 <SetPinVal+0xdc>
    1074:	88 0f       	add	r24, r24
    1076:	99 1f       	adc	r25, r25
    1078:	0a 94       	dec	r0
    107a:	e2 f7       	brpl	.-8      	; 0x1074 <SetPinVal+0xd8>
    107c:	80 95       	com	r24
    107e:	84 23       	and	r24, r20
    1080:	8c 93       	st	X, r24
    1082:	2b c1       	rjmp	.+598    	; 0x12da <__stack+0x1db>
				break;

		case (1):
			if(PinValue)
    1084:	8b 81       	ldd	r24, Y+3	; 0x03
    1086:	88 23       	and	r24, r24
    1088:	b9 f0       	breq	.+46     	; 0x10b8 <SetPinVal+0x11c>
			    SET_BIT(PORTB,PinNumber%8);
    108a:	a8 e3       	ldi	r26, 0x38	; 56
    108c:	b0 e0       	ldi	r27, 0x00	; 0
    108e:	e8 e3       	ldi	r30, 0x38	; 56
    1090:	f0 e0       	ldi	r31, 0x00	; 0
    1092:	80 81       	ld	r24, Z
    1094:	48 2f       	mov	r20, r24
    1096:	8a 81       	ldd	r24, Y+2	; 0x02
    1098:	88 2f       	mov	r24, r24
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	9c 01       	movw	r18, r24
    109e:	27 70       	andi	r18, 0x07	; 7
    10a0:	30 70       	andi	r19, 0x00	; 0
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	02 2e       	mov	r0, r18
    10a8:	02 c0       	rjmp	.+4      	; 0x10ae <SetPinVal+0x112>
    10aa:	88 0f       	add	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	0a 94       	dec	r0
    10b0:	e2 f7       	brpl	.-8      	; 0x10aa <SetPinVal+0x10e>
    10b2:	84 2b       	or	r24, r20
    10b4:	8c 93       	st	X, r24
    10b6:	11 c1       	rjmp	.+546    	; 0x12da <__stack+0x1db>
			else
			    CLEAR_BIT(PORTB,PinNumber%8);
    10b8:	a8 e3       	ldi	r26, 0x38	; 56
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	e8 e3       	ldi	r30, 0x38	; 56
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	48 2f       	mov	r20, r24
    10c4:	8a 81       	ldd	r24, Y+2	; 0x02
    10c6:	88 2f       	mov	r24, r24
    10c8:	90 e0       	ldi	r25, 0x00	; 0
    10ca:	9c 01       	movw	r18, r24
    10cc:	27 70       	andi	r18, 0x07	; 7
    10ce:	30 70       	andi	r19, 0x00	; 0
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	90 e0       	ldi	r25, 0x00	; 0
    10d4:	02 2e       	mov	r0, r18
    10d6:	02 c0       	rjmp	.+4      	; 0x10dc <SetPinVal+0x140>
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	0a 94       	dec	r0
    10de:	e2 f7       	brpl	.-8      	; 0x10d8 <SetPinVal+0x13c>
    10e0:	80 95       	com	r24
    10e2:	84 23       	and	r24, r20
    10e4:	8c 93       	st	X, r24
    10e6:	f9 c0       	rjmp	.+498    	; 0x12da <__stack+0x1db>
				break;

		case (2):
			if(PinValue)
    10e8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ea:	88 23       	and	r24, r24
    10ec:	b9 f0       	breq	.+46     	; 0x111c <__stack+0x1d>
				SET_BIT(PORTC,PinNumber%8);
    10ee:	a5 e3       	ldi	r26, 0x35	; 53
    10f0:	b0 e0       	ldi	r27, 0x00	; 0
    10f2:	e5 e3       	ldi	r30, 0x35	; 53
    10f4:	f0 e0       	ldi	r31, 0x00	; 0
    10f6:	80 81       	ld	r24, Z
    10f8:	48 2f       	mov	r20, r24
    10fa:	8a 81       	ldd	r24, Y+2	; 0x02
    10fc:	88 2f       	mov	r24, r24
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	9c 01       	movw	r18, r24
    1102:	27 70       	andi	r18, 0x07	; 7
    1104:	30 70       	andi	r19, 0x00	; 0
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	02 2e       	mov	r0, r18
    110c:	02 c0       	rjmp	.+4      	; 0x1112 <__stack+0x13>
    110e:	88 0f       	add	r24, r24
    1110:	99 1f       	adc	r25, r25
    1112:	0a 94       	dec	r0
    1114:	e2 f7       	brpl	.-8      	; 0x110e <__stack+0xf>
    1116:	84 2b       	or	r24, r20
    1118:	8c 93       	st	X, r24
    111a:	df c0       	rjmp	.+446    	; 0x12da <__stack+0x1db>
			else
				CLEAR_BIT(PORTC,PinNumber%8);
    111c:	a5 e3       	ldi	r26, 0x35	; 53
    111e:	b0 e0       	ldi	r27, 0x00	; 0
    1120:	e5 e3       	ldi	r30, 0x35	; 53
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	48 2f       	mov	r20, r24
    1128:	8a 81       	ldd	r24, Y+2	; 0x02
    112a:	88 2f       	mov	r24, r24
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	9c 01       	movw	r18, r24
    1130:	27 70       	andi	r18, 0x07	; 7
    1132:	30 70       	andi	r19, 0x00	; 0
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	02 2e       	mov	r0, r18
    113a:	02 c0       	rjmp	.+4      	; 0x1140 <__stack+0x41>
    113c:	88 0f       	add	r24, r24
    113e:	99 1f       	adc	r25, r25
    1140:	0a 94       	dec	r0
    1142:	e2 f7       	brpl	.-8      	; 0x113c <__stack+0x3d>
    1144:	80 95       	com	r24
    1146:	84 23       	and	r24, r20
    1148:	8c 93       	st	X, r24
    114a:	c7 c0       	rjmp	.+398    	; 0x12da <__stack+0x1db>
         	 	break;

		case (3):
			if(PinValue)
    114c:	8b 81       	ldd	r24, Y+3	; 0x03
    114e:	88 23       	and	r24, r24
    1150:	b9 f0       	breq	.+46     	; 0x1180 <__stack+0x81>
				SET_BIT(PORTD,PinNumber%8);
    1152:	a2 e3       	ldi	r26, 0x32	; 50
    1154:	b0 e0       	ldi	r27, 0x00	; 0
    1156:	e2 e3       	ldi	r30, 0x32	; 50
    1158:	f0 e0       	ldi	r31, 0x00	; 0
    115a:	80 81       	ld	r24, Z
    115c:	48 2f       	mov	r20, r24
    115e:	8a 81       	ldd	r24, Y+2	; 0x02
    1160:	88 2f       	mov	r24, r24
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	9c 01       	movw	r18, r24
    1166:	27 70       	andi	r18, 0x07	; 7
    1168:	30 70       	andi	r19, 0x00	; 0
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	02 2e       	mov	r0, r18
    1170:	02 c0       	rjmp	.+4      	; 0x1176 <__stack+0x77>
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	0a 94       	dec	r0
    1178:	e2 f7       	brpl	.-8      	; 0x1172 <__stack+0x73>
    117a:	84 2b       	or	r24, r20
    117c:	8c 93       	st	X, r24
    117e:	ad c0       	rjmp	.+346    	; 0x12da <__stack+0x1db>
			else
				CLEAR_BIT(PORTD,PinNumber%8);
    1180:	a2 e3       	ldi	r26, 0x32	; 50
    1182:	b0 e0       	ldi	r27, 0x00	; 0
    1184:	e2 e3       	ldi	r30, 0x32	; 50
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	48 2f       	mov	r20, r24
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	88 2f       	mov	r24, r24
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	9c 01       	movw	r18, r24
    1194:	27 70       	andi	r18, 0x07	; 7
    1196:	30 70       	andi	r19, 0x00	; 0
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	02 2e       	mov	r0, r18
    119e:	02 c0       	rjmp	.+4      	; 0x11a4 <__stack+0xa5>
    11a0:	88 0f       	add	r24, r24
    11a2:	99 1f       	adc	r25, r25
    11a4:	0a 94       	dec	r0
    11a6:	e2 f7       	brpl	.-8      	; 0x11a0 <__stack+0xa1>
    11a8:	80 95       	com	r24
    11aa:	84 23       	and	r24, r20
    11ac:	8c 93       	st	X, r24
    11ae:	95 c0       	rjmp	.+298    	; 0x12da <__stack+0x1db>
        		break;

		case (4):
			if(PinValue)
    11b0:	8b 81       	ldd	r24, Y+3	; 0x03
    11b2:	88 23       	and	r24, r24
    11b4:	b9 f0       	breq	.+46     	; 0x11e4 <__stack+0xe5>
				SET_BIT(PORTE,PinNumber%8);
    11b6:	ae e2       	ldi	r26, 0x2E	; 46
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	ee e2       	ldi	r30, 0x2E	; 46
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	48 2f       	mov	r20, r24
    11c2:	8a 81       	ldd	r24, Y+2	; 0x02
    11c4:	88 2f       	mov	r24, r24
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	9c 01       	movw	r18, r24
    11ca:	27 70       	andi	r18, 0x07	; 7
    11cc:	30 70       	andi	r19, 0x00	; 0
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	02 2e       	mov	r0, r18
    11d4:	02 c0       	rjmp	.+4      	; 0x11da <__stack+0xdb>
    11d6:	88 0f       	add	r24, r24
    11d8:	99 1f       	adc	r25, r25
    11da:	0a 94       	dec	r0
    11dc:	e2 f7       	brpl	.-8      	; 0x11d6 <__stack+0xd7>
    11de:	84 2b       	or	r24, r20
    11e0:	8c 93       	st	X, r24
    11e2:	7b c0       	rjmp	.+246    	; 0x12da <__stack+0x1db>
			else
				CLEAR_BIT(PORTE,PinNumber%8);
    11e4:	ae e2       	ldi	r26, 0x2E	; 46
    11e6:	b0 e0       	ldi	r27, 0x00	; 0
    11e8:	ee e2       	ldi	r30, 0x2E	; 46
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	80 81       	ld	r24, Z
    11ee:	48 2f       	mov	r20, r24
    11f0:	8a 81       	ldd	r24, Y+2	; 0x02
    11f2:	88 2f       	mov	r24, r24
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	9c 01       	movw	r18, r24
    11f8:	27 70       	andi	r18, 0x07	; 7
    11fa:	30 70       	andi	r19, 0x00	; 0
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	02 2e       	mov	r0, r18
    1202:	02 c0       	rjmp	.+4      	; 0x1208 <__stack+0x109>
    1204:	88 0f       	add	r24, r24
    1206:	99 1f       	adc	r25, r25
    1208:	0a 94       	dec	r0
    120a:	e2 f7       	brpl	.-8      	; 0x1204 <__stack+0x105>
    120c:	80 95       	com	r24
    120e:	84 23       	and	r24, r20
    1210:	8c 93       	st	X, r24
    1212:	63 c0       	rjmp	.+198    	; 0x12da <__stack+0x1db>
        		break;

		case (5):
			if(PinValue)
    1214:	8b 81       	ldd	r24, Y+3	; 0x03
    1216:	88 23       	and	r24, r24
    1218:	b9 f0       	breq	.+46     	; 0x1248 <__stack+0x149>
				SET_BIT(PORTF,PinNumber%8);
    121a:	a2 e6       	ldi	r26, 0x62	; 98
    121c:	b0 e0       	ldi	r27, 0x00	; 0
    121e:	e2 e6       	ldi	r30, 0x62	; 98
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	80 81       	ld	r24, Z
    1224:	48 2f       	mov	r20, r24
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	88 2f       	mov	r24, r24
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	9c 01       	movw	r18, r24
    122e:	27 70       	andi	r18, 0x07	; 7
    1230:	30 70       	andi	r19, 0x00	; 0
    1232:	81 e0       	ldi	r24, 0x01	; 1
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	02 2e       	mov	r0, r18
    1238:	02 c0       	rjmp	.+4      	; 0x123e <__stack+0x13f>
    123a:	88 0f       	add	r24, r24
    123c:	99 1f       	adc	r25, r25
    123e:	0a 94       	dec	r0
    1240:	e2 f7       	brpl	.-8      	; 0x123a <__stack+0x13b>
    1242:	84 2b       	or	r24, r20
    1244:	8c 93       	st	X, r24
    1246:	49 c0       	rjmp	.+146    	; 0x12da <__stack+0x1db>
			else
				CLEAR_BIT(PORTF,PinNumber%8);
    1248:	a2 e6       	ldi	r26, 0x62	; 98
    124a:	b0 e0       	ldi	r27, 0x00	; 0
    124c:	e2 e6       	ldi	r30, 0x62	; 98
    124e:	f0 e0       	ldi	r31, 0x00	; 0
    1250:	80 81       	ld	r24, Z
    1252:	48 2f       	mov	r20, r24
    1254:	8a 81       	ldd	r24, Y+2	; 0x02
    1256:	88 2f       	mov	r24, r24
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	9c 01       	movw	r18, r24
    125c:	27 70       	andi	r18, 0x07	; 7
    125e:	30 70       	andi	r19, 0x00	; 0
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	90 e0       	ldi	r25, 0x00	; 0
    1264:	02 2e       	mov	r0, r18
    1266:	02 c0       	rjmp	.+4      	; 0x126c <__stack+0x16d>
    1268:	88 0f       	add	r24, r24
    126a:	99 1f       	adc	r25, r25
    126c:	0a 94       	dec	r0
    126e:	e2 f7       	brpl	.-8      	; 0x1268 <__stack+0x169>
    1270:	80 95       	com	r24
    1272:	84 23       	and	r24, r20
    1274:	8c 93       	st	X, r24
    1276:	31 c0       	rjmp	.+98     	; 0x12da <__stack+0x1db>
				break;

		case (6):
			if(PinValue)
    1278:	8b 81       	ldd	r24, Y+3	; 0x03
    127a:	88 23       	and	r24, r24
    127c:	b9 f0       	breq	.+46     	; 0x12ac <__stack+0x1ad>
				SET_BIT(PORTG,PinNumber%8);
    127e:	a5 e6       	ldi	r26, 0x65	; 101
    1280:	b0 e0       	ldi	r27, 0x00	; 0
    1282:	e5 e6       	ldi	r30, 0x65	; 101
    1284:	f0 e0       	ldi	r31, 0x00	; 0
    1286:	80 81       	ld	r24, Z
    1288:	48 2f       	mov	r20, r24
    128a:	8a 81       	ldd	r24, Y+2	; 0x02
    128c:	88 2f       	mov	r24, r24
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	9c 01       	movw	r18, r24
    1292:	27 70       	andi	r18, 0x07	; 7
    1294:	30 70       	andi	r19, 0x00	; 0
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	02 2e       	mov	r0, r18
    129c:	02 c0       	rjmp	.+4      	; 0x12a2 <__stack+0x1a3>
    129e:	88 0f       	add	r24, r24
    12a0:	99 1f       	adc	r25, r25
    12a2:	0a 94       	dec	r0
    12a4:	e2 f7       	brpl	.-8      	; 0x129e <__stack+0x19f>
    12a6:	84 2b       	or	r24, r20
    12a8:	8c 93       	st	X, r24
    12aa:	17 c0       	rjmp	.+46     	; 0x12da <__stack+0x1db>
			else
				CLEAR_BIT(PORTG,PinNumber%8);
    12ac:	a5 e6       	ldi	r26, 0x65	; 101
    12ae:	b0 e0       	ldi	r27, 0x00	; 0
    12b0:	e5 e6       	ldi	r30, 0x65	; 101
    12b2:	f0 e0       	ldi	r31, 0x00	; 0
    12b4:	80 81       	ld	r24, Z
    12b6:	48 2f       	mov	r20, r24
    12b8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ba:	88 2f       	mov	r24, r24
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	9c 01       	movw	r18, r24
    12c0:	27 70       	andi	r18, 0x07	; 7
    12c2:	30 70       	andi	r19, 0x00	; 0
    12c4:	81 e0       	ldi	r24, 0x01	; 1
    12c6:	90 e0       	ldi	r25, 0x00	; 0
    12c8:	02 2e       	mov	r0, r18
    12ca:	02 c0       	rjmp	.+4      	; 0x12d0 <__stack+0x1d1>
    12cc:	88 0f       	add	r24, r24
    12ce:	99 1f       	adc	r25, r25
    12d0:	0a 94       	dec	r0
    12d2:	e2 f7       	brpl	.-8      	; 0x12cc <__stack+0x1cd>
    12d4:	80 95       	com	r24
    12d6:	84 23       	and	r24, r20
    12d8:	8c 93       	st	X, r24
        		break;


	}

}
    12da:	0f 90       	pop	r0
    12dc:	0f 90       	pop	r0
    12de:	0f 90       	pop	r0
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	cf 91       	pop	r28
    12e6:	df 91       	pop	r29
    12e8:	08 95       	ret

000012ea <ReadPinVal>:

u8 ReadPinVal(u8 PinNumber)
{
    12ea:	df 93       	push	r29
    12ec:	cf 93       	push	r28
    12ee:	00 d0       	rcall	.+0      	; 0x12f0 <ReadPinVal+0x6>
    12f0:	00 d0       	rcall	.+0      	; 0x12f2 <ReadPinVal+0x8>
    12f2:	00 d0       	rcall	.+0      	; 0x12f4 <ReadPinVal+0xa>
    12f4:	cd b7       	in	r28, 0x3d	; 61
    12f6:	de b7       	in	r29, 0x3e	; 62
    12f8:	8a 83       	std	Y+2, r24	; 0x02
	u8 PortLetter = PinNumber/8;
    12fa:	8a 81       	ldd	r24, Y+2	; 0x02
    12fc:	86 95       	lsr	r24
    12fe:	86 95       	lsr	r24
    1300:	86 95       	lsr	r24
    1302:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter)
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	28 2f       	mov	r18, r24
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	3d 83       	std	Y+5, r19	; 0x05
    130c:	2c 83       	std	Y+4, r18	; 0x04
    130e:	4c 81       	ldd	r20, Y+4	; 0x04
    1310:	5d 81       	ldd	r21, Y+5	; 0x05
    1312:	43 30       	cpi	r20, 0x03	; 3
    1314:	51 05       	cpc	r21, r1
    1316:	09 f4       	brne	.+2      	; 0x131a <ReadPinVal+0x30>
    1318:	67 c0       	rjmp	.+206    	; 0x13e8 <ReadPinVal+0xfe>
    131a:	8c 81       	ldd	r24, Y+4	; 0x04
    131c:	9d 81       	ldd	r25, Y+5	; 0x05
    131e:	84 30       	cpi	r24, 0x04	; 4
    1320:	91 05       	cpc	r25, r1
    1322:	84 f4       	brge	.+32     	; 0x1344 <ReadPinVal+0x5a>
    1324:	2c 81       	ldd	r18, Y+4	; 0x04
    1326:	3d 81       	ldd	r19, Y+5	; 0x05
    1328:	21 30       	cpi	r18, 0x01	; 1
    132a:	31 05       	cpc	r19, r1
    132c:	99 f1       	breq	.+102    	; 0x1394 <ReadPinVal+0xaa>
    132e:	4c 81       	ldd	r20, Y+4	; 0x04
    1330:	5d 81       	ldd	r21, Y+5	; 0x05
    1332:	42 30       	cpi	r20, 0x02	; 2
    1334:	51 05       	cpc	r21, r1
    1336:	0c f0       	brlt	.+2      	; 0x133a <ReadPinVal+0x50>
    1338:	42 c0       	rjmp	.+132    	; 0x13be <ReadPinVal+0xd4>
    133a:	8c 81       	ldd	r24, Y+4	; 0x04
    133c:	9d 81       	ldd	r25, Y+5	; 0x05
    133e:	00 97       	sbiw	r24, 0x00	; 0
    1340:	a1 f0       	breq	.+40     	; 0x136a <ReadPinVal+0x80>
    1342:	a6 c0       	rjmp	.+332    	; 0x1490 <ReadPinVal+0x1a6>
    1344:	2c 81       	ldd	r18, Y+4	; 0x04
    1346:	3d 81       	ldd	r19, Y+5	; 0x05
    1348:	25 30       	cpi	r18, 0x05	; 5
    134a:	31 05       	cpc	r19, r1
    134c:	09 f4       	brne	.+2      	; 0x1350 <ReadPinVal+0x66>
    134e:	76 c0       	rjmp	.+236    	; 0x143c <ReadPinVal+0x152>
    1350:	4c 81       	ldd	r20, Y+4	; 0x04
    1352:	5d 81       	ldd	r21, Y+5	; 0x05
    1354:	45 30       	cpi	r20, 0x05	; 5
    1356:	51 05       	cpc	r21, r1
    1358:	0c f4       	brge	.+2      	; 0x135c <ReadPinVal+0x72>
    135a:	5b c0       	rjmp	.+182    	; 0x1412 <ReadPinVal+0x128>
    135c:	8c 81       	ldd	r24, Y+4	; 0x04
    135e:	9d 81       	ldd	r25, Y+5	; 0x05
    1360:	86 30       	cpi	r24, 0x06	; 6
    1362:	91 05       	cpc	r25, r1
    1364:	09 f4       	brne	.+2      	; 0x1368 <ReadPinVal+0x7e>
    1366:	7f c0       	rjmp	.+254    	; 0x1466 <ReadPinVal+0x17c>
    1368:	93 c0       	rjmp	.+294    	; 0x1490 <ReadPinVal+0x1a6>
	{
		case (0):
				return (GET_BIT(PINA,PinNumber%8));
    136a:	e9 e3       	ldi	r30, 0x39	; 57
    136c:	f0 e0       	ldi	r31, 0x00	; 0
    136e:	80 81       	ld	r24, Z
    1370:	28 2f       	mov	r18, r24
    1372:	30 e0       	ldi	r19, 0x00	; 0
    1374:	8a 81       	ldd	r24, Y+2	; 0x02
    1376:	88 2f       	mov	r24, r24
    1378:	90 e0       	ldi	r25, 0x00	; 0
    137a:	87 70       	andi	r24, 0x07	; 7
    137c:	90 70       	andi	r25, 0x00	; 0
    137e:	a9 01       	movw	r20, r18
    1380:	02 c0       	rjmp	.+4      	; 0x1386 <ReadPinVal+0x9c>
    1382:	55 95       	asr	r21
    1384:	47 95       	ror	r20
    1386:	8a 95       	dec	r24
    1388:	e2 f7       	brpl	.-8      	; 0x1382 <ReadPinVal+0x98>
    138a:	ca 01       	movw	r24, r20
    138c:	58 2f       	mov	r21, r24
    138e:	51 70       	andi	r21, 0x01	; 1
    1390:	5b 83       	std	Y+3, r21	; 0x03
    1392:	7f c0       	rjmp	.+254    	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (1):
				return (GET_BIT(PINB,PinNumber%8));
    1394:	e6 e3       	ldi	r30, 0x36	; 54
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	80 81       	ld	r24, Z
    139a:	28 2f       	mov	r18, r24
    139c:	30 e0       	ldi	r19, 0x00	; 0
    139e:	8a 81       	ldd	r24, Y+2	; 0x02
    13a0:	88 2f       	mov	r24, r24
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	87 70       	andi	r24, 0x07	; 7
    13a6:	90 70       	andi	r25, 0x00	; 0
    13a8:	a9 01       	movw	r20, r18
    13aa:	02 c0       	rjmp	.+4      	; 0x13b0 <ReadPinVal+0xc6>
    13ac:	55 95       	asr	r21
    13ae:	47 95       	ror	r20
    13b0:	8a 95       	dec	r24
    13b2:	e2 f7       	brpl	.-8      	; 0x13ac <ReadPinVal+0xc2>
    13b4:	ca 01       	movw	r24, r20
    13b6:	58 2f       	mov	r21, r24
    13b8:	51 70       	andi	r21, 0x01	; 1
    13ba:	5b 83       	std	Y+3, r21	; 0x03
    13bc:	6a c0       	rjmp	.+212    	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (2):
				return (GET_BIT(PINC,PinNumber%8));
    13be:	e3 e3       	ldi	r30, 0x33	; 51
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	28 2f       	mov	r18, r24
    13c6:	30 e0       	ldi	r19, 0x00	; 0
    13c8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ca:	88 2f       	mov	r24, r24
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	87 70       	andi	r24, 0x07	; 7
    13d0:	90 70       	andi	r25, 0x00	; 0
    13d2:	a9 01       	movw	r20, r18
    13d4:	02 c0       	rjmp	.+4      	; 0x13da <ReadPinVal+0xf0>
    13d6:	55 95       	asr	r21
    13d8:	47 95       	ror	r20
    13da:	8a 95       	dec	r24
    13dc:	e2 f7       	brpl	.-8      	; 0x13d6 <ReadPinVal+0xec>
    13de:	ca 01       	movw	r24, r20
    13e0:	58 2f       	mov	r21, r24
    13e2:	51 70       	andi	r21, 0x01	; 1
    13e4:	5b 83       	std	Y+3, r21	; 0x03
    13e6:	55 c0       	rjmp	.+170    	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (3):
				return (GET_BIT(PIND,PinNumber%8));
    13e8:	e0 e3       	ldi	r30, 0x30	; 48
    13ea:	f0 e0       	ldi	r31, 0x00	; 0
    13ec:	80 81       	ld	r24, Z
    13ee:	28 2f       	mov	r18, r24
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	8a 81       	ldd	r24, Y+2	; 0x02
    13f4:	88 2f       	mov	r24, r24
    13f6:	90 e0       	ldi	r25, 0x00	; 0
    13f8:	87 70       	andi	r24, 0x07	; 7
    13fa:	90 70       	andi	r25, 0x00	; 0
    13fc:	a9 01       	movw	r20, r18
    13fe:	02 c0       	rjmp	.+4      	; 0x1404 <ReadPinVal+0x11a>
    1400:	55 95       	asr	r21
    1402:	47 95       	ror	r20
    1404:	8a 95       	dec	r24
    1406:	e2 f7       	brpl	.-8      	; 0x1400 <ReadPinVal+0x116>
    1408:	ca 01       	movw	r24, r20
    140a:	58 2f       	mov	r21, r24
    140c:	51 70       	andi	r21, 0x01	; 1
    140e:	5b 83       	std	Y+3, r21	; 0x03
    1410:	40 c0       	rjmp	.+128    	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (4):
				return (GET_BIT(PINE,PinNumber%8));
    1412:	e3 e2       	ldi	r30, 0x23	; 35
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	80 81       	ld	r24, Z
    1418:	28 2f       	mov	r18, r24
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	88 2f       	mov	r24, r24
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	87 70       	andi	r24, 0x07	; 7
    1424:	90 70       	andi	r25, 0x00	; 0
    1426:	a9 01       	movw	r20, r18
    1428:	02 c0       	rjmp	.+4      	; 0x142e <ReadPinVal+0x144>
    142a:	55 95       	asr	r21
    142c:	47 95       	ror	r20
    142e:	8a 95       	dec	r24
    1430:	e2 f7       	brpl	.-8      	; 0x142a <ReadPinVal+0x140>
    1432:	ca 01       	movw	r24, r20
    1434:	58 2f       	mov	r21, r24
    1436:	51 70       	andi	r21, 0x01	; 1
    1438:	5b 83       	std	Y+3, r21	; 0x03
    143a:	2b c0       	rjmp	.+86     	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (5):
				return (GET_BIT(PINF,PinNumber%8));
    143c:	e0 e2       	ldi	r30, 0x20	; 32
    143e:	f0 e0       	ldi	r31, 0x00	; 0
    1440:	80 81       	ld	r24, Z
    1442:	28 2f       	mov	r18, r24
    1444:	30 e0       	ldi	r19, 0x00	; 0
    1446:	8a 81       	ldd	r24, Y+2	; 0x02
    1448:	88 2f       	mov	r24, r24
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	87 70       	andi	r24, 0x07	; 7
    144e:	90 70       	andi	r25, 0x00	; 0
    1450:	a9 01       	movw	r20, r18
    1452:	02 c0       	rjmp	.+4      	; 0x1458 <ReadPinVal+0x16e>
    1454:	55 95       	asr	r21
    1456:	47 95       	ror	r20
    1458:	8a 95       	dec	r24
    145a:	e2 f7       	brpl	.-8      	; 0x1454 <ReadPinVal+0x16a>
    145c:	ca 01       	movw	r24, r20
    145e:	58 2f       	mov	r21, r24
    1460:	51 70       	andi	r21, 0x01	; 1
    1462:	5b 83       	std	Y+3, r21	; 0x03
    1464:	16 c0       	rjmp	.+44     	; 0x1492 <ReadPinVal+0x1a8>
				break;
		case (6):
				return (GET_BIT(PING,PinNumber%8));
    1466:	e3 e6       	ldi	r30, 0x63	; 99
    1468:	f0 e0       	ldi	r31, 0x00	; 0
    146a:	80 81       	ld	r24, Z
    146c:	28 2f       	mov	r18, r24
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	8a 81       	ldd	r24, Y+2	; 0x02
    1472:	88 2f       	mov	r24, r24
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	87 70       	andi	r24, 0x07	; 7
    1478:	90 70       	andi	r25, 0x00	; 0
    147a:	a9 01       	movw	r20, r18
    147c:	02 c0       	rjmp	.+4      	; 0x1482 <ReadPinVal+0x198>
    147e:	55 95       	asr	r21
    1480:	47 95       	ror	r20
    1482:	8a 95       	dec	r24
    1484:	e2 f7       	brpl	.-8      	; 0x147e <ReadPinVal+0x194>
    1486:	ca 01       	movw	r24, r20
    1488:	58 2f       	mov	r21, r24
    148a:	51 70       	andi	r21, 0x01	; 1
    148c:	5b 83       	std	Y+3, r21	; 0x03
    148e:	01 c0       	rjmp	.+2      	; 0x1492 <ReadPinVal+0x1a8>
    1490:	02 c0       	rjmp	.+4      	; 0x1496 <ReadPinVal+0x1ac>
				break;
	}

}
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	8e 83       	std	Y+6, r24	; 0x06
    1496:	8e 81       	ldd	r24, Y+6	; 0x06
    1498:	26 96       	adiw	r28, 0x06	; 6
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	de bf       	out	0x3e, r29	; 62
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	cd bf       	out	0x3d, r28	; 61
    14a4:	cf 91       	pop	r28
    14a6:	df 91       	pop	r29
    14a8:	08 95       	ret

000014aa <MPU_Init>:
 * *******************************************************************************************************************************************************
 */


void MPU_Init()
{
    14aa:	df 93       	push	r29
    14ac:	cf 93       	push	r28
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
	I2C_Add(0xD0);								//Call slave Start_Waitress and wait for Ack
    14b2:	80 ed       	ldi	r24, 0xD0	; 208
    14b4:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(SMPRLT_DIV);						//Send SMPLRT reg Start_Waitress
    14b8:	89 e1       	ldi	r24, 0x19	; 25
    14ba:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x00);							//Set to 1KHz / 1 = 1KHz sample rate, where 1 is SMPLRT_DIV value, and 1KHz is the gyro output rate when DLPF is activated
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    14c4:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>

	I2C_Add(0xD0);
    14c8:	80 ed       	ldi	r24, 0xD0	; 208
    14ca:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(CONFIG_REG);						//Send CONFG REG Start_Waitress
    14ce:	8a e1       	ldi	r24, 0x1A	; 26
    14d0:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x00);							//Set Config reg to: FSYNC -> Disabled, DLPF_CONFG to 000 = Max bandwidth and least delay
    14d4:	80 e0       	ldi	r24, 0x00	; 0
    14d6:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    14da:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>

	I2C_Add(0xD0);
    14de:	80 ed       	ldi	r24, 0xD0	; 208
    14e0:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(GYRO_CONFIG);						//Send GYRO CONFG REG Start_Waitress
    14e4:	8b e1       	ldi	r24, 0x1B	; 27
    14e6:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x18);							//Set FSEL to 3 -> range = -2000 to 2000 degrees per sec.
    14ea:	88 e1       	ldi	r24, 0x18	; 24
    14ec:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    14f0:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>

	I2C_Add(0xD0);
    14f4:	80 ed       	ldi	r24, 0xD0	; 208
    14f6:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(ACCEL_CONFIG);					//Send ACCEL CONFIG REG Start_Waitress
    14fa:	8c e1       	ldi	r24, 0x1C	; 28
    14fc:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x18);							//Set AFS_SEL to 3 -> range = -16g to 16g
    1500:	88 e1       	ldi	r24, 0x18	; 24
    1502:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    1506:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>

	I2C_Add(0xD0);
    150a:	80 ed       	ldi	r24, 0xD0	; 208
    150c:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(PWR_MGMT_1);						//Send PWR REG Start_Waiterss
    1510:	8b e6       	ldi	r24, 0x6B	; 107
    1512:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x01);							//Set to PLL with x-axis reference
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    151c:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>

	I2C_Add(0xD0);
    1520:	80 ed       	ldi	r24, 0xD0	; 208
    1522:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(INT_ENABLE);						//Send INT REG Start_Waiterss
    1526:	88 e3       	ldi	r24, 0x38	; 56
    1528:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Write(0x01);							//Set DATA Read_AckY BIT to 1
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Stop();
    1532:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>
}
    1536:	cf 91       	pop	r28
    1538:	df 91       	pop	r29
    153a:	08 95       	ret

0000153c <Read_IMU_Values>:

void Read_IMU_Values(accel *acc, bodyrate *gyro)
{
    153c:	0f 93       	push	r16
    153e:	1f 93       	push	r17
    1540:	df 93       	push	r29
    1542:	cf 93       	push	r28
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
    1548:	28 97       	sbiw	r28, 0x08	; 8
    154a:	0f b6       	in	r0, 0x3f	; 63
    154c:	f8 94       	cli
    154e:	de bf       	out	0x3e, r29	; 62
    1550:	0f be       	out	0x3f, r0	; 63
    1552:	cd bf       	out	0x3d, r28	; 61
    1554:	9e 83       	std	Y+6, r25	; 0x06
    1556:	8d 83       	std	Y+5, r24	; 0x05
    1558:	78 87       	std	Y+8, r23	; 0x08
    155a:	6f 83       	std	Y+7, r22	; 0x07
	f32 temp;
	I2C_Add(0xD0);
    155c:	80 ed       	ldi	r24, 0xD0	; 208
    155e:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	I2C_Write(ACCEL_XOUT_H);					//Set start Start_Waitress
    1562:	8b e3       	ldi	r24, 0x3B	; 59
    1564:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <I2C_Write>
	I2C_Add(0xD1);								//Send slave Start_Waitress + Read_Ack bit
    1568:	81 ed       	ldi	r24, 0xD1	; 209
    156a:	0e 94 1b 18 	call	0x3036	; 0x3036 <I2C_Add>
	acc->x = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());
    156e:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1572:	88 2f       	mov	r24, r24
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	18 2f       	mov	r17, r24
    1578:	00 27       	eor	r16, r16
    157a:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    157e:	88 2f       	mov	r24, r24
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	80 2b       	or	r24, r16
    1584:	91 2b       	or	r25, r17
    1586:	cc 01       	movw	r24, r24
    1588:	a0 e0       	ldi	r26, 0x00	; 0
    158a:	b0 e0       	ldi	r27, 0x00	; 0
    158c:	bc 01       	movw	r22, r24
    158e:	cd 01       	movw	r24, r26
    1590:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    1594:	dc 01       	movw	r26, r24
    1596:	cb 01       	movw	r24, r22
    1598:	ed 81       	ldd	r30, Y+5	; 0x05
    159a:	fe 81       	ldd	r31, Y+6	; 0x06
    159c:	80 83       	st	Z, r24
    159e:	91 83       	std	Z+1, r25	; 0x01
    15a0:	a2 83       	std	Z+2, r26	; 0x02
    15a2:	b3 83       	std	Z+3, r27	; 0x03
	acc->y = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());			//Read_Ack HIGH  then LOW
    15a4:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    15a8:	88 2f       	mov	r24, r24
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	18 2f       	mov	r17, r24
    15ae:	00 27       	eor	r16, r16
    15b0:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    15b4:	88 2f       	mov	r24, r24
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	80 2b       	or	r24, r16
    15ba:	91 2b       	or	r25, r17
    15bc:	cc 01       	movw	r24, r24
    15be:	a0 e0       	ldi	r26, 0x00	; 0
    15c0:	b0 e0       	ldi	r27, 0x00	; 0
    15c2:	bc 01       	movw	r22, r24
    15c4:	cd 01       	movw	r24, r26
    15c6:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    15ca:	dc 01       	movw	r26, r24
    15cc:	cb 01       	movw	r24, r22
    15ce:	ed 81       	ldd	r30, Y+5	; 0x05
    15d0:	fe 81       	ldd	r31, Y+6	; 0x06
    15d2:	84 83       	std	Z+4, r24	; 0x04
    15d4:	95 83       	std	Z+5, r25	; 0x05
    15d6:	a6 83       	std	Z+6, r26	; 0x06
    15d8:	b7 83       	std	Z+7, r27	; 0x07
	acc->z = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());			/////////////////////
    15da:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    15de:	88 2f       	mov	r24, r24
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	18 2f       	mov	r17, r24
    15e4:	00 27       	eor	r16, r16
    15e6:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    15ea:	88 2f       	mov	r24, r24
    15ec:	90 e0       	ldi	r25, 0x00	; 0
    15ee:	80 2b       	or	r24, r16
    15f0:	91 2b       	or	r25, r17
    15f2:	cc 01       	movw	r24, r24
    15f4:	a0 e0       	ldi	r26, 0x00	; 0
    15f6:	b0 e0       	ldi	r27, 0x00	; 0
    15f8:	bc 01       	movw	r22, r24
    15fa:	cd 01       	movw	r24, r26
    15fc:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    1600:	dc 01       	movw	r26, r24
    1602:	cb 01       	movw	r24, r22
    1604:	ed 81       	ldd	r30, Y+5	; 0x05
    1606:	fe 81       	ldd	r31, Y+6	; 0x06
    1608:	80 87       	std	Z+8, r24	; 0x08
    160a:	91 87       	std	Z+9, r25	; 0x09
    160c:	a2 87       	std	Z+10, r26	; 0x0a
    160e:	b3 87       	std	Z+11, r27	; 0x0b
	temp = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());
    1610:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1614:	88 2f       	mov	r24, r24
    1616:	90 e0       	ldi	r25, 0x00	; 0
    1618:	18 2f       	mov	r17, r24
    161a:	00 27       	eor	r16, r16
    161c:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1620:	88 2f       	mov	r24, r24
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	80 2b       	or	r24, r16
    1626:	91 2b       	or	r25, r17
    1628:	cc 01       	movw	r24, r24
    162a:	a0 e0       	ldi	r26, 0x00	; 0
    162c:	b0 e0       	ldi	r27, 0x00	; 0
    162e:	bc 01       	movw	r22, r24
    1630:	cd 01       	movw	r24, r26
    1632:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    1636:	dc 01       	movw	r26, r24
    1638:	cb 01       	movw	r24, r22
    163a:	89 83       	std	Y+1, r24	; 0x01
    163c:	9a 83       	std	Y+2, r25	; 0x02
    163e:	ab 83       	std	Y+3, r26	; 0x03
    1640:	bc 83       	std	Y+4, r27	; 0x04
	gyro->p = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());
    1642:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1646:	88 2f       	mov	r24, r24
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	18 2f       	mov	r17, r24
    164c:	00 27       	eor	r16, r16
    164e:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1652:	88 2f       	mov	r24, r24
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	80 2b       	or	r24, r16
    1658:	91 2b       	or	r25, r17
    165a:	cc 01       	movw	r24, r24
    165c:	a0 e0       	ldi	r26, 0x00	; 0
    165e:	b0 e0       	ldi	r27, 0x00	; 0
    1660:	bc 01       	movw	r22, r24
    1662:	cd 01       	movw	r24, r26
    1664:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    1668:	dc 01       	movw	r26, r24
    166a:	cb 01       	movw	r24, r22
    166c:	ef 81       	ldd	r30, Y+7	; 0x07
    166e:	f8 85       	ldd	r31, Y+8	; 0x08
    1670:	80 83       	st	Z, r24
    1672:	91 83       	std	Z+1, r25	; 0x01
    1674:	a2 83       	std	Z+2, r26	; 0x02
    1676:	b3 83       	std	Z+3, r27	; 0x03
	gyro->q = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());
    1678:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    167c:	88 2f       	mov	r24, r24
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	18 2f       	mov	r17, r24
    1682:	00 27       	eor	r16, r16
    1684:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    1688:	88 2f       	mov	r24, r24
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	80 2b       	or	r24, r16
    168e:	91 2b       	or	r25, r17
    1690:	cc 01       	movw	r24, r24
    1692:	a0 e0       	ldi	r26, 0x00	; 0
    1694:	b0 e0       	ldi	r27, 0x00	; 0
    1696:	bc 01       	movw	r22, r24
    1698:	cd 01       	movw	r24, r26
    169a:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    169e:	dc 01       	movw	r26, r24
    16a0:	cb 01       	movw	r24, r22
    16a2:	ef 81       	ldd	r30, Y+7	; 0x07
    16a4:	f8 85       	ldd	r31, Y+8	; 0x08
    16a6:	84 83       	std	Z+4, r24	; 0x04
    16a8:	95 83       	std	Z+5, r25	; 0x05
    16aa:	a6 83       	std	Z+6, r26	; 0x06
    16ac:	b7 83       	std	Z+7, r27	; 0x07
	gyro->r = ((u16)I2C_Read()<<8) | ((u16)I2C_Read());
    16ae:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    16b2:	88 2f       	mov	r24, r24
    16b4:	90 e0       	ldi	r25, 0x00	; 0
    16b6:	18 2f       	mov	r17, r24
    16b8:	00 27       	eor	r16, r16
    16ba:	0e 94 86 18 	call	0x310c	; 0x310c <I2C_Read>
    16be:	88 2f       	mov	r24, r24
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	80 2b       	or	r24, r16
    16c4:	91 2b       	or	r25, r17
    16c6:	cc 01       	movw	r24, r24
    16c8:	a0 e0       	ldi	r26, 0x00	; 0
    16ca:	b0 e0       	ldi	r27, 0x00	; 0
    16cc:	bc 01       	movw	r22, r24
    16ce:	cd 01       	movw	r24, r26
    16d0:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <__floatunsisf>
    16d4:	dc 01       	movw	r26, r24
    16d6:	cb 01       	movw	r24, r22
    16d8:	ef 81       	ldd	r30, Y+7	; 0x07
    16da:	f8 85       	ldd	r31, Y+8	; 0x08
    16dc:	80 87       	std	Z+8, r24	; 0x08
    16de:	91 87       	std	Z+9, r25	; 0x09
    16e0:	a2 87       	std	Z+10, r26	; 0x0a
    16e2:	b3 87       	std	Z+11, r27	; 0x0b
	I2C_Stop();
    16e4:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <I2C_Stop>
	acc->x /= 2048;								///////////////////////////////////////////
    16e8:	ed 81       	ldd	r30, Y+5	; 0x05
    16ea:	fe 81       	ldd	r31, Y+6	; 0x06
    16ec:	80 81       	ld	r24, Z
    16ee:	91 81       	ldd	r25, Z+1	; 0x01
    16f0:	a2 81       	ldd	r26, Z+2	; 0x02
    16f2:	b3 81       	ldd	r27, Z+3	; 0x03
    16f4:	bc 01       	movw	r22, r24
    16f6:	cd 01       	movw	r24, r26
    16f8:	20 e0       	ldi	r18, 0x00	; 0
    16fa:	30 e0       	ldi	r19, 0x00	; 0
    16fc:	40 e0       	ldi	r20, 0x00	; 0
    16fe:	55 e4       	ldi	r21, 0x45	; 69
    1700:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    1704:	dc 01       	movw	r26, r24
    1706:	cb 01       	movw	r24, r22
    1708:	ed 81       	ldd	r30, Y+5	; 0x05
    170a:	fe 81       	ldd	r31, Y+6	; 0x06
    170c:	80 83       	st	Z, r24
    170e:	91 83       	std	Z+1, r25	; 0x01
    1710:	a2 83       	std	Z+2, r26	; 0x02
    1712:	b3 83       	std	Z+3, r27	; 0x03
	acc->y /= 2048;								//normalizing the raw values to real values
    1714:	ed 81       	ldd	r30, Y+5	; 0x05
    1716:	fe 81       	ldd	r31, Y+6	; 0x06
    1718:	84 81       	ldd	r24, Z+4	; 0x04
    171a:	95 81       	ldd	r25, Z+5	; 0x05
    171c:	a6 81       	ldd	r26, Z+6	; 0x06
    171e:	b7 81       	ldd	r27, Z+7	; 0x07
    1720:	bc 01       	movw	r22, r24
    1722:	cd 01       	movw	r24, r26
    1724:	20 e0       	ldi	r18, 0x00	; 0
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	40 e0       	ldi	r20, 0x00	; 0
    172a:	55 e4       	ldi	r21, 0x45	; 69
    172c:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    1730:	dc 01       	movw	r26, r24
    1732:	cb 01       	movw	r24, r22
    1734:	ed 81       	ldd	r30, Y+5	; 0x05
    1736:	fe 81       	ldd	r31, Y+6	; 0x06
    1738:	84 83       	std	Z+4, r24	; 0x04
    173a:	95 83       	std	Z+5, r25	; 0x05
    173c:	a6 83       	std	Z+6, r26	; 0x06
    173e:	b7 83       	std	Z+7, r27	; 0x07
	acc->z /= 2048;								///////////////////////////////////////////
    1740:	ed 81       	ldd	r30, Y+5	; 0x05
    1742:	fe 81       	ldd	r31, Y+6	; 0x06
    1744:	80 85       	ldd	r24, Z+8	; 0x08
    1746:	91 85       	ldd	r25, Z+9	; 0x09
    1748:	a2 85       	ldd	r26, Z+10	; 0x0a
    174a:	b3 85       	ldd	r27, Z+11	; 0x0b
    174c:	bc 01       	movw	r22, r24
    174e:	cd 01       	movw	r24, r26
    1750:	20 e0       	ldi	r18, 0x00	; 0
    1752:	30 e0       	ldi	r19, 0x00	; 0
    1754:	40 e0       	ldi	r20, 0x00	; 0
    1756:	55 e4       	ldi	r21, 0x45	; 69
    1758:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    175c:	dc 01       	movw	r26, r24
    175e:	cb 01       	movw	r24, r22
    1760:	ed 81       	ldd	r30, Y+5	; 0x05
    1762:	fe 81       	ldd	r31, Y+6	; 0x06
    1764:	80 87       	std	Z+8, r24	; 0x08
    1766:	91 87       	std	Z+9, r25	; 0x09
    1768:	a2 87       	std	Z+10, r26	; 0x0a
    176a:	b3 87       	std	Z+11, r27	; 0x0b
	gyro->p /= 16.4;
    176c:	ef 81       	ldd	r30, Y+7	; 0x07
    176e:	f8 85       	ldd	r31, Y+8	; 0x08
    1770:	80 81       	ld	r24, Z
    1772:	91 81       	ldd	r25, Z+1	; 0x01
    1774:	a2 81       	ldd	r26, Z+2	; 0x02
    1776:	b3 81       	ldd	r27, Z+3	; 0x03
    1778:	bc 01       	movw	r22, r24
    177a:	cd 01       	movw	r24, r26
    177c:	23 e3       	ldi	r18, 0x33	; 51
    177e:	33 e3       	ldi	r19, 0x33	; 51
    1780:	43 e8       	ldi	r20, 0x83	; 131
    1782:	51 e4       	ldi	r21, 0x41	; 65
    1784:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    1788:	dc 01       	movw	r26, r24
    178a:	cb 01       	movw	r24, r22
    178c:	ef 81       	ldd	r30, Y+7	; 0x07
    178e:	f8 85       	ldd	r31, Y+8	; 0x08
    1790:	80 83       	st	Z, r24
    1792:	91 83       	std	Z+1, r25	; 0x01
    1794:	a2 83       	std	Z+2, r26	; 0x02
    1796:	b3 83       	std	Z+3, r27	; 0x03
	gyro->q /= 16.4;
    1798:	ef 81       	ldd	r30, Y+7	; 0x07
    179a:	f8 85       	ldd	r31, Y+8	; 0x08
    179c:	84 81       	ldd	r24, Z+4	; 0x04
    179e:	95 81       	ldd	r25, Z+5	; 0x05
    17a0:	a6 81       	ldd	r26, Z+6	; 0x06
    17a2:	b7 81       	ldd	r27, Z+7	; 0x07
    17a4:	bc 01       	movw	r22, r24
    17a6:	cd 01       	movw	r24, r26
    17a8:	23 e3       	ldi	r18, 0x33	; 51
    17aa:	33 e3       	ldi	r19, 0x33	; 51
    17ac:	43 e8       	ldi	r20, 0x83	; 131
    17ae:	51 e4       	ldi	r21, 0x41	; 65
    17b0:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    17b4:	dc 01       	movw	r26, r24
    17b6:	cb 01       	movw	r24, r22
    17b8:	ef 81       	ldd	r30, Y+7	; 0x07
    17ba:	f8 85       	ldd	r31, Y+8	; 0x08
    17bc:	84 83       	std	Z+4, r24	; 0x04
    17be:	95 83       	std	Z+5, r25	; 0x05
    17c0:	a6 83       	std	Z+6, r26	; 0x06
    17c2:	b7 83       	std	Z+7, r27	; 0x07
	gyro->r /= 16.4;
    17c4:	ef 81       	ldd	r30, Y+7	; 0x07
    17c6:	f8 85       	ldd	r31, Y+8	; 0x08
    17c8:	80 85       	ldd	r24, Z+8	; 0x08
    17ca:	91 85       	ldd	r25, Z+9	; 0x09
    17cc:	a2 85       	ldd	r26, Z+10	; 0x0a
    17ce:	b3 85       	ldd	r27, Z+11	; 0x0b
    17d0:	bc 01       	movw	r22, r24
    17d2:	cd 01       	movw	r24, r26
    17d4:	23 e3       	ldi	r18, 0x33	; 51
    17d6:	33 e3       	ldi	r19, 0x33	; 51
    17d8:	43 e8       	ldi	r20, 0x83	; 131
    17da:	51 e4       	ldi	r21, 0x41	; 65
    17dc:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    17e0:	dc 01       	movw	r26, r24
    17e2:	cb 01       	movw	r24, r22
    17e4:	ef 81       	ldd	r30, Y+7	; 0x07
    17e6:	f8 85       	ldd	r31, Y+8	; 0x08
    17e8:	80 87       	std	Z+8, r24	; 0x08
    17ea:	91 87       	std	Z+9, r25	; 0x09
    17ec:	a2 87       	std	Z+10, r26	; 0x0a
    17ee:	b3 87       	std	Z+11, r27	; 0x0b
}
    17f0:	28 96       	adiw	r28, 0x08	; 8
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	de bf       	out	0x3e, r29	; 62
    17f8:	0f be       	out	0x3f, r0	; 63
    17fa:	cd bf       	out	0x3d, r28	; 61
    17fc:	cf 91       	pop	r28
    17fe:	df 91       	pop	r29
    1800:	1f 91       	pop	r17
    1802:	0f 91       	pop	r16
    1804:	08 95       	ret

00001806 <ARM_Motors>:

#include "PWM.h"
#include <avr/io.h>

void ARM_Motors(void)
{
    1806:	df 93       	push	r29
    1808:	cf 93       	push	r28
    180a:	00 d0       	rcall	.+0      	; 0x180c <ARM_Motors+0x6>
    180c:	cd b7       	in	r28, 0x3d	; 61
    180e:	de b7       	in	r29, 0x3e	; 62
	TCCR1A |= (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11) ;	//Clear output upon match. TOV on ICR TOP
    1810:	af e4       	ldi	r26, 0x4F	; 79
    1812:	b0 e0       	ldi	r27, 0x00	; 0
    1814:	ef e4       	ldi	r30, 0x4F	; 79
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	80 81       	ld	r24, Z
    181a:	82 6a       	ori	r24, 0xA2	; 162
    181c:	8c 93       	st	X, r24


	TCCR3A |= (1 << COM3A1) | (1 << COM3B1) | (1 << WGM31) | (1 << WGM30);	//Same as timer 1.
    181e:	ab e8       	ldi	r26, 0x8B	; 139
    1820:	b0 e0       	ldi	r27, 0x00	; 0
    1822:	eb e8       	ldi	r30, 0x8B	; 139
    1824:	f0 e0       	ldi	r31, 0x00	; 0
    1826:	80 81       	ld	r24, Z
    1828:	83 6a       	ori	r24, 0xA3	; 163
    182a:	8c 93       	st	X, r24

	TCNT1H = 0x8E;
    182c:	ed e4       	ldi	r30, 0x4D	; 77
    182e:	f0 e0       	ldi	r31, 0x00	; 0
    1830:	8e e8       	ldi	r24, 0x8E	; 142
    1832:	80 83       	st	Z, r24
	TCNT1L = 0x0B;											//Set default value as explained in description.
    1834:	ec e4       	ldi	r30, 0x4C	; 76
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	8b e0       	ldi	r24, 0x0B	; 11
    183a:	80 83       	st	Z, r24


	TCNT3L = 0x8E;											//Set default value as explained in description.
    183c:	e8 e8       	ldi	r30, 0x88	; 136
    183e:	f0 e0       	ldi	r31, 0x00	; 0
    1840:	8e e8       	ldi	r24, 0x8E	; 142
    1842:	80 83       	st	Z, r24
	TCNT3H = 0x0B;
    1844:	e9 e8       	ldi	r30, 0x89	; 137
    1846:	f0 e0       	ldi	r31, 0x00	; 0
    1848:	8b e0       	ldi	r24, 0x0B	; 11
    184a:	80 83       	st	Z, r24

	u16 start = 0.2*0.055*36363 + 0.055*36363 + (65535 - 36363);		//(20% ARMING) CHANGE THIS IN CASE OF NOT GOOD ARMING
    184c:	83 e5       	ldi	r24, 0x53	; 83
    184e:	9b e7       	ldi	r25, 0x7B	; 123
    1850:	9a 83       	std	Y+2, r25	; 0x02
    1852:	89 83       	std	Y+1, r24	; 0x01
	 *	The ESC ranges from zero throttle to 100% throttle corresponding to 1 ms (no throttle) to:
	 *	2 ms (full throttle), therefore, to arm the motors at 20% we need a pulse width of 1.2 ms,
	 *	which corresponds to 740 + 15 + 3 = 758.
	 */

	OCR1AH = (start >> 8);
    1854:	eb e4       	ldi	r30, 0x4B	; 75
    1856:	f0 e0       	ldi	r31, 0x00	; 0
    1858:	89 81       	ldd	r24, Y+1	; 0x01
    185a:	9a 81       	ldd	r25, Y+2	; 0x02
    185c:	89 2f       	mov	r24, r25
    185e:	99 27       	eor	r25, r25
    1860:	80 83       	st	Z, r24
	OCR1AL = start & 0xff;
    1862:	ea e4       	ldi	r30, 0x4A	; 74
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	89 81       	ldd	r24, Y+1	; 0x01
    1868:	80 83       	st	Z, r24

	OCR1BH = (start >> 8);
    186a:	e9 e4       	ldi	r30, 0x49	; 73
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	89 81       	ldd	r24, Y+1	; 0x01
    1870:	9a 81       	ldd	r25, Y+2	; 0x02
    1872:	89 2f       	mov	r24, r25
    1874:	99 27       	eor	r25, r25
    1876:	80 83       	st	Z, r24
	OCR1BL = start & 0xff;
    1878:	e8 e4       	ldi	r30, 0x48	; 72
    187a:	f0 e0       	ldi	r31, 0x00	; 0
    187c:	89 81       	ldd	r24, Y+1	; 0x01
    187e:	80 83       	st	Z, r24

	OCR3AH = (start >> 8);
    1880:	e7 e8       	ldi	r30, 0x87	; 135
    1882:	f0 e0       	ldi	r31, 0x00	; 0
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	9a 81       	ldd	r25, Y+2	; 0x02
    1888:	89 2f       	mov	r24, r25
    188a:	99 27       	eor	r25, r25
    188c:	80 83       	st	Z, r24
	OCR3AL = start & 0xff;
    188e:	e6 e8       	ldi	r30, 0x86	; 134
    1890:	f0 e0       	ldi	r31, 0x00	; 0
    1892:	89 81       	ldd	r24, Y+1	; 0x01
    1894:	80 83       	st	Z, r24

	OCR3BH = (start >> 8);
    1896:	e5 e8       	ldi	r30, 0x85	; 133
    1898:	f0 e0       	ldi	r31, 0x00	; 0
    189a:	89 81       	ldd	r24, Y+1	; 0x01
    189c:	9a 81       	ldd	r25, Y+2	; 0x02
    189e:	89 2f       	mov	r24, r25
    18a0:	99 27       	eor	r25, r25
    18a2:	80 83       	st	Z, r24
	OCR3BL = start & 0xff;
    18a4:	e4 e8       	ldi	r30, 0x84	; 132
    18a6:	f0 e0       	ldi	r31, 0x00	; 0
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	80 83       	st	Z, r24

	ICR1H = 0xff;
    18ac:	e7 e4       	ldi	r30, 0x47	; 71
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	8f ef       	ldi	r24, 0xFF	; 255
    18b2:	80 83       	st	Z, r24
	ICR1L = 0xff;
    18b4:	e6 e4       	ldi	r30, 0x46	; 70
    18b6:	f0 e0       	ldi	r31, 0x00	; 0
    18b8:	8f ef       	ldi	r24, 0xFF	; 255
    18ba:	80 83       	st	Z, r24

	TIMSK |= (1 << TOIE1);// | (1 << OCIE1A) | (1 << OCIE1B);
    18bc:	a7 e5       	ldi	r26, 0x57	; 87
    18be:	b0 e0       	ldi	r27, 0x00	; 0
    18c0:	e7 e5       	ldi	r30, 0x57	; 87
    18c2:	f0 e0       	ldi	r31, 0x00	; 0
    18c4:	80 81       	ld	r24, Z
    18c6:	84 60       	ori	r24, 0x04	; 4
    18c8:	8c 93       	st	X, r24
	ETIMSK |= (1 << TOIE3);// | (1 << OCIE3A) | (1 << OCIE3B);
    18ca:	ad e7       	ldi	r26, 0x7D	; 125
    18cc:	b0 e0       	ldi	r27, 0x00	; 0
    18ce:	ed e7       	ldi	r30, 0x7D	; 125
    18d0:	f0 e0       	ldi	r31, 0x00	; 0
    18d2:	80 81       	ld	r24, Z
    18d4:	84 60       	ori	r24, 0x04	; 4
    18d6:	8c 93       	st	X, r24

	TCCR1B |= (1 << WGM12) | (1 << WGM13) | (1 << CS10) | (1 << CS12);		//Prescaler = 1024 and i deleted the shit out of wgm13
    18d8:	ae e4       	ldi	r26, 0x4E	; 78
    18da:	b0 e0       	ldi	r27, 0x00	; 0
    18dc:	ee e4       	ldi	r30, 0x4E	; 78
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	80 81       	ld	r24, Z
    18e2:	8d 61       	ori	r24, 0x1D	; 29
    18e4:	8c 93       	st	X, r24
	TCCR3B |= (1 << CS31) | (1 << WGM32) | (1 << WGM33);					//Same as timer 1.
    18e6:	aa e8       	ldi	r26, 0x8A	; 138
    18e8:	b0 e0       	ldi	r27, 0x00	; 0
    18ea:	ea e8       	ldi	r30, 0x8A	; 138
    18ec:	f0 e0       	ldi	r31, 0x00	; 0
    18ee:	80 81       	ld	r24, Z
    18f0:	8a 61       	ori	r24, 0x1A	; 26
    18f2:	8c 93       	st	X, r24
}
    18f4:	0f 90       	pop	r0
    18f6:	0f 90       	pop	r0
    18f8:	cf 91       	pop	r28
    18fa:	df 91       	pop	r29
    18fc:	08 95       	ret

000018fe <ISR>:
ISR(TIMER1_OVF_vect)
	{
    18fe:	df 93       	push	r29
    1900:	cf 93       	push	r28
    1902:	00 d0       	rcall	.+0      	; 0x1904 <ISR+0x6>
    1904:	00 d0       	rcall	.+0      	; 0x1906 <ISR+0x8>
    1906:	cd b7       	in	r28, 0x3d	; 61
    1908:	de b7       	in	r29, 0x3e	; 62
    190a:	9a 83       	std	Y+2, r25	; 0x02
    190c:	89 83       	std	Y+1, r24	; 0x01
		TCNT1H = 0x8E;
    190e:	ed e4       	ldi	r30, 0x4D	; 77
    1910:	f0 e0       	ldi	r31, 0x00	; 0
    1912:	8e e8       	ldi	r24, 0x8E	; 142
    1914:	80 83       	st	Z, r24
		TCNT1L = 0x0B;
    1916:	ec e4       	ldi	r30, 0x4C	; 76
    1918:	f0 e0       	ldi	r31, 0x00	; 0
    191a:	8b e0       	ldi	r24, 0x0B	; 11
    191c:	80 83       	st	Z, r24
	}
    191e:	0f 90       	pop	r0
    1920:	0f 90       	pop	r0
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
    1926:	cf 91       	pop	r28
    1928:	df 91       	pop	r29
    192a:	08 95       	ret

0000192c <PWM>:
	 * 												3    4
	 *
	 */

void PWM(u8 dutyCycle, u8 motorNumber)					//dutyCycle is a percentage of how much force is needed of max
{
    192c:	df 93       	push	r29
    192e:	cf 93       	push	r28
    1930:	00 d0       	rcall	.+0      	; 0x1932 <PWM+0x6>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <PWM+0x8>
    1934:	00 d0       	rcall	.+0      	; 0x1936 <PWM+0xa>
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
    193a:	8b 83       	std	Y+3, r24	; 0x03
    193c:	6c 83       	std	Y+4, r22	; 0x04
	u16 temp = 36363 + (dutyCycle/100) * 2000 + 2000;			//First get the value needed then split to LOW and HIGH
    193e:	8b 81       	ldd	r24, Y+3	; 0x03
    1940:	94 e6       	ldi	r25, 0x64	; 100
    1942:	69 2f       	mov	r22, r25
    1944:	0e 94 65 2e 	call	0x5cca	; 0x5cca <__udivmodqi4>
    1948:	28 2f       	mov	r18, r24
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	80 ed       	ldi	r24, 0xD0	; 208
    194e:	97 e0       	ldi	r25, 0x07	; 7
    1950:	ac 01       	movw	r20, r24
    1952:	24 9f       	mul	r18, r20
    1954:	c0 01       	movw	r24, r0
    1956:	25 9f       	mul	r18, r21
    1958:	90 0d       	add	r25, r0
    195a:	34 9f       	mul	r19, r20
    195c:	90 0d       	add	r25, r0
    195e:	11 24       	eor	r1, r1
    1960:	85 52       	subi	r24, 0x25	; 37
    1962:	9a 46       	sbci	r25, 0x6A	; 106
    1964:	9a 83       	std	Y+2, r25	; 0x02
    1966:	89 83       	std	Y+1, r24	; 0x01
	//u16 temp =  (dutyCycle/100.0) * (65535);

	switch(motorNumber)
    1968:	8c 81       	ldd	r24, Y+4	; 0x04
    196a:	28 2f       	mov	r18, r24
    196c:	30 e0       	ldi	r19, 0x00	; 0
    196e:	3e 83       	std	Y+6, r19	; 0x06
    1970:	2d 83       	std	Y+5, r18	; 0x05
    1972:	4d 81       	ldd	r20, Y+5	; 0x05
    1974:	5e 81       	ldd	r21, Y+6	; 0x06
    1976:	42 30       	cpi	r20, 0x02	; 2
    1978:	51 05       	cpc	r21, r1
    197a:	11 f1       	breq	.+68     	; 0x19c0 <PWM+0x94>
    197c:	8d 81       	ldd	r24, Y+5	; 0x05
    197e:	9e 81       	ldd	r25, Y+6	; 0x06
    1980:	83 30       	cpi	r24, 0x03	; 3
    1982:	91 05       	cpc	r25, r1
    1984:	34 f4       	brge	.+12     	; 0x1992 <PWM+0x66>
    1986:	2d 81       	ldd	r18, Y+5	; 0x05
    1988:	3e 81       	ldd	r19, Y+6	; 0x06
    198a:	21 30       	cpi	r18, 0x01	; 1
    198c:	31 05       	cpc	r19, r1
    198e:	61 f0       	breq	.+24     	; 0x19a8 <PWM+0x7c>
    1990:	3b c0       	rjmp	.+118    	; 0x1a08 <PWM+0xdc>
    1992:	4d 81       	ldd	r20, Y+5	; 0x05
    1994:	5e 81       	ldd	r21, Y+6	; 0x06
    1996:	43 30       	cpi	r20, 0x03	; 3
    1998:	51 05       	cpc	r21, r1
    199a:	f1 f0       	breq	.+60     	; 0x19d8 <PWM+0xac>
    199c:	8d 81       	ldd	r24, Y+5	; 0x05
    199e:	9e 81       	ldd	r25, Y+6	; 0x06
    19a0:	84 30       	cpi	r24, 0x04	; 4
    19a2:	91 05       	cpc	r25, r1
    19a4:	29 f1       	breq	.+74     	; 0x19f0 <PWM+0xc4>
    19a6:	30 c0       	rjmp	.+96     	; 0x1a08 <PWM+0xdc>
	{
	case 1:

		OCR1AH = (temp >> 8);
    19a8:	eb e4       	ldi	r30, 0x4B	; 75
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	89 81       	ldd	r24, Y+1	; 0x01
    19ae:	9a 81       	ldd	r25, Y+2	; 0x02
    19b0:	89 2f       	mov	r24, r25
    19b2:	99 27       	eor	r25, r25
    19b4:	80 83       	st	Z, r24
		OCR1AL = temp & 0xff;
    19b6:	ea e4       	ldi	r30, 0x4A	; 74
    19b8:	f0 e0       	ldi	r31, 0x00	; 0
    19ba:	89 81       	ldd	r24, Y+1	; 0x01
    19bc:	80 83       	st	Z, r24
    19be:	65 c0       	rjmp	.+202    	; 0x1a8a <PWM+0x15e>
		break;
	case 2:

		OCR1BH = (temp >> 8);
    19c0:	e9 e4       	ldi	r30, 0x49	; 73
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	9a 81       	ldd	r25, Y+2	; 0x02
    19c8:	89 2f       	mov	r24, r25
    19ca:	99 27       	eor	r25, r25
    19cc:	80 83       	st	Z, r24
		OCR1BL = temp & 0xff;
    19ce:	e8 e4       	ldi	r30, 0x48	; 72
    19d0:	f0 e0       	ldi	r31, 0x00	; 0
    19d2:	89 81       	ldd	r24, Y+1	; 0x01
    19d4:	80 83       	st	Z, r24
    19d6:	59 c0       	rjmp	.+178    	; 0x1a8a <PWM+0x15e>
		break;
	case 3:
		OCR3AH = (temp >> 8);
    19d8:	e7 e8       	ldi	r30, 0x87	; 135
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	89 81       	ldd	r24, Y+1	; 0x01
    19de:	9a 81       	ldd	r25, Y+2	; 0x02
    19e0:	89 2f       	mov	r24, r25
    19e2:	99 27       	eor	r25, r25
    19e4:	80 83       	st	Z, r24
		OCR3AL = temp & 0xff;
    19e6:	e6 e8       	ldi	r30, 0x86	; 134
    19e8:	f0 e0       	ldi	r31, 0x00	; 0
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	80 83       	st	Z, r24
    19ee:	4d c0       	rjmp	.+154    	; 0x1a8a <PWM+0x15e>
		break;
	case 4:

		OCR3BH = (temp >> 8);
    19f0:	e5 e8       	ldi	r30, 0x85	; 133
    19f2:	f0 e0       	ldi	r31, 0x00	; 0
    19f4:	89 81       	ldd	r24, Y+1	; 0x01
    19f6:	9a 81       	ldd	r25, Y+2	; 0x02
    19f8:	89 2f       	mov	r24, r25
    19fa:	99 27       	eor	r25, r25
    19fc:	80 83       	st	Z, r24
		OCR3BL = temp & 0xff;
    19fe:	e4 e8       	ldi	r30, 0x84	; 132
    1a00:	f0 e0       	ldi	r31, 0x00	; 0
    1a02:	89 81       	ldd	r24, Y+1	; 0x01
    1a04:	80 83       	st	Z, r24
    1a06:	41 c0       	rjmp	.+130    	; 0x1a8a <PWM+0x15e>
		break;
	default:
		temp = 36363 + (dutyCycle/100) * 2000 + 2000;
    1a08:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0a:	94 e6       	ldi	r25, 0x64	; 100
    1a0c:	69 2f       	mov	r22, r25
    1a0e:	0e 94 65 2e 	call	0x5cca	; 0x5cca <__udivmodqi4>
    1a12:	28 2f       	mov	r18, r24
    1a14:	30 e0       	ldi	r19, 0x00	; 0
    1a16:	80 ed       	ldi	r24, 0xD0	; 208
    1a18:	97 e0       	ldi	r25, 0x07	; 7
    1a1a:	ac 01       	movw	r20, r24
    1a1c:	24 9f       	mul	r18, r20
    1a1e:	c0 01       	movw	r24, r0
    1a20:	25 9f       	mul	r18, r21
    1a22:	90 0d       	add	r25, r0
    1a24:	34 9f       	mul	r19, r20
    1a26:	90 0d       	add	r25, r0
    1a28:	11 24       	eor	r1, r1
    1a2a:	85 52       	subi	r24, 0x25	; 37
    1a2c:	9a 46       	sbci	r25, 0x6A	; 106
    1a2e:	9a 83       	std	Y+2, r25	; 0x02
    1a30:	89 83       	std	Y+1, r24	; 0x01
		OCR1AH = (temp >> 8);
    1a32:	eb e4       	ldi	r30, 0x4B	; 75
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	89 81       	ldd	r24, Y+1	; 0x01
    1a38:	9a 81       	ldd	r25, Y+2	; 0x02
    1a3a:	89 2f       	mov	r24, r25
    1a3c:	99 27       	eor	r25, r25
    1a3e:	80 83       	st	Z, r24
		OCR1AL = temp & 0xff;
    1a40:	ea e4       	ldi	r30, 0x4A	; 74
    1a42:	f0 e0       	ldi	r31, 0x00	; 0
    1a44:	89 81       	ldd	r24, Y+1	; 0x01
    1a46:	80 83       	st	Z, r24

		OCR1BH = (temp >> 8);
    1a48:	e9 e4       	ldi	r30, 0x49	; 73
    1a4a:	f0 e0       	ldi	r31, 0x00	; 0
    1a4c:	89 81       	ldd	r24, Y+1	; 0x01
    1a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1a50:	89 2f       	mov	r24, r25
    1a52:	99 27       	eor	r25, r25
    1a54:	80 83       	st	Z, r24
		OCR1BL = temp & 0xff;
    1a56:	e8 e4       	ldi	r30, 0x48	; 72
    1a58:	f0 e0       	ldi	r31, 0x00	; 0
    1a5a:	89 81       	ldd	r24, Y+1	; 0x01
    1a5c:	80 83       	st	Z, r24

		OCR3AH = (temp >> 8);
    1a5e:	e7 e8       	ldi	r30, 0x87	; 135
    1a60:	f0 e0       	ldi	r31, 0x00	; 0
    1a62:	89 81       	ldd	r24, Y+1	; 0x01
    1a64:	9a 81       	ldd	r25, Y+2	; 0x02
    1a66:	89 2f       	mov	r24, r25
    1a68:	99 27       	eor	r25, r25
    1a6a:	80 83       	st	Z, r24
		OCR3AL = temp & 0xff;
    1a6c:	e6 e8       	ldi	r30, 0x86	; 134
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	89 81       	ldd	r24, Y+1	; 0x01
    1a72:	80 83       	st	Z, r24

		OCR3BH = (temp >> 8);
    1a74:	e5 e8       	ldi	r30, 0x85	; 133
    1a76:	f0 e0       	ldi	r31, 0x00	; 0
    1a78:	89 81       	ldd	r24, Y+1	; 0x01
    1a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1a7c:	89 2f       	mov	r24, r25
    1a7e:	99 27       	eor	r25, r25
    1a80:	80 83       	st	Z, r24
		OCR3BL = temp & 0xff;
    1a82:	e4 e8       	ldi	r30, 0x84	; 132
    1a84:	f0 e0       	ldi	r31, 0x00	; 0
    1a86:	89 81       	ldd	r24, Y+1	; 0x01
    1a88:	80 83       	st	Z, r24

	}



}
    1a8a:	26 96       	adiw	r28, 0x06	; 6
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	de bf       	out	0x3e, r29	; 62
    1a92:	0f be       	out	0x3f, r0	; 63
    1a94:	cd bf       	out	0x3d, r28	; 61
    1a96:	cf 91       	pop	r28
    1a98:	df 91       	pop	r29
    1a9a:	08 95       	ret

00001a9c <DISARM_Motors>:

/* Disabling all timers*/
void DISARM_Motors(void)
{
    1a9c:	df 93       	push	r29
    1a9e:	cf 93       	push	r28
    1aa0:	cd b7       	in	r28, 0x3d	; 61
    1aa2:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = 0;
    1aa4:	ef e4       	ldi	r30, 0x4F	; 79
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	10 82       	st	Z, r1
	TCCR1B = 0;
    1aaa:	ee e4       	ldi	r30, 0x4E	; 78
    1aac:	f0 e0       	ldi	r31, 0x00	; 0
    1aae:	10 82       	st	Z, r1
	TCCR3A = 0;
    1ab0:	eb e8       	ldi	r30, 0x8B	; 139
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	10 82       	st	Z, r1
	TCCR3B = 0;
    1ab6:	ea e8       	ldi	r30, 0x8A	; 138
    1ab8:	f0 e0       	ldi	r31, 0x00	; 0
    1aba:	10 82       	st	Z, r1
	TCNT1 = 0;
    1abc:	ec e4       	ldi	r30, 0x4C	; 76
    1abe:	f0 e0       	ldi	r31, 0x00	; 0
    1ac0:	11 82       	std	Z+1, r1	; 0x01
    1ac2:	10 82       	st	Z, r1
	TCNT3 = 0;
    1ac4:	e8 e8       	ldi	r30, 0x88	; 136
    1ac6:	f0 e0       	ldi	r31, 0x00	; 0
    1ac8:	11 82       	std	Z+1, r1	; 0x01
    1aca:	10 82       	st	Z, r1
	OCR1A = 0;
    1acc:	ea e4       	ldi	r30, 0x4A	; 74
    1ace:	f0 e0       	ldi	r31, 0x00	; 0
    1ad0:	11 82       	std	Z+1, r1	; 0x01
    1ad2:	10 82       	st	Z, r1
	OCR1B = 0;
    1ad4:	e8 e4       	ldi	r30, 0x48	; 72
    1ad6:	f0 e0       	ldi	r31, 0x00	; 0
    1ad8:	11 82       	std	Z+1, r1	; 0x01
    1ada:	10 82       	st	Z, r1
	OCR3A = 0;
    1adc:	e6 e8       	ldi	r30, 0x86	; 134
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	11 82       	std	Z+1, r1	; 0x01
    1ae2:	10 82       	st	Z, r1
	OCR3B = 0;
    1ae4:	e4 e8       	ldi	r30, 0x84	; 132
    1ae6:	f0 e0       	ldi	r31, 0x00	; 0
    1ae8:	11 82       	std	Z+1, r1	; 0x01
    1aea:	10 82       	st	Z, r1
	TIMSK = 0;
    1aec:	e7 e5       	ldi	r30, 0x57	; 87
    1aee:	f0 e0       	ldi	r31, 0x00	; 0
    1af0:	10 82       	st	Z, r1
	ETIMSK = 0;
    1af2:	ed e7       	ldi	r30, 0x7D	; 125
    1af4:	f0 e0       	ldi	r31, 0x00	; 0
    1af6:	10 82       	st	Z, r1
}
    1af8:	cf 91       	pop	r28
    1afa:	df 91       	pop	r29
    1afc:	08 95       	ret

00001afe <UART0_init>:
 * UART_receiveByte()  receive byte
 * baud rate = 9600 symbol/second
 * UART_sendString(" ... #") NOTE : you must send '#' at the end of the string
 * UART_receiveString()
 *
 */
    1afe:	df 93       	push	r29
    1b00:	cf 93       	push	r28
    1b02:	cd b7       	in	r28, 0x3d	; 61
    1b04:	de b7       	in	r29, 0x3e	; 62
void UART0_init()
{
	//UCSR0A=(1<<U2X);											// double speed mode
    1b06:	e1 ec       	ldi	r30, 0xC1	; 193
    1b08:	f0 e0       	ldi	r31, 0x00	; 0
    1b0a:	88 e1       	ldi	r24, 0x18	; 24
    1b0c:	80 83       	st	Z, r24

    1b0e:	e2 ec       	ldi	r30, 0xC2	; 194
    1b10:	f0 e0       	ldi	r31, 0x00	; 0
    1b12:	86 e8       	ldi	r24, 0x86	; 134
    1b14:	80 83       	st	Z, r24
	UCSR0B	=	0b00011000;									//sender and receiver
	UCSR0C	= 	0b10000110;							//no parity check and send 8 bits
    1b16:	e4 ec       	ldi	r30, 0xC4	; 196
    1b18:	f0 e0       	ldi	r31, 0x00	; 0
    1b1a:	87 e6       	ldi	r24, 0x67	; 103
    1b1c:	80 83       	st	Z, r24

	UBRR0L=103;
    1b1e:	cf 91       	pop	r28
    1b20:	df 91       	pop	r29
    1b22:	08 95       	ret

00001b24 <UART1_init>:

}

    1b24:	df 93       	push	r29
    1b26:	cf 93       	push	r28
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
void UART1_init()
{
    1b2c:	e9 ec       	ldi	r30, 0xC9	; 201
    1b2e:	f0 e0       	ldi	r31, 0x00	; 0
    1b30:	88 e1       	ldi	r24, 0x18	; 24
    1b32:	80 83       	st	Z, r24
	//UCSR1A=(1<<U2X);											// double speed mode
    1b34:	ea ec       	ldi	r30, 0xCA	; 202
    1b36:	f0 e0       	ldi	r31, 0x00	; 0
    1b38:	86 e8       	ldi	r24, 0x86	; 134
    1b3a:	80 83       	st	Z, r24
	UCSR1B	=	0b00011000;										//sender and receiver
	UCSR1C	= 	0b10000110;							//no parity check and send 8 bits
    1b3c:	ec ec       	ldi	r30, 0xCC	; 204
    1b3e:	f0 e0       	ldi	r31, 0x00	; 0
    1b40:	87 e6       	ldi	r24, 0x67	; 103
    1b42:	80 83       	st	Z, r24
	//UBRR1H=BAUD_PRESCALE<<8; 								//baud rate 9600
	UBRR1L	=	103;
    1b44:	cf 91       	pop	r28
    1b46:	df 91       	pop	r29
    1b48:	08 95       	ret

00001b4a <UART2_init>:

}


    1b4a:	df 93       	push	r29
    1b4c:	cf 93       	push	r28
    1b4e:	cd b7       	in	r28, 0x3d	; 61
    1b50:	de b7       	in	r29, 0x3e	; 62


    1b52:	e1 ed       	ldi	r30, 0xD1	; 209
    1b54:	f0 e0       	ldi	r31, 0x00	; 0
    1b56:	88 e1       	ldi	r24, 0x18	; 24
    1b58:	80 83       	st	Z, r24

    1b5a:	e2 ed       	ldi	r30, 0xD2	; 210
    1b5c:	f0 e0       	ldi	r31, 0x00	; 0
    1b5e:	86 e8       	ldi	r24, 0x86	; 134
    1b60:	80 83       	st	Z, r24
/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */
void UART0_sendByte (u8 data)
    1b62:	e4 ed       	ldi	r30, 0xD4	; 212
    1b64:	f0 e0       	ldi	r31, 0x00	; 0
    1b66:	87 e6       	ldi	r24, 0x67	; 103
    1b68:	80 83       	st	Z, r24
{
    1b6a:	cf 91       	pop	r28
    1b6c:	df 91       	pop	r29
    1b6e:	08 95       	ret

00001b70 <UART0_sendByte>:
	UDR0=data;
	while (!GET_BIT(UCSR0A,5)){}
	SET_BIT(UCSR0A,TXC);

}
/* this fun receive a byte and waits until the data is empty to avoid overwriting */
    1b70:	df 93       	push	r29
    1b72:	cf 93       	push	r28
    1b74:	0f 92       	push	r0
    1b76:	cd b7       	in	r28, 0x3d	; 61
    1b78:	de b7       	in	r29, 0x3e	; 62
    1b7a:	89 83       	std	Y+1, r24	; 0x01
u8 UART0_receiveByte (void)
    1b7c:	e6 ec       	ldi	r30, 0xC6	; 198
    1b7e:	f0 e0       	ldi	r31, 0x00	; 0
    1b80:	89 81       	ldd	r24, Y+1	; 0x01
    1b82:	80 83       	st	Z, r24
{
    1b84:	e0 ec       	ldi	r30, 0xC0	; 192
    1b86:	f0 e0       	ldi	r31, 0x00	; 0
    1b88:	80 81       	ld	r24, Z
    1b8a:	82 95       	swap	r24
    1b8c:	86 95       	lsr	r24
    1b8e:	87 70       	andi	r24, 0x07	; 7
    1b90:	88 2f       	mov	r24, r24
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	81 70       	andi	r24, 0x01	; 1
    1b96:	90 70       	andi	r25, 0x00	; 0
    1b98:	00 97       	sbiw	r24, 0x00	; 0
    1b9a:	a1 f3       	breq	.-24     	; 0x1b84 <UART0_sendByte+0x14>
	while (!GET_BIT(UCSR0A,7)){}
    1b9c:	a0 ec       	ldi	r26, 0xC0	; 192
    1b9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ba0:	e0 ec       	ldi	r30, 0xC0	; 192
    1ba2:	f0 e0       	ldi	r31, 0x00	; 0
    1ba4:	80 81       	ld	r24, Z
    1ba6:	80 64       	ori	r24, 0x40	; 64
    1ba8:	8c 93       	st	X, r24
	/*
	 * wait until the last byte is received
    1baa:	0f 90       	pop	r0
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <UART0_receiveByte>:
	 */
	return UDR0;
}
    1bb2:	df 93       	push	r29
    1bb4:	cf 93       	push	r28
    1bb6:	cd b7       	in	r28, 0x3d	; 61
    1bb8:	de b7       	in	r29, 0x3e	; 62

    1bba:	e0 ec       	ldi	r30, 0xC0	; 192
    1bbc:	f0 e0       	ldi	r31, 0x00	; 0
    1bbe:	80 81       	ld	r24, Z
    1bc0:	88 23       	and	r24, r24
    1bc2:	dc f7       	brge	.-10     	; 0x1bba <UART0_receiveByte+0x8>
/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */
void UART1_sendByte (u8 data)
{
	UDR1=data;
    1bc4:	e6 ec       	ldi	r30, 0xC6	; 198
    1bc6:	f0 e0       	ldi	r31, 0x00	; 0
    1bc8:	80 81       	ld	r24, Z
	while (!GET_BIT(UCSR1A,5)){}
    1bca:	cf 91       	pop	r28
    1bcc:	df 91       	pop	r29
    1bce:	08 95       	ret

00001bd0 <UART1_sendByte>:
	SET_BIT(UCSR1A,TXC);

}
/* this fun receive a byte and waits untill the data is empty to avoid overwriting */
    1bd0:	df 93       	push	r29
    1bd2:	cf 93       	push	r28
    1bd4:	0f 92       	push	r0
    1bd6:	cd b7       	in	r28, 0x3d	; 61
    1bd8:	de b7       	in	r29, 0x3e	; 62
    1bda:	89 83       	std	Y+1, r24	; 0x01
u8 UART1_receiveByte (void)
    1bdc:	ee ec       	ldi	r30, 0xCE	; 206
    1bde:	f0 e0       	ldi	r31, 0x00	; 0
    1be0:	89 81       	ldd	r24, Y+1	; 0x01
    1be2:	80 83       	st	Z, r24
{
    1be4:	e8 ec       	ldi	r30, 0xC8	; 200
    1be6:	f0 e0       	ldi	r31, 0x00	; 0
    1be8:	80 81       	ld	r24, Z
    1bea:	82 95       	swap	r24
    1bec:	86 95       	lsr	r24
    1bee:	87 70       	andi	r24, 0x07	; 7
    1bf0:	88 2f       	mov	r24, r24
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	81 70       	andi	r24, 0x01	; 1
    1bf6:	90 70       	andi	r25, 0x00	; 0
    1bf8:	00 97       	sbiw	r24, 0x00	; 0
    1bfa:	a1 f3       	breq	.-24     	; 0x1be4 <UART1_sendByte+0x14>
	while (!GET_BIT(UCSR1A,7)){}
    1bfc:	a8 ec       	ldi	r26, 0xC8	; 200
    1bfe:	b0 e0       	ldi	r27, 0x00	; 0
    1c00:	e8 ec       	ldi	r30, 0xC8	; 200
    1c02:	f0 e0       	ldi	r31, 0x00	; 0
    1c04:	80 81       	ld	r24, Z
    1c06:	80 64       	ori	r24, 0x40	; 64
    1c08:	8c 93       	st	X, r24
	/*
	 * wait until the last byte is received
    1c0a:	0f 90       	pop	r0
    1c0c:	cf 91       	pop	r28
    1c0e:	df 91       	pop	r29
    1c10:	08 95       	ret

00001c12 <UART1_receiveByte>:
	 */
	return UDR1;
}
    1c12:	df 93       	push	r29
    1c14:	cf 93       	push	r28
    1c16:	cd b7       	in	r28, 0x3d	; 61
    1c18:	de b7       	in	r29, 0x3e	; 62

    1c1a:	e8 ec       	ldi	r30, 0xC8	; 200
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	80 81       	ld	r24, Z
    1c20:	88 23       	and	r24, r24
    1c22:	dc f7       	brge	.-10     	; 0x1c1a <UART1_receiveByte+0x8>

/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */

/* this fun receive a byte and waits untill the data is empty to avoid overwriting */
    1c24:	ee ec       	ldi	r30, 0xCE	; 206
    1c26:	f0 e0       	ldi	r31, 0x00	; 0
    1c28:	80 81       	ld	r24, Z

    1c2a:	cf 91       	pop	r28
    1c2c:	df 91       	pop	r29
    1c2e:	08 95       	ret

00001c30 <UART2_sendByte>:



void UART0_sendString (const u8 *str)
{
    1c30:	df 93       	push	r29
    1c32:	cf 93       	push	r28
    1c34:	0f 92       	push	r0
    1c36:	cd b7       	in	r28, 0x3d	; 61
    1c38:	de b7       	in	r29, 0x3e	; 62
    1c3a:	89 83       	std	Y+1, r24	; 0x01
	while (*str != '\0')
    1c3c:	e6 ed       	ldi	r30, 0xD6	; 214
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	89 81       	ldd	r24, Y+1	; 0x01
    1c42:	80 83       	st	Z, r24
	{
    1c44:	e0 ed       	ldi	r30, 0xD0	; 208
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	80 81       	ld	r24, Z
    1c4a:	82 95       	swap	r24
    1c4c:	86 95       	lsr	r24
    1c4e:	87 70       	andi	r24, 0x07	; 7
    1c50:	88 2f       	mov	r24, r24
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	81 70       	andi	r24, 0x01	; 1
    1c56:	90 70       	andi	r25, 0x00	; 0
    1c58:	00 97       	sbiw	r24, 0x00	; 0
    1c5a:	a1 f3       	breq	.-24     	; 0x1c44 <UART2_sendByte+0x14>
		UART0_sendByte(*str);
    1c5c:	a0 ed       	ldi	r26, 0xD0	; 208
    1c5e:	b0 e0       	ldi	r27, 0x00	; 0
    1c60:	e0 ed       	ldi	r30, 0xD0	; 208
    1c62:	f0 e0       	ldi	r31, 0x00	; 0
    1c64:	80 81       	ld	r24, Z
    1c66:	80 64       	ori	r24, 0x40	; 64
    1c68:	8c 93       	st	X, r24
		str++;
	}
    1c6a:	0f 90       	pop	r0
    1c6c:	cf 91       	pop	r28
    1c6e:	df 91       	pop	r29
    1c70:	08 95       	ret

00001c72 <UART2_receiveByte>:
}


    1c72:	df 93       	push	r29
    1c74:	cf 93       	push	r28
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
void UART0_receiveString (u8 *str)
    1c7a:	e0 ed       	ldi	r30, 0xD0	; 208
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	80 81       	ld	r24, Z
    1c80:	88 23       	and	r24, r24
    1c82:	dc f7       	brge	.-10     	; 0x1c7a <UART2_receiveByte+0x8>
{
	*str=UART0_receiveByte();
	while (*str != '#')
	{
    1c84:	e6 ed       	ldi	r30, 0xD6	; 214
    1c86:	f0 e0       	ldi	r31, 0x00	; 0
    1c88:	80 81       	ld	r24, Z
		str++;
    1c8a:	cf 91       	pop	r28
    1c8c:	df 91       	pop	r29
    1c8e:	08 95       	ret

00001c90 <UART0_sendString>:
		*str=UART0_receiveByte();

	}
	*str='\0';

    1c90:	df 93       	push	r29
    1c92:	cf 93       	push	r28
    1c94:	00 d0       	rcall	.+0      	; 0x1c96 <UART0_sendString+0x6>
    1c96:	cd b7       	in	r28, 0x3d	; 61
    1c98:	de b7       	in	r29, 0x3e	; 62
    1c9a:	9a 83       	std	Y+2, r25	; 0x02
    1c9c:	89 83       	std	Y+1, r24	; 0x01
    1c9e:	0a c0       	rjmp	.+20     	; 0x1cb4 <UART0_sendString+0x24>
}


    1ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca4:	80 81       	ld	r24, Z
    1ca6:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <UART0_sendByte>
void UART1_sendString (const u8 *str)
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	9a 81       	ldd	r25, Y+2	; 0x02
    1cae:	01 96       	adiw	r24, 0x01	; 1
    1cb0:	9a 83       	std	Y+2, r25	; 0x02
    1cb2:	89 83       	std	Y+1, r24	; 0x01
		*str=UART0_receiveByte();

	}
	*str='\0';

}
    1cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb8:	80 81       	ld	r24, Z
    1cba:	88 23       	and	r24, r24
    1cbc:	89 f7       	brne	.-30     	; 0x1ca0 <UART0_sendString+0x10>


void UART1_sendString (const u8 *str)
{
	while (*str != '\0')
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	cf 91       	pop	r28
    1cc4:	df 91       	pop	r29
    1cc6:	08 95       	ret

00001cc8 <UART0_receiveString>:
	{
		UART1_sendByte(*str);
		str++;
	}
    1cc8:	df 93       	push	r29
    1cca:	cf 93       	push	r28
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <UART0_receiveString+0x6>
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	9a 83       	std	Y+2, r25	; 0x02
    1cd4:	89 83       	std	Y+1, r24	; 0x01
}
    1cd6:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <UART0_receiveByte>
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	80 83       	st	Z, r24
    1ce0:	0a c0       	rjmp	.+20     	; 0x1cf6 <UART0_receiveString+0x2e>


void UART1_receiveString (u8 *str)
    1ce2:	89 81       	ldd	r24, Y+1	; 0x01
    1ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce6:	01 96       	adiw	r24, 0x01	; 1
    1ce8:	9a 83       	std	Y+2, r25	; 0x02
    1cea:	89 83       	std	Y+1, r24	; 0x01
{
    1cec:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <UART0_receiveByte>
    1cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf4:	80 83       	st	Z, r24
	{
		UART1_sendByte(*str);
		str++;
	}
}

    1cf6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfa:	80 81       	ld	r24, Z
    1cfc:	83 32       	cpi	r24, 0x23	; 35
    1cfe:	89 f7       	brne	.-30     	; 0x1ce2 <UART0_receiveString+0x1a>

void UART1_receiveString (u8 *str)
{
	*str=UART1_receiveByte();
	while (*str != ',')
	{
    1d00:	e9 81       	ldd	r30, Y+1	; 0x01
    1d02:	fa 81       	ldd	r31, Y+2	; 0x02
    1d04:	10 82       	st	Z, r1
		str++;
		*str=UART1_receiveByte();
    1d06:	0f 90       	pop	r0
    1d08:	0f 90       	pop	r0
    1d0a:	cf 91       	pop	r28
    1d0c:	df 91       	pop	r29
    1d0e:	08 95       	ret

00001d10 <UART1_sendString>:

	}
	*str='\0';

    1d10:	df 93       	push	r29
    1d12:	cf 93       	push	r28
    1d14:	00 d0       	rcall	.+0      	; 0x1d16 <UART1_sendString+0x6>
    1d16:	cd b7       	in	r28, 0x3d	; 61
    1d18:	de b7       	in	r29, 0x3e	; 62
    1d1a:	9a 83       	std	Y+2, r25	; 0x02
    1d1c:	89 83       	std	Y+1, r24	; 0x01
    1d1e:	0a c0       	rjmp	.+20     	; 0x1d34 <UART1_sendString+0x24>
}


    1d20:	e9 81       	ldd	r30, Y+1	; 0x01
    1d22:	fa 81       	ldd	r31, Y+2	; 0x02
    1d24:	80 81       	ld	r24, Z
    1d26:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <UART1_sendByte>

    1d2a:	89 81       	ldd	r24, Y+1	; 0x01
    1d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2e:	01 96       	adiw	r24, 0x01	; 1
    1d30:	9a 83       	std	Y+2, r25	; 0x02
    1d32:	89 83       	std	Y+1, r24	; 0x01
		*str=UART1_receiveByte();

	}
	*str='\0';

}
    1d34:	e9 81       	ldd	r30, Y+1	; 0x01
    1d36:	fa 81       	ldd	r31, Y+2	; 0x02
    1d38:	80 81       	ld	r24, Z
    1d3a:	88 23       	and	r24, r24
    1d3c:	89 f7       	brne	.-30     	; 0x1d20 <UART1_sendString+0x10>



    1d3e:	0f 90       	pop	r0
    1d40:	0f 90       	pop	r0
    1d42:	cf 91       	pop	r28
    1d44:	df 91       	pop	r29
    1d46:	08 95       	ret

00001d48 <UART1_receiveString>:
    1d48:	df 93       	push	r29
    1d4a:	cf 93       	push	r28
    1d4c:	00 d0       	rcall	.+0      	; 0x1d4e <UART1_receiveString+0x6>
    1d4e:	cd b7       	in	r28, 0x3d	; 61
    1d50:	de b7       	in	r29, 0x3e	; 62
    1d52:	9a 83       	std	Y+2, r25	; 0x02
    1d54:	89 83       	std	Y+1, r24	; 0x01
    1d56:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
    1d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5e:	80 83       	st	Z, r24
    1d60:	0a c0       	rjmp	.+20     	; 0x1d76 <UART1_receiveString+0x2e>
    1d62:	89 81       	ldd	r24, Y+1	; 0x01
    1d64:	9a 81       	ldd	r25, Y+2	; 0x02
    1d66:	01 96       	adiw	r24, 0x01	; 1
    1d68:	9a 83       	std	Y+2, r25	; 0x02
    1d6a:	89 83       	std	Y+1, r24	; 0x01
    1d6c:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	80 83       	st	Z, r24
    1d76:	e9 81       	ldd	r30, Y+1	; 0x01
    1d78:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7a:	80 81       	ld	r24, Z
    1d7c:	83 32       	cpi	r24, 0x23	; 35
    1d7e:	89 f7       	brne	.-30     	; 0x1d62 <UART1_receiveString+0x1a>
    1d80:	e9 81       	ldd	r30, Y+1	; 0x01
    1d82:	fa 81       	ldd	r31, Y+2	; 0x02
    1d84:	10 82       	st	Z, r1
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	cf 91       	pop	r28
    1d8c:	df 91       	pop	r29
    1d8e:	08 95       	ret

00001d90 <UART2_sendString>:
    1d90:	df 93       	push	r29
    1d92:	cf 93       	push	r28
    1d94:	00 d0       	rcall	.+0      	; 0x1d96 <UART2_sendString+0x6>
    1d96:	cd b7       	in	r28, 0x3d	; 61
    1d98:	de b7       	in	r29, 0x3e	; 62
    1d9a:	9a 83       	std	Y+2, r25	; 0x02
    1d9c:	89 83       	std	Y+1, r24	; 0x01
    1d9e:	0a c0       	rjmp	.+20     	; 0x1db4 <UART2_sendString+0x24>
    1da0:	e9 81       	ldd	r30, Y+1	; 0x01
    1da2:	fa 81       	ldd	r31, Y+2	; 0x02
    1da4:	80 81       	ld	r24, Z
    1da6:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <UART2_sendByte>
    1daa:	89 81       	ldd	r24, Y+1	; 0x01
    1dac:	9a 81       	ldd	r25, Y+2	; 0x02
    1dae:	01 96       	adiw	r24, 0x01	; 1
    1db0:	9a 83       	std	Y+2, r25	; 0x02
    1db2:	89 83       	std	Y+1, r24	; 0x01
    1db4:	e9 81       	ldd	r30, Y+1	; 0x01
    1db6:	fa 81       	ldd	r31, Y+2	; 0x02
    1db8:	80 81       	ld	r24, Z
    1dba:	88 23       	and	r24, r24
    1dbc:	89 f7       	brne	.-30     	; 0x1da0 <UART2_sendString+0x10>
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	cf 91       	pop	r28
    1dc4:	df 91       	pop	r29
    1dc6:	08 95       	ret

00001dc8 <UART2_receiveString>:
    1dc8:	df 93       	push	r29
    1dca:	cf 93       	push	r28
    1dcc:	00 d0       	rcall	.+0      	; 0x1dce <UART2_receiveString+0x6>
    1dce:	cd b7       	in	r28, 0x3d	; 61
    1dd0:	de b7       	in	r29, 0x3e	; 62
    1dd2:	9a 83       	std	Y+2, r25	; 0x02
    1dd4:	89 83       	std	Y+1, r24	; 0x01
    1dd6:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <UART2_receiveByte>
    1dda:	e9 81       	ldd	r30, Y+1	; 0x01
    1ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dde:	80 83       	st	Z, r24
    1de0:	0a c0       	rjmp	.+20     	; 0x1df6 <UART2_receiveString+0x2e>
    1de2:	89 81       	ldd	r24, Y+1	; 0x01
    1de4:	9a 81       	ldd	r25, Y+2	; 0x02
    1de6:	01 96       	adiw	r24, 0x01	; 1
    1de8:	9a 83       	std	Y+2, r25	; 0x02
    1dea:	89 83       	std	Y+1, r24	; 0x01
    1dec:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <UART2_receiveByte>
    1df0:	e9 81       	ldd	r30, Y+1	; 0x01
    1df2:	fa 81       	ldd	r31, Y+2	; 0x02
    1df4:	80 83       	st	Z, r24
    1df6:	e9 81       	ldd	r30, Y+1	; 0x01
    1df8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfa:	80 81       	ld	r24, Z
    1dfc:	8c 32       	cpi	r24, 0x2C	; 44
    1dfe:	89 f7       	brne	.-30     	; 0x1de2 <UART2_receiveString+0x1a>
    1e00:	e9 81       	ldd	r30, Y+1	; 0x01
    1e02:	fa 81       	ldd	r31, Y+2	; 0x02
    1e04:	10 82       	st	Z, r1
    1e06:	0f 90       	pop	r0
    1e08:	0f 90       	pop	r0
    1e0a:	cf 91       	pop	r28
    1e0c:	df 91       	pop	r29
    1e0e:	08 95       	ret

00001e10 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1e10:	df 93       	push	r29
    1e12:	cf 93       	push	r28
    1e14:	cd b7       	in	r28, 0x3d	; 61
    1e16:	de b7       	in	r29, 0x3e	; 62
    1e18:	27 97       	sbiw	r28, 0x07	; 7
    1e1a:	0f b6       	in	r0, 0x3f	; 63
    1e1c:	f8 94       	cli
    1e1e:	de bf       	out	0x3e, r29	; 62
    1e20:	0f be       	out	0x3f, r0	; 63
    1e22:	cd bf       	out	0x3d, r28	; 61
    1e24:	9d 83       	std	Y+5, r25	; 0x05
    1e26:	8c 83       	std	Y+4, r24	; 0x04
    1e28:	6e 83       	std	Y+6, r22	; 0x06
    1e2a:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1e2c:	8a e1       	ldi	r24, 0x1A	; 26
    1e2e:	90 e0       	ldi	r25, 0x00	; 0
    1e30:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <pvPortMalloc>
    1e34:	9a 83       	std	Y+2, r25	; 0x02
    1e36:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1e38:	89 81       	ldd	r24, Y+1	; 0x01
    1e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e3c:	00 97       	sbiw	r24, 0x00	; 0
    1e3e:	09 f4       	brne	.+2      	; 0x1e42 <xCoRoutineCreate+0x32>
    1e40:	6f c0       	rjmp	.+222    	; 0x1f20 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1e42:	80 91 10 01 	lds	r24, 0x0110
    1e46:	90 91 11 01 	lds	r25, 0x0111
    1e4a:	00 97       	sbiw	r24, 0x00	; 0
    1e4c:	41 f4       	brne	.+16     	; 0x1e5e <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1e4e:	89 81       	ldd	r24, Y+1	; 0x01
    1e50:	9a 81       	ldd	r25, Y+2	; 0x02
    1e52:	90 93 11 01 	sts	0x0111, r25
    1e56:	80 93 10 01 	sts	0x0110, r24
			prvInitialiseCoRoutineLists();
    1e5a:	0e 94 6f 11 	call	0x22de	; 0x22de <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1e5e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e60:	82 30       	cpi	r24, 0x02	; 2
    1e62:	10 f0       	brcs	.+4      	; 0x1e68 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1e64:	81 e0       	ldi	r24, 0x01	; 1
    1e66:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1e68:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6c:	11 8e       	std	Z+25, r1	; 0x19
    1e6e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1e70:	e9 81       	ldd	r30, Y+1	; 0x01
    1e72:	fa 81       	ldd	r31, Y+2	; 0x02
    1e74:	8e 81       	ldd	r24, Y+6	; 0x06
    1e76:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1e78:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1e7e:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1e80:	e9 81       	ldd	r30, Y+1	; 0x01
    1e82:	fa 81       	ldd	r31, Y+2	; 0x02
    1e84:	8c 81       	ldd	r24, Y+4	; 0x04
    1e86:	9d 81       	ldd	r25, Y+5	; 0x05
    1e88:	91 83       	std	Z+1, r25	; 0x01
    1e8a:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1e8c:	89 81       	ldd	r24, Y+1	; 0x01
    1e8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e90:	02 96       	adiw	r24, 0x02	; 2
    1e92:	0e 94 c3 18 	call	0x3186	; 0x3186 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1e96:	89 81       	ldd	r24, Y+1	; 0x01
    1e98:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9a:	0c 96       	adiw	r24, 0x0c	; 12
    1e9c:	0e 94 c3 18 	call	0x3186	; 0x3186 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea4:	89 81       	ldd	r24, Y+1	; 0x01
    1ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ea8:	91 87       	std	Z+9, r25	; 0x09
    1eaa:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1eac:	e9 81       	ldd	r30, Y+1	; 0x01
    1eae:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb0:	89 81       	ldd	r24, Y+1	; 0x01
    1eb2:	9a 81       	ldd	r25, Y+2	; 0x02
    1eb4:	93 8b       	std	Z+19, r25	; 0x13
    1eb6:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1eb8:	8e 81       	ldd	r24, Y+6	; 0x06
    1eba:	28 2f       	mov	r18, r24
    1ebc:	30 e0       	ldi	r19, 0x00	; 0
    1ebe:	83 e0       	ldi	r24, 0x03	; 3
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	82 1b       	sub	r24, r18
    1ec4:	93 0b       	sbc	r25, r19
    1ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eca:	95 87       	std	Z+13, r25	; 0x0d
    1ecc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1ece:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed2:	96 89       	ldd	r25, Z+22	; 0x16
    1ed4:	80 91 12 01 	lds	r24, 0x0112
    1ed8:	89 17       	cp	r24, r25
    1eda:	28 f4       	brcc	.+10     	; 0x1ee6 <xCoRoutineCreate+0xd6>
    1edc:	e9 81       	ldd	r30, Y+1	; 0x01
    1ede:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee0:	86 89       	ldd	r24, Z+22	; 0x16
    1ee2:	80 93 12 01 	sts	0x0112, r24
    1ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eea:	86 89       	ldd	r24, Z+22	; 0x16
    1eec:	28 2f       	mov	r18, r24
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	c9 01       	movw	r24, r18
    1ef2:	88 0f       	add	r24, r24
    1ef4:	99 1f       	adc	r25, r25
    1ef6:	88 0f       	add	r24, r24
    1ef8:	99 1f       	adc	r25, r25
    1efa:	88 0f       	add	r24, r24
    1efc:	99 1f       	adc	r25, r25
    1efe:	82 0f       	add	r24, r18
    1f00:	93 1f       	adc	r25, r19
    1f02:	ac 01       	movw	r20, r24
    1f04:	47 5e       	subi	r20, 0xE7	; 231
    1f06:	5e 4f       	sbci	r21, 0xFE	; 254
    1f08:	89 81       	ldd	r24, Y+1	; 0x01
    1f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f0c:	9c 01       	movw	r18, r24
    1f0e:	2e 5f       	subi	r18, 0xFE	; 254
    1f10:	3f 4f       	sbci	r19, 0xFF	; 255
    1f12:	ca 01       	movw	r24, r20
    1f14:	b9 01       	movw	r22, r18
    1f16:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>

		xReturn = pdPASS;
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	8b 83       	std	Y+3, r24	; 0x03
    1f1e:	02 c0       	rjmp	.+4      	; 0x1f24 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f20:	8f ef       	ldi	r24, 0xFF	; 255
    1f22:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1f26:	27 96       	adiw	r28, 0x07	; 7
    1f28:	0f b6       	in	r0, 0x3f	; 63
    1f2a:	f8 94       	cli
    1f2c:	de bf       	out	0x3e, r29	; 62
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	cd bf       	out	0x3d, r28	; 61
    1f32:	cf 91       	pop	r28
    1f34:	df 91       	pop	r29
    1f36:	08 95       	ret

00001f38 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1f38:	df 93       	push	r29
    1f3a:	cf 93       	push	r28
    1f3c:	00 d0       	rcall	.+0      	; 0x1f3e <vCoRoutineAddToDelayedList+0x6>
    1f3e:	00 d0       	rcall	.+0      	; 0x1f40 <vCoRoutineAddToDelayedList+0x8>
    1f40:	00 d0       	rcall	.+0      	; 0x1f42 <vCoRoutineAddToDelayedList+0xa>
    1f42:	cd b7       	in	r28, 0x3d	; 61
    1f44:	de b7       	in	r29, 0x3e	; 62
    1f46:	9c 83       	std	Y+4, r25	; 0x04
    1f48:	8b 83       	std	Y+3, r24	; 0x03
    1f4a:	7e 83       	std	Y+6, r23	; 0x06
    1f4c:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1f4e:	20 91 13 01 	lds	r18, 0x0113
    1f52:	30 91 14 01 	lds	r19, 0x0114
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	82 0f       	add	r24, r18
    1f5c:	93 1f       	adc	r25, r19
    1f5e:	9a 83       	std	Y+2, r25	; 0x02
    1f60:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f62:	80 91 10 01 	lds	r24, 0x0110
    1f66:	90 91 11 01 	lds	r25, 0x0111
    1f6a:	02 96       	adiw	r24, 0x02	; 2
    1f6c:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1f70:	e0 91 10 01 	lds	r30, 0x0110
    1f74:	f0 91 11 01 	lds	r31, 0x0111
    1f78:	89 81       	ldd	r24, Y+1	; 0x01
    1f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7c:	93 83       	std	Z+3, r25	; 0x03
    1f7e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1f80:	20 91 13 01 	lds	r18, 0x0113
    1f84:	30 91 14 01 	lds	r19, 0x0114
    1f88:	89 81       	ldd	r24, Y+1	; 0x01
    1f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f8c:	82 17       	cp	r24, r18
    1f8e:	93 07       	cpc	r25, r19
    1f90:	70 f4       	brcc	.+28     	; 0x1fae <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f92:	80 91 3f 01 	lds	r24, 0x013F
    1f96:	90 91 40 01 	lds	r25, 0x0140
    1f9a:	20 91 10 01 	lds	r18, 0x0110
    1f9e:	30 91 11 01 	lds	r19, 0x0111
    1fa2:	2e 5f       	subi	r18, 0xFE	; 254
    1fa4:	3f 4f       	sbci	r19, 0xFF	; 255
    1fa6:	b9 01       	movw	r22, r18
    1fa8:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>
    1fac:	0d c0       	rjmp	.+26     	; 0x1fc8 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1fae:	80 91 3d 01 	lds	r24, 0x013D
    1fb2:	90 91 3e 01 	lds	r25, 0x013E
    1fb6:	20 91 10 01 	lds	r18, 0x0110
    1fba:	30 91 11 01 	lds	r19, 0x0111
    1fbe:	2e 5f       	subi	r18, 0xFE	; 254
    1fc0:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc2:	b9 01       	movw	r22, r18
    1fc4:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>
	}

	if( pxEventList )
    1fc8:	8d 81       	ldd	r24, Y+5	; 0x05
    1fca:	9e 81       	ldd	r25, Y+6	; 0x06
    1fcc:	00 97       	sbiw	r24, 0x00	; 0
    1fce:	61 f0       	breq	.+24     	; 0x1fe8 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1fd0:	80 91 10 01 	lds	r24, 0x0110
    1fd4:	90 91 11 01 	lds	r25, 0x0111
    1fd8:	9c 01       	movw	r18, r24
    1fda:	24 5f       	subi	r18, 0xF4	; 244
    1fdc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fde:	8d 81       	ldd	r24, Y+5	; 0x05
    1fe0:	9e 81       	ldd	r25, Y+6	; 0x06
    1fe2:	b9 01       	movw	r22, r18
    1fe4:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>
	}
}
    1fe8:	26 96       	adiw	r28, 0x06	; 6
    1fea:	0f b6       	in	r0, 0x3f	; 63
    1fec:	f8 94       	cli
    1fee:	de bf       	out	0x3e, r29	; 62
    1ff0:	0f be       	out	0x3f, r0	; 63
    1ff2:	cd bf       	out	0x3d, r28	; 61
    1ff4:	cf 91       	pop	r28
    1ff6:	df 91       	pop	r29
    1ff8:	08 95       	ret

00001ffa <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1ffa:	df 93       	push	r29
    1ffc:	cf 93       	push	r28
    1ffe:	00 d0       	rcall	.+0      	; 0x2000 <prvCheckPendingReadyList+0x6>
    2000:	cd b7       	in	r28, 0x3d	; 61
    2002:	de b7       	in	r29, 0x3e	; 62
    2004:	3a c0       	rjmp	.+116    	; 0x207a <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2006:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2008:	e0 91 46 01 	lds	r30, 0x0146
    200c:	f0 91 47 01 	lds	r31, 0x0147
    2010:	86 81       	ldd	r24, Z+6	; 0x06
    2012:	97 81       	ldd	r25, Z+7	; 0x07
    2014:	9a 83       	std	Y+2, r25	; 0x02
    2016:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	9a 81       	ldd	r25, Y+2	; 0x02
    201c:	0c 96       	adiw	r24, 0x0c	; 12
    201e:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2022:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2024:	89 81       	ldd	r24, Y+1	; 0x01
    2026:	9a 81       	ldd	r25, Y+2	; 0x02
    2028:	02 96       	adiw	r24, 0x02	; 2
    202a:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    202e:	e9 81       	ldd	r30, Y+1	; 0x01
    2030:	fa 81       	ldd	r31, Y+2	; 0x02
    2032:	96 89       	ldd	r25, Z+22	; 0x16
    2034:	80 91 12 01 	lds	r24, 0x0112
    2038:	89 17       	cp	r24, r25
    203a:	28 f4       	brcc	.+10     	; 0x2046 <prvCheckPendingReadyList+0x4c>
    203c:	e9 81       	ldd	r30, Y+1	; 0x01
    203e:	fa 81       	ldd	r31, Y+2	; 0x02
    2040:	86 89       	ldd	r24, Z+22	; 0x16
    2042:	80 93 12 01 	sts	0x0112, r24
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	86 89       	ldd	r24, Z+22	; 0x16
    204c:	28 2f       	mov	r18, r24
    204e:	30 e0       	ldi	r19, 0x00	; 0
    2050:	c9 01       	movw	r24, r18
    2052:	88 0f       	add	r24, r24
    2054:	99 1f       	adc	r25, r25
    2056:	88 0f       	add	r24, r24
    2058:	99 1f       	adc	r25, r25
    205a:	88 0f       	add	r24, r24
    205c:	99 1f       	adc	r25, r25
    205e:	82 0f       	add	r24, r18
    2060:	93 1f       	adc	r25, r19
    2062:	ac 01       	movw	r20, r24
    2064:	47 5e       	subi	r20, 0xE7	; 231
    2066:	5e 4f       	sbci	r21, 0xFE	; 254
    2068:	89 81       	ldd	r24, Y+1	; 0x01
    206a:	9a 81       	ldd	r25, Y+2	; 0x02
    206c:	9c 01       	movw	r18, r24
    206e:	2e 5f       	subi	r18, 0xFE	; 254
    2070:	3f 4f       	sbci	r19, 0xFF	; 255
    2072:	ca 01       	movw	r24, r20
    2074:	b9 01       	movw	r22, r18
    2076:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    207a:	80 91 41 01 	lds	r24, 0x0141
    207e:	88 23       	and	r24, r24
    2080:	09 f0       	breq	.+2      	; 0x2084 <prvCheckPendingReadyList+0x8a>
    2082:	c1 cf       	rjmp	.-126    	; 0x2006 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2084:	0f 90       	pop	r0
    2086:	0f 90       	pop	r0
    2088:	cf 91       	pop	r28
    208a:	df 91       	pop	r29
    208c:	08 95       	ret

0000208e <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    208e:	df 93       	push	r29
    2090:	cf 93       	push	r28
    2092:	00 d0       	rcall	.+0      	; 0x2094 <prvCheckDelayedList+0x6>
    2094:	00 d0       	rcall	.+0      	; 0x2096 <prvCheckDelayedList+0x8>
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    209a:	0e 94 36 28 	call	0x506c	; 0x506c <xTaskGetTickCount>
    209e:	20 91 15 01 	lds	r18, 0x0115
    20a2:	30 91 16 01 	lds	r19, 0x0116
    20a6:	82 1b       	sub	r24, r18
    20a8:	93 0b       	sbc	r25, r19
    20aa:	90 93 18 01 	sts	0x0118, r25
    20ae:	80 93 17 01 	sts	0x0117, r24
    20b2:	85 c0       	rjmp	.+266    	; 0x21be <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    20b4:	80 91 13 01 	lds	r24, 0x0113
    20b8:	90 91 14 01 	lds	r25, 0x0114
    20bc:	01 96       	adiw	r24, 0x01	; 1
    20be:	90 93 14 01 	sts	0x0114, r25
    20c2:	80 93 13 01 	sts	0x0113, r24
		xPassedTicks--;
    20c6:	80 91 17 01 	lds	r24, 0x0117
    20ca:	90 91 18 01 	lds	r25, 0x0118
    20ce:	01 97       	sbiw	r24, 0x01	; 1
    20d0:	90 93 18 01 	sts	0x0118, r25
    20d4:	80 93 17 01 	sts	0x0117, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    20d8:	80 91 13 01 	lds	r24, 0x0113
    20dc:	90 91 14 01 	lds	r25, 0x0114
    20e0:	00 97       	sbiw	r24, 0x00	; 0
    20e2:	09 f0       	breq	.+2      	; 0x20e6 <prvCheckDelayedList+0x58>
    20e4:	64 c0       	rjmp	.+200    	; 0x21ae <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    20e6:	80 91 3d 01 	lds	r24, 0x013D
    20ea:	90 91 3e 01 	lds	r25, 0x013E
    20ee:	9a 83       	std	Y+2, r25	; 0x02
    20f0:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    20f2:	80 91 3f 01 	lds	r24, 0x013F
    20f6:	90 91 40 01 	lds	r25, 0x0140
    20fa:	90 93 3e 01 	sts	0x013E, r25
    20fe:	80 93 3d 01 	sts	0x013D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2102:	89 81       	ldd	r24, Y+1	; 0x01
    2104:	9a 81       	ldd	r25, Y+2	; 0x02
    2106:	90 93 40 01 	sts	0x0140, r25
    210a:	80 93 3f 01 	sts	0x013F, r24
    210e:	4f c0       	rjmp	.+158    	; 0x21ae <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2110:	e0 91 3d 01 	lds	r30, 0x013D
    2114:	f0 91 3e 01 	lds	r31, 0x013E
    2118:	05 80       	ldd	r0, Z+5	; 0x05
    211a:	f6 81       	ldd	r31, Z+6	; 0x06
    211c:	e0 2d       	mov	r30, r0
    211e:	86 81       	ldd	r24, Z+6	; 0x06
    2120:	97 81       	ldd	r25, Z+7	; 0x07
    2122:	9c 83       	std	Y+4, r25	; 0x04
    2124:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2126:	eb 81       	ldd	r30, Y+3	; 0x03
    2128:	fc 81       	ldd	r31, Y+4	; 0x04
    212a:	22 81       	ldd	r18, Z+2	; 0x02
    212c:	33 81       	ldd	r19, Z+3	; 0x03
    212e:	80 91 13 01 	lds	r24, 0x0113
    2132:	90 91 14 01 	lds	r25, 0x0114
    2136:	82 17       	cp	r24, r18
    2138:	93 07       	cpc	r25, r19
    213a:	08 f4       	brcc	.+2      	; 0x213e <prvCheckDelayedList+0xb0>
    213c:	40 c0       	rjmp	.+128    	; 0x21be <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    213e:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2140:	8b 81       	ldd	r24, Y+3	; 0x03
    2142:	9c 81       	ldd	r25, Y+4	; 0x04
    2144:	02 96       	adiw	r24, 0x02	; 2
    2146:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    214a:	eb 81       	ldd	r30, Y+3	; 0x03
    214c:	fc 81       	ldd	r31, Y+4	; 0x04
    214e:	84 89       	ldd	r24, Z+20	; 0x14
    2150:	95 89       	ldd	r25, Z+21	; 0x15
    2152:	00 97       	sbiw	r24, 0x00	; 0
    2154:	29 f0       	breq	.+10     	; 0x2160 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2156:	8b 81       	ldd	r24, Y+3	; 0x03
    2158:	9c 81       	ldd	r25, Y+4	; 0x04
    215a:	0c 96       	adiw	r24, 0x0c	; 12
    215c:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2160:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2162:	eb 81       	ldd	r30, Y+3	; 0x03
    2164:	fc 81       	ldd	r31, Y+4	; 0x04
    2166:	96 89       	ldd	r25, Z+22	; 0x16
    2168:	80 91 12 01 	lds	r24, 0x0112
    216c:	89 17       	cp	r24, r25
    216e:	28 f4       	brcc	.+10     	; 0x217a <prvCheckDelayedList+0xec>
    2170:	eb 81       	ldd	r30, Y+3	; 0x03
    2172:	fc 81       	ldd	r31, Y+4	; 0x04
    2174:	86 89       	ldd	r24, Z+22	; 0x16
    2176:	80 93 12 01 	sts	0x0112, r24
    217a:	eb 81       	ldd	r30, Y+3	; 0x03
    217c:	fc 81       	ldd	r31, Y+4	; 0x04
    217e:	86 89       	ldd	r24, Z+22	; 0x16
    2180:	28 2f       	mov	r18, r24
    2182:	30 e0       	ldi	r19, 0x00	; 0
    2184:	c9 01       	movw	r24, r18
    2186:	88 0f       	add	r24, r24
    2188:	99 1f       	adc	r25, r25
    218a:	88 0f       	add	r24, r24
    218c:	99 1f       	adc	r25, r25
    218e:	88 0f       	add	r24, r24
    2190:	99 1f       	adc	r25, r25
    2192:	82 0f       	add	r24, r18
    2194:	93 1f       	adc	r25, r19
    2196:	ac 01       	movw	r20, r24
    2198:	47 5e       	subi	r20, 0xE7	; 231
    219a:	5e 4f       	sbci	r21, 0xFE	; 254
    219c:	8b 81       	ldd	r24, Y+3	; 0x03
    219e:	9c 81       	ldd	r25, Y+4	; 0x04
    21a0:	9c 01       	movw	r18, r24
    21a2:	2e 5f       	subi	r18, 0xFE	; 254
    21a4:	3f 4f       	sbci	r19, 0xFF	; 255
    21a6:	ca 01       	movw	r24, r20
    21a8:	b9 01       	movw	r22, r18
    21aa:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    21ae:	e0 91 3d 01 	lds	r30, 0x013D
    21b2:	f0 91 3e 01 	lds	r31, 0x013E
    21b6:	80 81       	ld	r24, Z
    21b8:	88 23       	and	r24, r24
    21ba:	09 f0       	breq	.+2      	; 0x21be <prvCheckDelayedList+0x130>
    21bc:	a9 cf       	rjmp	.-174    	; 0x2110 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    21be:	80 91 17 01 	lds	r24, 0x0117
    21c2:	90 91 18 01 	lds	r25, 0x0118
    21c6:	00 97       	sbiw	r24, 0x00	; 0
    21c8:	09 f0       	breq	.+2      	; 0x21cc <prvCheckDelayedList+0x13e>
    21ca:	74 cf       	rjmp	.-280    	; 0x20b4 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    21cc:	80 91 13 01 	lds	r24, 0x0113
    21d0:	90 91 14 01 	lds	r25, 0x0114
    21d4:	90 93 16 01 	sts	0x0116, r25
    21d8:	80 93 15 01 	sts	0x0115, r24
}
    21dc:	0f 90       	pop	r0
    21de:	0f 90       	pop	r0
    21e0:	0f 90       	pop	r0
    21e2:	0f 90       	pop	r0
    21e4:	cf 91       	pop	r28
    21e6:	df 91       	pop	r29
    21e8:	08 95       	ret

000021ea <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    21ea:	df 93       	push	r29
    21ec:	cf 93       	push	r28
    21ee:	00 d0       	rcall	.+0      	; 0x21f0 <vCoRoutineSchedule+0x6>
    21f0:	cd b7       	in	r28, 0x3d	; 61
    21f2:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    21f4:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    21f8:	0e 94 47 10 	call	0x208e	; 0x208e <prvCheckDelayedList>
    21fc:	0a c0       	rjmp	.+20     	; 0x2212 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    21fe:	80 91 12 01 	lds	r24, 0x0112
    2202:	88 23       	and	r24, r24
    2204:	09 f4       	brne	.+2      	; 0x2208 <vCoRoutineSchedule+0x1e>
    2206:	66 c0       	rjmp	.+204    	; 0x22d4 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2208:	80 91 12 01 	lds	r24, 0x0112
    220c:	81 50       	subi	r24, 0x01	; 1
    220e:	80 93 12 01 	sts	0x0112, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2212:	80 91 12 01 	lds	r24, 0x0112
    2216:	28 2f       	mov	r18, r24
    2218:	30 e0       	ldi	r19, 0x00	; 0
    221a:	c9 01       	movw	r24, r18
    221c:	88 0f       	add	r24, r24
    221e:	99 1f       	adc	r25, r25
    2220:	88 0f       	add	r24, r24
    2222:	99 1f       	adc	r25, r25
    2224:	88 0f       	add	r24, r24
    2226:	99 1f       	adc	r25, r25
    2228:	82 0f       	add	r24, r18
    222a:	93 1f       	adc	r25, r19
    222c:	fc 01       	movw	r30, r24
    222e:	e7 5e       	subi	r30, 0xE7	; 231
    2230:	fe 4f       	sbci	r31, 0xFE	; 254
    2232:	80 81       	ld	r24, Z
    2234:	88 23       	and	r24, r24
    2236:	19 f3       	breq	.-58     	; 0x21fe <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2238:	80 91 12 01 	lds	r24, 0x0112
    223c:	28 2f       	mov	r18, r24
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	c9 01       	movw	r24, r18
    2242:	88 0f       	add	r24, r24
    2244:	99 1f       	adc	r25, r25
    2246:	88 0f       	add	r24, r24
    2248:	99 1f       	adc	r25, r25
    224a:	88 0f       	add	r24, r24
    224c:	99 1f       	adc	r25, r25
    224e:	82 0f       	add	r24, r18
    2250:	93 1f       	adc	r25, r19
    2252:	87 5e       	subi	r24, 0xE7	; 231
    2254:	9e 4f       	sbci	r25, 0xFE	; 254
    2256:	9a 83       	std	Y+2, r25	; 0x02
    2258:	89 83       	std	Y+1, r24	; 0x01
    225a:	e9 81       	ldd	r30, Y+1	; 0x01
    225c:	fa 81       	ldd	r31, Y+2	; 0x02
    225e:	01 80       	ldd	r0, Z+1	; 0x01
    2260:	f2 81       	ldd	r31, Z+2	; 0x02
    2262:	e0 2d       	mov	r30, r0
    2264:	82 81       	ldd	r24, Z+2	; 0x02
    2266:	93 81       	ldd	r25, Z+3	; 0x03
    2268:	e9 81       	ldd	r30, Y+1	; 0x01
    226a:	fa 81       	ldd	r31, Y+2	; 0x02
    226c:	92 83       	std	Z+2, r25	; 0x02
    226e:	81 83       	std	Z+1, r24	; 0x01
    2270:	e9 81       	ldd	r30, Y+1	; 0x01
    2272:	fa 81       	ldd	r31, Y+2	; 0x02
    2274:	21 81       	ldd	r18, Z+1	; 0x01
    2276:	32 81       	ldd	r19, Z+2	; 0x02
    2278:	89 81       	ldd	r24, Y+1	; 0x01
    227a:	9a 81       	ldd	r25, Y+2	; 0x02
    227c:	03 96       	adiw	r24, 0x03	; 3
    227e:	28 17       	cp	r18, r24
    2280:	39 07       	cpc	r19, r25
    2282:	59 f4       	brne	.+22     	; 0x229a <vCoRoutineSchedule+0xb0>
    2284:	e9 81       	ldd	r30, Y+1	; 0x01
    2286:	fa 81       	ldd	r31, Y+2	; 0x02
    2288:	01 80       	ldd	r0, Z+1	; 0x01
    228a:	f2 81       	ldd	r31, Z+2	; 0x02
    228c:	e0 2d       	mov	r30, r0
    228e:	82 81       	ldd	r24, Z+2	; 0x02
    2290:	93 81       	ldd	r25, Z+3	; 0x03
    2292:	e9 81       	ldd	r30, Y+1	; 0x01
    2294:	fa 81       	ldd	r31, Y+2	; 0x02
    2296:	92 83       	std	Z+2, r25	; 0x02
    2298:	81 83       	std	Z+1, r24	; 0x01
    229a:	e9 81       	ldd	r30, Y+1	; 0x01
    229c:	fa 81       	ldd	r31, Y+2	; 0x02
    229e:	01 80       	ldd	r0, Z+1	; 0x01
    22a0:	f2 81       	ldd	r31, Z+2	; 0x02
    22a2:	e0 2d       	mov	r30, r0
    22a4:	86 81       	ldd	r24, Z+6	; 0x06
    22a6:	97 81       	ldd	r25, Z+7	; 0x07
    22a8:	90 93 11 01 	sts	0x0111, r25
    22ac:	80 93 10 01 	sts	0x0110, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    22b0:	e0 91 10 01 	lds	r30, 0x0110
    22b4:	f0 91 11 01 	lds	r31, 0x0111
    22b8:	40 81       	ld	r20, Z
    22ba:	51 81       	ldd	r21, Z+1	; 0x01
    22bc:	80 91 10 01 	lds	r24, 0x0110
    22c0:	90 91 11 01 	lds	r25, 0x0111
    22c4:	e0 91 10 01 	lds	r30, 0x0110
    22c8:	f0 91 11 01 	lds	r31, 0x0111
    22cc:	27 89       	ldd	r18, Z+23	; 0x17
    22ce:	62 2f       	mov	r22, r18
    22d0:	fa 01       	movw	r30, r20
    22d2:	09 95       	icall

	return;
}
    22d4:	0f 90       	pop	r0
    22d6:	0f 90       	pop	r0
    22d8:	cf 91       	pop	r28
    22da:	df 91       	pop	r29
    22dc:	08 95       	ret

000022de <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    22de:	df 93       	push	r29
    22e0:	cf 93       	push	r28
    22e2:	0f 92       	push	r0
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    22e8:	19 82       	std	Y+1, r1	; 0x01
    22ea:	13 c0       	rjmp	.+38     	; 0x2312 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	28 2f       	mov	r18, r24
    22f0:	30 e0       	ldi	r19, 0x00	; 0
    22f2:	c9 01       	movw	r24, r18
    22f4:	88 0f       	add	r24, r24
    22f6:	99 1f       	adc	r25, r25
    22f8:	88 0f       	add	r24, r24
    22fa:	99 1f       	adc	r25, r25
    22fc:	88 0f       	add	r24, r24
    22fe:	99 1f       	adc	r25, r25
    2300:	82 0f       	add	r24, r18
    2302:	93 1f       	adc	r25, r19
    2304:	87 5e       	subi	r24, 0xE7	; 231
    2306:	9e 4f       	sbci	r25, 0xFE	; 254
    2308:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    230c:	89 81       	ldd	r24, Y+1	; 0x01
    230e:	8f 5f       	subi	r24, 0xFF	; 255
    2310:	89 83       	std	Y+1, r24	; 0x01
    2312:	89 81       	ldd	r24, Y+1	; 0x01
    2314:	82 30       	cpi	r24, 0x02	; 2
    2316:	50 f3       	brcs	.-44     	; 0x22ec <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2318:	8b e2       	ldi	r24, 0x2B	; 43
    231a:	91 e0       	ldi	r25, 0x01	; 1
    231c:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2320:	84 e3       	ldi	r24, 0x34	; 52
    2322:	91 e0       	ldi	r25, 0x01	; 1
    2324:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2328:	81 e4       	ldi	r24, 0x41	; 65
    232a:	91 e0       	ldi	r25, 0x01	; 1
    232c:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2330:	8b e2       	ldi	r24, 0x2B	; 43
    2332:	91 e0       	ldi	r25, 0x01	; 1
    2334:	90 93 3e 01 	sts	0x013E, r25
    2338:	80 93 3d 01 	sts	0x013D, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    233c:	84 e3       	ldi	r24, 0x34	; 52
    233e:	91 e0       	ldi	r25, 0x01	; 1
    2340:	90 93 40 01 	sts	0x0140, r25
    2344:	80 93 3f 01 	sts	0x013F, r24
}
    2348:	0f 90       	pop	r0
    234a:	cf 91       	pop	r28
    234c:	df 91       	pop	r29
    234e:	08 95       	ret

00002350 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2350:	df 93       	push	r29
    2352:	cf 93       	push	r28
    2354:	00 d0       	rcall	.+0      	; 0x2356 <xCoRoutineRemoveFromEventList+0x6>
    2356:	00 d0       	rcall	.+0      	; 0x2358 <xCoRoutineRemoveFromEventList+0x8>
    2358:	0f 92       	push	r0
    235a:	cd b7       	in	r28, 0x3d	; 61
    235c:	de b7       	in	r29, 0x3e	; 62
    235e:	9d 83       	std	Y+5, r25	; 0x05
    2360:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2362:	ec 81       	ldd	r30, Y+4	; 0x04
    2364:	fd 81       	ldd	r31, Y+5	; 0x05
    2366:	05 80       	ldd	r0, Z+5	; 0x05
    2368:	f6 81       	ldd	r31, Z+6	; 0x06
    236a:	e0 2d       	mov	r30, r0
    236c:	86 81       	ldd	r24, Z+6	; 0x06
    236e:	97 81       	ldd	r25, Z+7	; 0x07
    2370:	9b 83       	std	Y+3, r25	; 0x03
    2372:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2374:	8a 81       	ldd	r24, Y+2	; 0x02
    2376:	9b 81       	ldd	r25, Y+3	; 0x03
    2378:	0c 96       	adiw	r24, 0x0c	; 12
    237a:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
    2380:	9b 81       	ldd	r25, Y+3	; 0x03
    2382:	9c 01       	movw	r18, r24
    2384:	24 5f       	subi	r18, 0xF4	; 244
    2386:	3f 4f       	sbci	r19, 0xFF	; 255
    2388:	81 e4       	ldi	r24, 0x41	; 65
    238a:	91 e0       	ldi	r25, 0x01	; 1
    238c:	b9 01       	movw	r22, r18
    238e:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2392:	ea 81       	ldd	r30, Y+2	; 0x02
    2394:	fb 81       	ldd	r31, Y+3	; 0x03
    2396:	96 89       	ldd	r25, Z+22	; 0x16
    2398:	e0 91 10 01 	lds	r30, 0x0110
    239c:	f0 91 11 01 	lds	r31, 0x0111
    23a0:	86 89       	ldd	r24, Z+22	; 0x16
    23a2:	98 17       	cp	r25, r24
    23a4:	18 f0       	brcs	.+6      	; 0x23ac <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    23a6:	81 e0       	ldi	r24, 0x01	; 1
    23a8:	89 83       	std	Y+1, r24	; 0x01
    23aa:	01 c0       	rjmp	.+2      	; 0x23ae <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    23ac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
}
    23b0:	0f 90       	pop	r0
    23b2:	0f 90       	pop	r0
    23b4:	0f 90       	pop	r0
    23b6:	0f 90       	pop	r0
    23b8:	0f 90       	pop	r0
    23ba:	cf 91       	pop	r28
    23bc:	df 91       	pop	r29
    23be:	08 95       	ret

000023c0 <update_IMU>:
#include "STD_TYPES.h"
#include "MPU.h"
#include "quickmath.h"
//#include "Constants.h"
void update_IMU(parameters *ptr)
{
    23c0:	ef 92       	push	r14
    23c2:	ff 92       	push	r15
    23c4:	0f 93       	push	r16
    23c6:	1f 93       	push	r17
    23c8:	df 93       	push	r29
    23ca:	cf 93       	push	r28
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	c2 54       	subi	r28, 0x42	; 66
    23d2:	d0 40       	sbci	r29, 0x00	; 0
    23d4:	0f b6       	in	r0, 0x3f	; 63
    23d6:	f8 94       	cli
    23d8:	de bf       	out	0x3e, r29	; 62
    23da:	0f be       	out	0x3f, r0	; 63
    23dc:	cd bf       	out	0x3d, r28	; 61
    23de:	fe 01       	movw	r30, r28
    23e0:	ef 5b       	subi	r30, 0xBF	; 191
    23e2:	ff 4f       	sbci	r31, 0xFF	; 255
    23e4:	91 83       	std	Z+1, r25	; 0x01
    23e6:	80 83       	st	Z, r24
	bodyrate * gyro;
	accel * acc;
	Read_IMU_Values(acc, gyro);
    23e8:	8d ad       	ldd	r24, Y+61	; 0x3d
    23ea:	9e ad       	ldd	r25, Y+62	; 0x3e
    23ec:	fe 01       	movw	r30, r28
    23ee:	ff 96       	adiw	r30, 0x3f	; 63
    23f0:	20 81       	ld	r18, Z
    23f2:	31 81       	ldd	r19, Z+1	; 0x01
    23f4:	b9 01       	movw	r22, r18
    23f6:	0e 94 9e 0a 	call	0x153c	; 0x153c <Read_IMU_Values>
	f32 dt = 0.001; f32 taw=1;
    23fa:	8f e6       	ldi	r24, 0x6F	; 111
    23fc:	92 e1       	ldi	r25, 0x12	; 18
    23fe:	a3 e8       	ldi	r26, 0x83	; 131
    2400:	ba e3       	ldi	r27, 0x3A	; 58
    2402:	89 af       	std	Y+57, r24	; 0x39
    2404:	9a af       	std	Y+58, r25	; 0x3a
    2406:	ab af       	std	Y+59, r26	; 0x3b
    2408:	bc af       	std	Y+60, r27	; 0x3c
    240a:	80 e0       	ldi	r24, 0x00	; 0
    240c:	90 e0       	ldi	r25, 0x00	; 0
    240e:	a0 e8       	ldi	r26, 0x80	; 128
    2410:	bf e3       	ldi	r27, 0x3F	; 63
    2412:	8d ab       	std	Y+53, r24	; 0x35
    2414:	9e ab       	std	Y+54, r25	; 0x36
    2416:	af ab       	std	Y+55, r26	; 0x37
    2418:	b8 af       	std	Y+56, r27	; 0x38
		f32 R11 = 1;
    241a:	80 e0       	ldi	r24, 0x00	; 0
    241c:	90 e0       	ldi	r25, 0x00	; 0
    241e:	a0 e8       	ldi	r26, 0x80	; 128
    2420:	bf e3       	ldi	r27, 0x3F	; 63
    2422:	89 ab       	std	Y+49, r24	; 0x31
    2424:	9a ab       	std	Y+50, r25	; 0x32
    2426:	ab ab       	std	Y+51, r26	; 0x33
    2428:	bc ab       	std	Y+52, r27	; 0x34
		f32 R12 = sine(ptr->phi) * sine(ptr->theta) / cosine(ptr->theta);
    242a:	fe 01       	movw	r30, r28
    242c:	ef 5b       	subi	r30, 0xBF	; 191
    242e:	ff 4f       	sbci	r31, 0xFF	; 255
    2430:	01 90       	ld	r0, Z+
    2432:	f0 81       	ld	r31, Z
    2434:	e0 2d       	mov	r30, r0
    2436:	84 a1       	ldd	r24, Z+36	; 0x24
    2438:	95 a1       	ldd	r25, Z+37	; 0x25
    243a:	a6 a1       	ldd	r26, Z+38	; 0x26
    243c:	b7 a1       	ldd	r27, Z+39	; 0x27
    243e:	bc 01       	movw	r22, r24
    2440:	cd 01       	movw	r24, r26
    2442:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
    2446:	7b 01       	movw	r14, r22
    2448:	8c 01       	movw	r16, r24
    244a:	fe 01       	movw	r30, r28
    244c:	ef 5b       	subi	r30, 0xBF	; 191
    244e:	ff 4f       	sbci	r31, 0xFF	; 255
    2450:	01 90       	ld	r0, Z+
    2452:	f0 81       	ld	r31, Z
    2454:	e0 2d       	mov	r30, r0
    2456:	80 a5       	ldd	r24, Z+40	; 0x28
    2458:	91 a5       	ldd	r25, Z+41	; 0x29
    245a:	a2 a5       	ldd	r26, Z+42	; 0x2a
    245c:	b3 a5       	ldd	r27, Z+43	; 0x2b
    245e:	bc 01       	movw	r22, r24
    2460:	cd 01       	movw	r24, r26
    2462:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
    2466:	9b 01       	movw	r18, r22
    2468:	ac 01       	movw	r20, r24
    246a:	c8 01       	movw	r24, r16
    246c:	b7 01       	movw	r22, r14
    246e:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2472:	dc 01       	movw	r26, r24
    2474:	cb 01       	movw	r24, r22
    2476:	7c 01       	movw	r14, r24
    2478:	8d 01       	movw	r16, r26
    247a:	fe 01       	movw	r30, r28
    247c:	ef 5b       	subi	r30, 0xBF	; 191
    247e:	ff 4f       	sbci	r31, 0xFF	; 255
    2480:	01 90       	ld	r0, Z+
    2482:	f0 81       	ld	r31, Z
    2484:	e0 2d       	mov	r30, r0
    2486:	80 a5       	ldd	r24, Z+40	; 0x28
    2488:	91 a5       	ldd	r25, Z+41	; 0x29
    248a:	a2 a5       	ldd	r26, Z+42	; 0x2a
    248c:	b3 a5       	ldd	r27, Z+43	; 0x2b
    248e:	bc 01       	movw	r22, r24
    2490:	cd 01       	movw	r24, r26
    2492:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    2496:	9b 01       	movw	r18, r22
    2498:	ac 01       	movw	r20, r24
    249a:	c8 01       	movw	r24, r16
    249c:	b7 01       	movw	r22, r14
    249e:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    24a2:	dc 01       	movw	r26, r24
    24a4:	cb 01       	movw	r24, r22
    24a6:	8d a7       	std	Y+45, r24	; 0x2d
    24a8:	9e a7       	std	Y+46, r25	; 0x2e
    24aa:	af a7       	std	Y+47, r26	; 0x2f
    24ac:	b8 ab       	std	Y+48, r27	; 0x30
		f32 R13= cosine(ptr->phi) * sine(ptr->theta) / cosine(ptr->theta);
    24ae:	fe 01       	movw	r30, r28
    24b0:	ef 5b       	subi	r30, 0xBF	; 191
    24b2:	ff 4f       	sbci	r31, 0xFF	; 255
    24b4:	01 90       	ld	r0, Z+
    24b6:	f0 81       	ld	r31, Z
    24b8:	e0 2d       	mov	r30, r0
    24ba:	84 a1       	ldd	r24, Z+36	; 0x24
    24bc:	95 a1       	ldd	r25, Z+37	; 0x25
    24be:	a6 a1       	ldd	r26, Z+38	; 0x26
    24c0:	b7 a1       	ldd	r27, Z+39	; 0x27
    24c2:	bc 01       	movw	r22, r24
    24c4:	cd 01       	movw	r24, r26
    24c6:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    24ca:	7b 01       	movw	r14, r22
    24cc:	8c 01       	movw	r16, r24
    24ce:	fe 01       	movw	r30, r28
    24d0:	ef 5b       	subi	r30, 0xBF	; 191
    24d2:	ff 4f       	sbci	r31, 0xFF	; 255
    24d4:	01 90       	ld	r0, Z+
    24d6:	f0 81       	ld	r31, Z
    24d8:	e0 2d       	mov	r30, r0
    24da:	80 a5       	ldd	r24, Z+40	; 0x28
    24dc:	91 a5       	ldd	r25, Z+41	; 0x29
    24de:	a2 a5       	ldd	r26, Z+42	; 0x2a
    24e0:	b3 a5       	ldd	r27, Z+43	; 0x2b
    24e2:	bc 01       	movw	r22, r24
    24e4:	cd 01       	movw	r24, r26
    24e6:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
    24ea:	9b 01       	movw	r18, r22
    24ec:	ac 01       	movw	r20, r24
    24ee:	c8 01       	movw	r24, r16
    24f0:	b7 01       	movw	r22, r14
    24f2:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    24f6:	dc 01       	movw	r26, r24
    24f8:	cb 01       	movw	r24, r22
    24fa:	7c 01       	movw	r14, r24
    24fc:	8d 01       	movw	r16, r26
    24fe:	fe 01       	movw	r30, r28
    2500:	ef 5b       	subi	r30, 0xBF	; 191
    2502:	ff 4f       	sbci	r31, 0xFF	; 255
    2504:	01 90       	ld	r0, Z+
    2506:	f0 81       	ld	r31, Z
    2508:	e0 2d       	mov	r30, r0
    250a:	80 a5       	ldd	r24, Z+40	; 0x28
    250c:	91 a5       	ldd	r25, Z+41	; 0x29
    250e:	a2 a5       	ldd	r26, Z+42	; 0x2a
    2510:	b3 a5       	ldd	r27, Z+43	; 0x2b
    2512:	bc 01       	movw	r22, r24
    2514:	cd 01       	movw	r24, r26
    2516:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    251a:	9b 01       	movw	r18, r22
    251c:	ac 01       	movw	r20, r24
    251e:	c8 01       	movw	r24, r16
    2520:	b7 01       	movw	r22, r14
    2522:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2526:	dc 01       	movw	r26, r24
    2528:	cb 01       	movw	r24, r22
    252a:	89 a7       	std	Y+41, r24	; 0x29
    252c:	9a a7       	std	Y+42, r25	; 0x2a
    252e:	ab a7       	std	Y+43, r26	; 0x2b
    2530:	bc a7       	std	Y+44, r27	; 0x2c
		f32 R21 = 0;
    2532:	80 e0       	ldi	r24, 0x00	; 0
    2534:	90 e0       	ldi	r25, 0x00	; 0
    2536:	a0 e0       	ldi	r26, 0x00	; 0
    2538:	b0 e0       	ldi	r27, 0x00	; 0
    253a:	8d a3       	std	Y+37, r24	; 0x25
    253c:	9e a3       	std	Y+38, r25	; 0x26
    253e:	af a3       	std	Y+39, r26	; 0x27
    2540:	b8 a7       	std	Y+40, r27	; 0x28
		f32 R22 = cosine(ptr->phi);
    2542:	fe 01       	movw	r30, r28
    2544:	ef 5b       	subi	r30, 0xBF	; 191
    2546:	ff 4f       	sbci	r31, 0xFF	; 255
    2548:	01 90       	ld	r0, Z+
    254a:	f0 81       	ld	r31, Z
    254c:	e0 2d       	mov	r30, r0
    254e:	84 a1       	ldd	r24, Z+36	; 0x24
    2550:	95 a1       	ldd	r25, Z+37	; 0x25
    2552:	a6 a1       	ldd	r26, Z+38	; 0x26
    2554:	b7 a1       	ldd	r27, Z+39	; 0x27
    2556:	bc 01       	movw	r22, r24
    2558:	cd 01       	movw	r24, r26
    255a:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    255e:	dc 01       	movw	r26, r24
    2560:	cb 01       	movw	r24, r22
    2562:	89 a3       	std	Y+33, r24	; 0x21
    2564:	9a a3       	std	Y+34, r25	; 0x22
    2566:	ab a3       	std	Y+35, r26	; 0x23
    2568:	bc a3       	std	Y+36, r27	; 0x24
		f32 R23= -sine(ptr->phi);
    256a:	fe 01       	movw	r30, r28
    256c:	ef 5b       	subi	r30, 0xBF	; 191
    256e:	ff 4f       	sbci	r31, 0xFF	; 255
    2570:	01 90       	ld	r0, Z+
    2572:	f0 81       	ld	r31, Z
    2574:	e0 2d       	mov	r30, r0
    2576:	84 a1       	ldd	r24, Z+36	; 0x24
    2578:	95 a1       	ldd	r25, Z+37	; 0x25
    257a:	a6 a1       	ldd	r26, Z+38	; 0x26
    257c:	b7 a1       	ldd	r27, Z+39	; 0x27
    257e:	bc 01       	movw	r22, r24
    2580:	cd 01       	movw	r24, r26
    2582:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
    2586:	dc 01       	movw	r26, r24
    2588:	cb 01       	movw	r24, r22
    258a:	b0 58       	subi	r27, 0x80	; 128
    258c:	8d 8f       	std	Y+29, r24	; 0x1d
    258e:	9e 8f       	std	Y+30, r25	; 0x1e
    2590:	af 8f       	std	Y+31, r26	; 0x1f
    2592:	b8 a3       	std	Y+32, r27	; 0x20
		f32 R31 = 0;
    2594:	80 e0       	ldi	r24, 0x00	; 0
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	a0 e0       	ldi	r26, 0x00	; 0
    259a:	b0 e0       	ldi	r27, 0x00	; 0
    259c:	89 8f       	std	Y+25, r24	; 0x19
    259e:	9a 8f       	std	Y+26, r25	; 0x1a
    25a0:	ab 8f       	std	Y+27, r26	; 0x1b
    25a2:	bc 8f       	std	Y+28, r27	; 0x1c
		f32 R32 = sine(ptr->phi) / cosine(ptr->theta);
    25a4:	fe 01       	movw	r30, r28
    25a6:	ef 5b       	subi	r30, 0xBF	; 191
    25a8:	ff 4f       	sbci	r31, 0xFF	; 255
    25aa:	01 90       	ld	r0, Z+
    25ac:	f0 81       	ld	r31, Z
    25ae:	e0 2d       	mov	r30, r0
    25b0:	84 a1       	ldd	r24, Z+36	; 0x24
    25b2:	95 a1       	ldd	r25, Z+37	; 0x25
    25b4:	a6 a1       	ldd	r26, Z+38	; 0x26
    25b6:	b7 a1       	ldd	r27, Z+39	; 0x27
    25b8:	bc 01       	movw	r22, r24
    25ba:	cd 01       	movw	r24, r26
    25bc:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <sine>
    25c0:	7b 01       	movw	r14, r22
    25c2:	8c 01       	movw	r16, r24
    25c4:	fe 01       	movw	r30, r28
    25c6:	ef 5b       	subi	r30, 0xBF	; 191
    25c8:	ff 4f       	sbci	r31, 0xFF	; 255
    25ca:	01 90       	ld	r0, Z+
    25cc:	f0 81       	ld	r31, Z
    25ce:	e0 2d       	mov	r30, r0
    25d0:	80 a5       	ldd	r24, Z+40	; 0x28
    25d2:	91 a5       	ldd	r25, Z+41	; 0x29
    25d4:	a2 a5       	ldd	r26, Z+42	; 0x2a
    25d6:	b3 a5       	ldd	r27, Z+43	; 0x2b
    25d8:	bc 01       	movw	r22, r24
    25da:	cd 01       	movw	r24, r26
    25dc:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    25e0:	9b 01       	movw	r18, r22
    25e2:	ac 01       	movw	r20, r24
    25e4:	c8 01       	movw	r24, r16
    25e6:	b7 01       	movw	r22, r14
    25e8:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    25ec:	dc 01       	movw	r26, r24
    25ee:	cb 01       	movw	r24, r22
    25f0:	8d 8b       	std	Y+21, r24	; 0x15
    25f2:	9e 8b       	std	Y+22, r25	; 0x16
    25f4:	af 8b       	std	Y+23, r26	; 0x17
    25f6:	b8 8f       	std	Y+24, r27	; 0x18
		f32 R33 = cosine(ptr->phi) / cosine(ptr->theta);
    25f8:	fe 01       	movw	r30, r28
    25fa:	ef 5b       	subi	r30, 0xBF	; 191
    25fc:	ff 4f       	sbci	r31, 0xFF	; 255
    25fe:	01 90       	ld	r0, Z+
    2600:	f0 81       	ld	r31, Z
    2602:	e0 2d       	mov	r30, r0
    2604:	84 a1       	ldd	r24, Z+36	; 0x24
    2606:	95 a1       	ldd	r25, Z+37	; 0x25
    2608:	a6 a1       	ldd	r26, Z+38	; 0x26
    260a:	b7 a1       	ldd	r27, Z+39	; 0x27
    260c:	bc 01       	movw	r22, r24
    260e:	cd 01       	movw	r24, r26
    2610:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    2614:	7b 01       	movw	r14, r22
    2616:	8c 01       	movw	r16, r24
    2618:	fe 01       	movw	r30, r28
    261a:	ef 5b       	subi	r30, 0xBF	; 191
    261c:	ff 4f       	sbci	r31, 0xFF	; 255
    261e:	01 90       	ld	r0, Z+
    2620:	f0 81       	ld	r31, Z
    2622:	e0 2d       	mov	r30, r0
    2624:	80 a5       	ldd	r24, Z+40	; 0x28
    2626:	91 a5       	ldd	r25, Z+41	; 0x29
    2628:	a2 a5       	ldd	r26, Z+42	; 0x2a
    262a:	b3 a5       	ldd	r27, Z+43	; 0x2b
    262c:	bc 01       	movw	r22, r24
    262e:	cd 01       	movw	r24, r26
    2630:	0e 94 d5 22 	call	0x45aa	; 0x45aa <cosine>
    2634:	9b 01       	movw	r18, r22
    2636:	ac 01       	movw	r20, r24
    2638:	c8 01       	movw	r24, r16
    263a:	b7 01       	movw	r22, r14
    263c:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2640:	dc 01       	movw	r26, r24
    2642:	cb 01       	movw	r24, r22
    2644:	89 8b       	std	Y+17, r24	; 0x11
    2646:	9a 8b       	std	Y+18, r25	; 0x12
    2648:	ab 8b       	std	Y+19, r26	; 0x13
    264a:	bc 8b       	std	Y+20, r27	; 0x14
		ptr->phi_dot = ptr->p + ptr->q * R12 + ptr->r * R13;
    264c:	fe 01       	movw	r30, r28
    264e:	ef 5b       	subi	r30, 0xBF	; 191
    2650:	ff 4f       	sbci	r31, 0xFF	; 255
    2652:	01 90       	ld	r0, Z+
    2654:	f0 81       	ld	r31, Z
    2656:	e0 2d       	mov	r30, r0
    2658:	e4 ac       	ldd	r14, Z+60	; 0x3c
    265a:	f5 ac       	ldd	r15, Z+61	; 0x3d
    265c:	06 ad       	ldd	r16, Z+62	; 0x3e
    265e:	17 ad       	ldd	r17, Z+63	; 0x3f
    2660:	fe 01       	movw	r30, r28
    2662:	ef 5b       	subi	r30, 0xBF	; 191
    2664:	ff 4f       	sbci	r31, 0xFF	; 255
    2666:	80 81       	ld	r24, Z
    2668:	91 81       	ldd	r25, Z+1	; 0x01
    266a:	fc 01       	movw	r30, r24
    266c:	e0 5c       	subi	r30, 0xC0	; 192
    266e:	ff 4f       	sbci	r31, 0xFF	; 255
    2670:	80 81       	ld	r24, Z
    2672:	91 81       	ldd	r25, Z+1	; 0x01
    2674:	a2 81       	ldd	r26, Z+2	; 0x02
    2676:	b3 81       	ldd	r27, Z+3	; 0x03
    2678:	bc 01       	movw	r22, r24
    267a:	cd 01       	movw	r24, r26
    267c:	2d a5       	ldd	r18, Y+45	; 0x2d
    267e:	3e a5       	ldd	r19, Y+46	; 0x2e
    2680:	4f a5       	ldd	r20, Y+47	; 0x2f
    2682:	58 a9       	ldd	r21, Y+48	; 0x30
    2684:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2688:	dc 01       	movw	r26, r24
    268a:	cb 01       	movw	r24, r22
    268c:	9c 01       	movw	r18, r24
    268e:	ad 01       	movw	r20, r26
    2690:	c8 01       	movw	r24, r16
    2692:	b7 01       	movw	r22, r14
    2694:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2698:	dc 01       	movw	r26, r24
    269a:	cb 01       	movw	r24, r22
    269c:	7c 01       	movw	r14, r24
    269e:	8d 01       	movw	r16, r26
    26a0:	fe 01       	movw	r30, r28
    26a2:	ef 5b       	subi	r30, 0xBF	; 191
    26a4:	ff 4f       	sbci	r31, 0xFF	; 255
    26a6:	80 81       	ld	r24, Z
    26a8:	91 81       	ldd	r25, Z+1	; 0x01
    26aa:	fc 01       	movw	r30, r24
    26ac:	ec 5b       	subi	r30, 0xBC	; 188
    26ae:	ff 4f       	sbci	r31, 0xFF	; 255
    26b0:	80 81       	ld	r24, Z
    26b2:	91 81       	ldd	r25, Z+1	; 0x01
    26b4:	a2 81       	ldd	r26, Z+2	; 0x02
    26b6:	b3 81       	ldd	r27, Z+3	; 0x03
    26b8:	bc 01       	movw	r22, r24
    26ba:	cd 01       	movw	r24, r26
    26bc:	29 a5       	ldd	r18, Y+41	; 0x29
    26be:	3a a5       	ldd	r19, Y+42	; 0x2a
    26c0:	4b a5       	ldd	r20, Y+43	; 0x2b
    26c2:	5c a5       	ldd	r21, Y+44	; 0x2c
    26c4:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    26c8:	dc 01       	movw	r26, r24
    26ca:	cb 01       	movw	r24, r22
    26cc:	9c 01       	movw	r18, r24
    26ce:	ad 01       	movw	r20, r26
    26d0:	c8 01       	movw	r24, r16
    26d2:	b7 01       	movw	r22, r14
    26d4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    26d8:	dc 01       	movw	r26, r24
    26da:	cb 01       	movw	r24, r22
    26dc:	fe 01       	movw	r30, r28
    26de:	ef 5b       	subi	r30, 0xBF	; 191
    26e0:	ff 4f       	sbci	r31, 0xFF	; 255
    26e2:	01 90       	ld	r0, Z+
    26e4:	f0 81       	ld	r31, Z
    26e6:	e0 2d       	mov	r30, r0
    26e8:	80 ab       	std	Z+48, r24	; 0x30
    26ea:	91 ab       	std	Z+49, r25	; 0x31
    26ec:	a2 ab       	std	Z+50, r26	; 0x32
    26ee:	b3 ab       	std	Z+51, r27	; 0x33
	    ptr->theta_dot = ptr->q * R22 - ptr->r * R23;
    26f0:	fe 01       	movw	r30, r28
    26f2:	ef 5b       	subi	r30, 0xBF	; 191
    26f4:	ff 4f       	sbci	r31, 0xFF	; 255
    26f6:	80 81       	ld	r24, Z
    26f8:	91 81       	ldd	r25, Z+1	; 0x01
    26fa:	fc 01       	movw	r30, r24
    26fc:	e0 5c       	subi	r30, 0xC0	; 192
    26fe:	ff 4f       	sbci	r31, 0xFF	; 255
    2700:	80 81       	ld	r24, Z
    2702:	91 81       	ldd	r25, Z+1	; 0x01
    2704:	a2 81       	ldd	r26, Z+2	; 0x02
    2706:	b3 81       	ldd	r27, Z+3	; 0x03
    2708:	bc 01       	movw	r22, r24
    270a:	cd 01       	movw	r24, r26
    270c:	29 a1       	ldd	r18, Y+33	; 0x21
    270e:	3a a1       	ldd	r19, Y+34	; 0x22
    2710:	4b a1       	ldd	r20, Y+35	; 0x23
    2712:	5c a1       	ldd	r21, Y+36	; 0x24
    2714:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2718:	dc 01       	movw	r26, r24
    271a:	cb 01       	movw	r24, r22
    271c:	7c 01       	movw	r14, r24
    271e:	8d 01       	movw	r16, r26
    2720:	fe 01       	movw	r30, r28
    2722:	ef 5b       	subi	r30, 0xBF	; 191
    2724:	ff 4f       	sbci	r31, 0xFF	; 255
    2726:	80 81       	ld	r24, Z
    2728:	91 81       	ldd	r25, Z+1	; 0x01
    272a:	fc 01       	movw	r30, r24
    272c:	ec 5b       	subi	r30, 0xBC	; 188
    272e:	ff 4f       	sbci	r31, 0xFF	; 255
    2730:	80 81       	ld	r24, Z
    2732:	91 81       	ldd	r25, Z+1	; 0x01
    2734:	a2 81       	ldd	r26, Z+2	; 0x02
    2736:	b3 81       	ldd	r27, Z+3	; 0x03
    2738:	bc 01       	movw	r22, r24
    273a:	cd 01       	movw	r24, r26
    273c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    273e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2740:	4f 8d       	ldd	r20, Y+31	; 0x1f
    2742:	58 a1       	ldd	r21, Y+32	; 0x20
    2744:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2748:	dc 01       	movw	r26, r24
    274a:	cb 01       	movw	r24, r22
    274c:	9c 01       	movw	r18, r24
    274e:	ad 01       	movw	r20, r26
    2750:	c8 01       	movw	r24, r16
    2752:	b7 01       	movw	r22, r14
    2754:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    2758:	dc 01       	movw	r26, r24
    275a:	cb 01       	movw	r24, r22
    275c:	fe 01       	movw	r30, r28
    275e:	ef 5b       	subi	r30, 0xBF	; 191
    2760:	ff 4f       	sbci	r31, 0xFF	; 255
    2762:	01 90       	ld	r0, Z+
    2764:	f0 81       	ld	r31, Z
    2766:	e0 2d       	mov	r30, r0
    2768:	84 ab       	std	Z+52, r24	; 0x34
    276a:	95 ab       	std	Z+53, r25	; 0x35
    276c:	a6 ab       	std	Z+54, r26	; 0x36
    276e:	b7 ab       	std	Z+55, r27	; 0x37
	    ptr->psi_dot = ptr-> q * R32 + ptr->r * R33;
    2770:	fe 01       	movw	r30, r28
    2772:	ef 5b       	subi	r30, 0xBF	; 191
    2774:	ff 4f       	sbci	r31, 0xFF	; 255
    2776:	80 81       	ld	r24, Z
    2778:	91 81       	ldd	r25, Z+1	; 0x01
    277a:	fc 01       	movw	r30, r24
    277c:	e0 5c       	subi	r30, 0xC0	; 192
    277e:	ff 4f       	sbci	r31, 0xFF	; 255
    2780:	80 81       	ld	r24, Z
    2782:	91 81       	ldd	r25, Z+1	; 0x01
    2784:	a2 81       	ldd	r26, Z+2	; 0x02
    2786:	b3 81       	ldd	r27, Z+3	; 0x03
    2788:	bc 01       	movw	r22, r24
    278a:	cd 01       	movw	r24, r26
    278c:	2d 89       	ldd	r18, Y+21	; 0x15
    278e:	3e 89       	ldd	r19, Y+22	; 0x16
    2790:	4f 89       	ldd	r20, Y+23	; 0x17
    2792:	58 8d       	ldd	r21, Y+24	; 0x18
    2794:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2798:	dc 01       	movw	r26, r24
    279a:	cb 01       	movw	r24, r22
    279c:	7c 01       	movw	r14, r24
    279e:	8d 01       	movw	r16, r26
    27a0:	fe 01       	movw	r30, r28
    27a2:	ef 5b       	subi	r30, 0xBF	; 191
    27a4:	ff 4f       	sbci	r31, 0xFF	; 255
    27a6:	80 81       	ld	r24, Z
    27a8:	91 81       	ldd	r25, Z+1	; 0x01
    27aa:	fc 01       	movw	r30, r24
    27ac:	ec 5b       	subi	r30, 0xBC	; 188
    27ae:	ff 4f       	sbci	r31, 0xFF	; 255
    27b0:	80 81       	ld	r24, Z
    27b2:	91 81       	ldd	r25, Z+1	; 0x01
    27b4:	a2 81       	ldd	r26, Z+2	; 0x02
    27b6:	b3 81       	ldd	r27, Z+3	; 0x03
    27b8:	bc 01       	movw	r22, r24
    27ba:	cd 01       	movw	r24, r26
    27bc:	29 89       	ldd	r18, Y+17	; 0x11
    27be:	3a 89       	ldd	r19, Y+18	; 0x12
    27c0:	4b 89       	ldd	r20, Y+19	; 0x13
    27c2:	5c 89       	ldd	r21, Y+20	; 0x14
    27c4:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    27c8:	dc 01       	movw	r26, r24
    27ca:	cb 01       	movw	r24, r22
    27cc:	9c 01       	movw	r18, r24
    27ce:	ad 01       	movw	r20, r26
    27d0:	c8 01       	movw	r24, r16
    27d2:	b7 01       	movw	r22, r14
    27d4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    27d8:	dc 01       	movw	r26, r24
    27da:	cb 01       	movw	r24, r22
    27dc:	fe 01       	movw	r30, r28
    27de:	ef 5b       	subi	r30, 0xBF	; 191
    27e0:	ff 4f       	sbci	r31, 0xFF	; 255
    27e2:	01 90       	ld	r0, Z+
    27e4:	f0 81       	ld	r31, Z
    27e6:	e0 2d       	mov	r30, r0
    27e8:	80 af       	std	Z+56, r24	; 0x38
    27ea:	91 af       	std	Z+57, r25	; 0x39
    27ec:	a2 af       	std	Z+58, r26	; 0x3a
    27ee:	b3 af       	std	Z+59, r27	; 0x3b
	    f32 predictedphi = ptr->phi + ptr->phi_dot * dt;
    27f0:	fe 01       	movw	r30, r28
    27f2:	ef 5b       	subi	r30, 0xBF	; 191
    27f4:	ff 4f       	sbci	r31, 0xFF	; 255
    27f6:	01 90       	ld	r0, Z+
    27f8:	f0 81       	ld	r31, Z
    27fa:	e0 2d       	mov	r30, r0
    27fc:	e4 a0       	ldd	r14, Z+36	; 0x24
    27fe:	f5 a0       	ldd	r15, Z+37	; 0x25
    2800:	06 a1       	ldd	r16, Z+38	; 0x26
    2802:	17 a1       	ldd	r17, Z+39	; 0x27
    2804:	fe 01       	movw	r30, r28
    2806:	ef 5b       	subi	r30, 0xBF	; 191
    2808:	ff 4f       	sbci	r31, 0xFF	; 255
    280a:	01 90       	ld	r0, Z+
    280c:	f0 81       	ld	r31, Z
    280e:	e0 2d       	mov	r30, r0
    2810:	80 a9       	ldd	r24, Z+48	; 0x30
    2812:	91 a9       	ldd	r25, Z+49	; 0x31
    2814:	a2 a9       	ldd	r26, Z+50	; 0x32
    2816:	b3 a9       	ldd	r27, Z+51	; 0x33
    2818:	bc 01       	movw	r22, r24
    281a:	cd 01       	movw	r24, r26
    281c:	29 ad       	ldd	r18, Y+57	; 0x39
    281e:	3a ad       	ldd	r19, Y+58	; 0x3a
    2820:	4b ad       	ldd	r20, Y+59	; 0x3b
    2822:	5c ad       	ldd	r21, Y+60	; 0x3c
    2824:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2828:	dc 01       	movw	r26, r24
    282a:	cb 01       	movw	r24, r22
    282c:	9c 01       	movw	r18, r24
    282e:	ad 01       	movw	r20, r26
    2830:	c8 01       	movw	r24, r16
    2832:	b7 01       	movw	r22, r14
    2834:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2838:	dc 01       	movw	r26, r24
    283a:	cb 01       	movw	r24, r22
    283c:	8d 87       	std	Y+13, r24	; 0x0d
    283e:	9e 87       	std	Y+14, r25	; 0x0e
    2840:	af 87       	std	Y+15, r26	; 0x0f
    2842:	b8 8b       	std	Y+16, r27	; 0x10
	    f32 predictedtheta = ptr->theta + ptr->theta_dot * dt;
    2844:	fe 01       	movw	r30, r28
    2846:	ef 5b       	subi	r30, 0xBF	; 191
    2848:	ff 4f       	sbci	r31, 0xFF	; 255
    284a:	01 90       	ld	r0, Z+
    284c:	f0 81       	ld	r31, Z
    284e:	e0 2d       	mov	r30, r0
    2850:	e0 a4       	ldd	r14, Z+40	; 0x28
    2852:	f1 a4       	ldd	r15, Z+41	; 0x29
    2854:	02 a5       	ldd	r16, Z+42	; 0x2a
    2856:	13 a5       	ldd	r17, Z+43	; 0x2b
    2858:	fe 01       	movw	r30, r28
    285a:	ef 5b       	subi	r30, 0xBF	; 191
    285c:	ff 4f       	sbci	r31, 0xFF	; 255
    285e:	01 90       	ld	r0, Z+
    2860:	f0 81       	ld	r31, Z
    2862:	e0 2d       	mov	r30, r0
    2864:	84 a9       	ldd	r24, Z+52	; 0x34
    2866:	95 a9       	ldd	r25, Z+53	; 0x35
    2868:	a6 a9       	ldd	r26, Z+54	; 0x36
    286a:	b7 a9       	ldd	r27, Z+55	; 0x37
    286c:	bc 01       	movw	r22, r24
    286e:	cd 01       	movw	r24, r26
    2870:	29 ad       	ldd	r18, Y+57	; 0x39
    2872:	3a ad       	ldd	r19, Y+58	; 0x3a
    2874:	4b ad       	ldd	r20, Y+59	; 0x3b
    2876:	5c ad       	ldd	r21, Y+60	; 0x3c
    2878:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    287c:	dc 01       	movw	r26, r24
    287e:	cb 01       	movw	r24, r22
    2880:	9c 01       	movw	r18, r24
    2882:	ad 01       	movw	r20, r26
    2884:	c8 01       	movw	r24, r16
    2886:	b7 01       	movw	r22, r14
    2888:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    288c:	dc 01       	movw	r26, r24
    288e:	cb 01       	movw	r24, r22
    2890:	89 87       	std	Y+9, r24	; 0x09
    2892:	9a 87       	std	Y+10, r25	; 0x0a
    2894:	ab 87       	std	Y+11, r26	; 0x0b
    2896:	bc 87       	std	Y+12, r27	; 0x0c
	    ptr->psi += ptr->psi_dot * dt;
    2898:	fe 01       	movw	r30, r28
    289a:	ef 5b       	subi	r30, 0xBF	; 191
    289c:	ff 4f       	sbci	r31, 0xFF	; 255
    289e:	01 90       	ld	r0, Z+
    28a0:	f0 81       	ld	r31, Z
    28a2:	e0 2d       	mov	r30, r0
    28a4:	e4 a4       	ldd	r14, Z+44	; 0x2c
    28a6:	f5 a4       	ldd	r15, Z+45	; 0x2d
    28a8:	06 a5       	ldd	r16, Z+46	; 0x2e
    28aa:	17 a5       	ldd	r17, Z+47	; 0x2f
    28ac:	fe 01       	movw	r30, r28
    28ae:	ef 5b       	subi	r30, 0xBF	; 191
    28b0:	ff 4f       	sbci	r31, 0xFF	; 255
    28b2:	01 90       	ld	r0, Z+
    28b4:	f0 81       	ld	r31, Z
    28b6:	e0 2d       	mov	r30, r0
    28b8:	80 ad       	ldd	r24, Z+56	; 0x38
    28ba:	91 ad       	ldd	r25, Z+57	; 0x39
    28bc:	a2 ad       	ldd	r26, Z+58	; 0x3a
    28be:	b3 ad       	ldd	r27, Z+59	; 0x3b
    28c0:	bc 01       	movw	r22, r24
    28c2:	cd 01       	movw	r24, r26
    28c4:	29 ad       	ldd	r18, Y+57	; 0x39
    28c6:	3a ad       	ldd	r19, Y+58	; 0x3a
    28c8:	4b ad       	ldd	r20, Y+59	; 0x3b
    28ca:	5c ad       	ldd	r21, Y+60	; 0x3c
    28cc:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    28d0:	dc 01       	movw	r26, r24
    28d2:	cb 01       	movw	r24, r22
    28d4:	9c 01       	movw	r18, r24
    28d6:	ad 01       	movw	r20, r26
    28d8:	c8 01       	movw	r24, r16
    28da:	b7 01       	movw	r22, r14
    28dc:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    28e0:	dc 01       	movw	r26, r24
    28e2:	cb 01       	movw	r24, r22
    28e4:	fe 01       	movw	r30, r28
    28e6:	ef 5b       	subi	r30, 0xBF	; 191
    28e8:	ff 4f       	sbci	r31, 0xFF	; 255
    28ea:	01 90       	ld	r0, Z+
    28ec:	f0 81       	ld	r31, Z
    28ee:	e0 2d       	mov	r30, r0
    28f0:	84 a7       	std	Z+44, r24	; 0x2c
    28f2:	95 a7       	std	Z+45, r25	; 0x2d
    28f4:	a6 a7       	std	Z+46, r26	; 0x2e
    28f6:	b7 a7       	std	Z+47, r27	; 0x2f
	    if(ptr->psi > PI)
    28f8:	fe 01       	movw	r30, r28
    28fa:	ef 5b       	subi	r30, 0xBF	; 191
    28fc:	ff 4f       	sbci	r31, 0xFF	; 255
    28fe:	01 90       	ld	r0, Z+
    2900:	f0 81       	ld	r31, Z
    2902:	e0 2d       	mov	r30, r0
    2904:	84 a5       	ldd	r24, Z+44	; 0x2c
    2906:	95 a5       	ldd	r25, Z+45	; 0x2d
    2908:	a6 a5       	ldd	r26, Z+46	; 0x2e
    290a:	b7 a5       	ldd	r27, Z+47	; 0x2f
    290c:	bc 01       	movw	r22, r24
    290e:	cd 01       	movw	r24, r26
    2910:	20 ed       	ldi	r18, 0xD0	; 208
    2912:	3f e0       	ldi	r19, 0x0F	; 15
    2914:	49 e4       	ldi	r20, 0x49	; 73
    2916:	50 e4       	ldi	r21, 0x40	; 64
    2918:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <__gesf2>
    291c:	18 16       	cp	r1, r24
    291e:	f4 f4       	brge	.+60     	; 0x295c <update_IMU+0x59c>
	    	ptr->psi -= 2*PI;
    2920:	fe 01       	movw	r30, r28
    2922:	ef 5b       	subi	r30, 0xBF	; 191
    2924:	ff 4f       	sbci	r31, 0xFF	; 255
    2926:	01 90       	ld	r0, Z+
    2928:	f0 81       	ld	r31, Z
    292a:	e0 2d       	mov	r30, r0
    292c:	84 a5       	ldd	r24, Z+44	; 0x2c
    292e:	95 a5       	ldd	r25, Z+45	; 0x2d
    2930:	a6 a5       	ldd	r26, Z+46	; 0x2e
    2932:	b7 a5       	ldd	r27, Z+47	; 0x2f
    2934:	bc 01       	movw	r22, r24
    2936:	cd 01       	movw	r24, r26
    2938:	20 ed       	ldi	r18, 0xD0	; 208
    293a:	3f e0       	ldi	r19, 0x0F	; 15
    293c:	49 ec       	ldi	r20, 0xC9	; 201
    293e:	50 e4       	ldi	r21, 0x40	; 64
    2940:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    2944:	dc 01       	movw	r26, r24
    2946:	cb 01       	movw	r24, r22
    2948:	fe 01       	movw	r30, r28
    294a:	ef 5b       	subi	r30, 0xBF	; 191
    294c:	ff 4f       	sbci	r31, 0xFF	; 255
    294e:	01 90       	ld	r0, Z+
    2950:	f0 81       	ld	r31, Z
    2952:	e0 2d       	mov	r30, r0
    2954:	84 a7       	std	Z+44, r24	; 0x2c
    2956:	95 a7       	std	Z+45, r25	; 0x2d
    2958:	a6 a7       	std	Z+46, r26	; 0x2e
    295a:	b7 a7       	std	Z+47, r27	; 0x2f
	    if(ptr->psi < -PI)
    295c:	fe 01       	movw	r30, r28
    295e:	ef 5b       	subi	r30, 0xBF	; 191
    2960:	ff 4f       	sbci	r31, 0xFF	; 255
    2962:	01 90       	ld	r0, Z+
    2964:	f0 81       	ld	r31, Z
    2966:	e0 2d       	mov	r30, r0
    2968:	84 a5       	ldd	r24, Z+44	; 0x2c
    296a:	95 a5       	ldd	r25, Z+45	; 0x2d
    296c:	a6 a5       	ldd	r26, Z+46	; 0x2e
    296e:	b7 a5       	ldd	r27, Z+47	; 0x2f
    2970:	bc 01       	movw	r22, r24
    2972:	cd 01       	movw	r24, r26
    2974:	20 ed       	ldi	r18, 0xD0	; 208
    2976:	3f e0       	ldi	r19, 0x0F	; 15
    2978:	49 e4       	ldi	r20, 0x49	; 73
    297a:	50 ec       	ldi	r21, 0xC0	; 192
    297c:	0e 94 b4 2c 	call	0x5968	; 0x5968 <__cmpsf2>
    2980:	88 23       	and	r24, r24
    2982:	f4 f4       	brge	.+60     	; 0x29c0 <update_IMU+0x600>
	    	ptr->psi += 2*PI;
    2984:	fe 01       	movw	r30, r28
    2986:	ef 5b       	subi	r30, 0xBF	; 191
    2988:	ff 4f       	sbci	r31, 0xFF	; 255
    298a:	01 90       	ld	r0, Z+
    298c:	f0 81       	ld	r31, Z
    298e:	e0 2d       	mov	r30, r0
    2990:	84 a5       	ldd	r24, Z+44	; 0x2c
    2992:	95 a5       	ldd	r25, Z+45	; 0x2d
    2994:	a6 a5       	ldd	r26, Z+46	; 0x2e
    2996:	b7 a5       	ldd	r27, Z+47	; 0x2f
    2998:	bc 01       	movw	r22, r24
    299a:	cd 01       	movw	r24, r26
    299c:	20 ed       	ldi	r18, 0xD0	; 208
    299e:	3f e0       	ldi	r19, 0x0F	; 15
    29a0:	49 ec       	ldi	r20, 0xC9	; 201
    29a2:	50 e4       	ldi	r21, 0x40	; 64
    29a4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    29a8:	dc 01       	movw	r26, r24
    29aa:	cb 01       	movw	r24, r22
    29ac:	fe 01       	movw	r30, r28
    29ae:	ef 5b       	subi	r30, 0xBF	; 191
    29b0:	ff 4f       	sbci	r31, 0xFF	; 255
    29b2:	01 90       	ld	r0, Z+
    29b4:	f0 81       	ld	r31, Z
    29b6:	e0 2d       	mov	r30, r0
    29b8:	84 a7       	std	Z+44, r24	; 0x2c
    29ba:	95 a7       	std	Z+45, r25	; 0x2d
    29bc:	a6 a7       	std	Z+46, r26	; 0x2e
    29be:	b7 a7       	std	Z+47, r27	; 0x2f
	    f32 accelPhi = arctan(acc->y/acc->z);
    29c0:	ed ad       	ldd	r30, Y+61	; 0x3d
    29c2:	fe ad       	ldd	r31, Y+62	; 0x3e
    29c4:	84 81       	ldd	r24, Z+4	; 0x04
    29c6:	95 81       	ldd	r25, Z+5	; 0x05
    29c8:	a6 81       	ldd	r26, Z+6	; 0x06
    29ca:	b7 81       	ldd	r27, Z+7	; 0x07
    29cc:	ed ad       	ldd	r30, Y+61	; 0x3d
    29ce:	fe ad       	ldd	r31, Y+62	; 0x3e
    29d0:	20 85       	ldd	r18, Z+8	; 0x08
    29d2:	31 85       	ldd	r19, Z+9	; 0x09
    29d4:	42 85       	ldd	r20, Z+10	; 0x0a
    29d6:	53 85       	ldd	r21, Z+11	; 0x0b
    29d8:	bc 01       	movw	r22, r24
    29da:	cd 01       	movw	r24, r26
    29dc:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    29e0:	dc 01       	movw	r26, r24
    29e2:	cb 01       	movw	r24, r22
    29e4:	bc 01       	movw	r22, r24
    29e6:	cd 01       	movw	r24, r26
    29e8:	0e 94 ab 23 	call	0x4756	; 0x4756 <arctan>
    29ec:	dc 01       	movw	r26, r24
    29ee:	cb 01       	movw	r24, r22
    29f0:	8d 83       	std	Y+5, r24	; 0x05
    29f2:	9e 83       	std	Y+6, r25	; 0x06
    29f4:	af 83       	std	Y+7, r26	; 0x07
    29f6:	b8 87       	std	Y+8, r27	; 0x08
	    f32 acceltheta = arctan(-acc->y/9.812);
    29f8:	ed ad       	ldd	r30, Y+61	; 0x3d
    29fa:	fe ad       	ldd	r31, Y+62	; 0x3e
    29fc:	84 81       	ldd	r24, Z+4	; 0x04
    29fe:	95 81       	ldd	r25, Z+5	; 0x05
    2a00:	a6 81       	ldd	r26, Z+6	; 0x06
    2a02:	b7 81       	ldd	r27, Z+7	; 0x07
    2a04:	bc 01       	movw	r22, r24
    2a06:	cd 01       	movw	r24, r26
    2a08:	24 ef       	ldi	r18, 0xF4	; 244
    2a0a:	3d ef       	ldi	r19, 0xFD	; 253
    2a0c:	4c e1       	ldi	r20, 0x1C	; 28
    2a0e:	51 ec       	ldi	r21, 0xC1	; 193
    2a10:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2a14:	dc 01       	movw	r26, r24
    2a16:	cb 01       	movw	r24, r22
    2a18:	bc 01       	movw	r22, r24
    2a1a:	cd 01       	movw	r24, r26
    2a1c:	0e 94 ab 23 	call	0x4756	; 0x4756 <arctan>
    2a20:	dc 01       	movw	r26, r24
    2a22:	cb 01       	movw	r24, r22
    2a24:	89 83       	std	Y+1, r24	; 0x01
    2a26:	9a 83       	std	Y+2, r25	; 0x02
    2a28:	ab 83       	std	Y+3, r26	; 0x03
    2a2a:	bc 83       	std	Y+4, r27	; 0x04
	    ptr->phi = (taw/(taw + dt))* predictedphi + (dt/(taw + dt)) * accelPhi;
    2a2c:	6d a9       	ldd	r22, Y+53	; 0x35
    2a2e:	7e a9       	ldd	r23, Y+54	; 0x36
    2a30:	8f a9       	ldd	r24, Y+55	; 0x37
    2a32:	98 ad       	ldd	r25, Y+56	; 0x38
    2a34:	29 ad       	ldd	r18, Y+57	; 0x39
    2a36:	3a ad       	ldd	r19, Y+58	; 0x3a
    2a38:	4b ad       	ldd	r20, Y+59	; 0x3b
    2a3a:	5c ad       	ldd	r21, Y+60	; 0x3c
    2a3c:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2a40:	dc 01       	movw	r26, r24
    2a42:	cb 01       	movw	r24, r22
    2a44:	9c 01       	movw	r18, r24
    2a46:	ad 01       	movw	r20, r26
    2a48:	6d a9       	ldd	r22, Y+53	; 0x35
    2a4a:	7e a9       	ldd	r23, Y+54	; 0x36
    2a4c:	8f a9       	ldd	r24, Y+55	; 0x37
    2a4e:	98 ad       	ldd	r25, Y+56	; 0x38
    2a50:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2a54:	dc 01       	movw	r26, r24
    2a56:	cb 01       	movw	r24, r22
    2a58:	bc 01       	movw	r22, r24
    2a5a:	cd 01       	movw	r24, r26
    2a5c:	2d 85       	ldd	r18, Y+13	; 0x0d
    2a5e:	3e 85       	ldd	r19, Y+14	; 0x0e
    2a60:	4f 85       	ldd	r20, Y+15	; 0x0f
    2a62:	58 89       	ldd	r21, Y+16	; 0x10
    2a64:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2a68:	dc 01       	movw	r26, r24
    2a6a:	cb 01       	movw	r24, r22
    2a6c:	7c 01       	movw	r14, r24
    2a6e:	8d 01       	movw	r16, r26
    2a70:	6d a9       	ldd	r22, Y+53	; 0x35
    2a72:	7e a9       	ldd	r23, Y+54	; 0x36
    2a74:	8f a9       	ldd	r24, Y+55	; 0x37
    2a76:	98 ad       	ldd	r25, Y+56	; 0x38
    2a78:	29 ad       	ldd	r18, Y+57	; 0x39
    2a7a:	3a ad       	ldd	r19, Y+58	; 0x3a
    2a7c:	4b ad       	ldd	r20, Y+59	; 0x3b
    2a7e:	5c ad       	ldd	r21, Y+60	; 0x3c
    2a80:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2a84:	dc 01       	movw	r26, r24
    2a86:	cb 01       	movw	r24, r22
    2a88:	9c 01       	movw	r18, r24
    2a8a:	ad 01       	movw	r20, r26
    2a8c:	69 ad       	ldd	r22, Y+57	; 0x39
    2a8e:	7a ad       	ldd	r23, Y+58	; 0x3a
    2a90:	8b ad       	ldd	r24, Y+59	; 0x3b
    2a92:	9c ad       	ldd	r25, Y+60	; 0x3c
    2a94:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2a98:	dc 01       	movw	r26, r24
    2a9a:	cb 01       	movw	r24, r22
    2a9c:	bc 01       	movw	r22, r24
    2a9e:	cd 01       	movw	r24, r26
    2aa0:	2d 81       	ldd	r18, Y+5	; 0x05
    2aa2:	3e 81       	ldd	r19, Y+6	; 0x06
    2aa4:	4f 81       	ldd	r20, Y+7	; 0x07
    2aa6:	58 85       	ldd	r21, Y+8	; 0x08
    2aa8:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2aac:	dc 01       	movw	r26, r24
    2aae:	cb 01       	movw	r24, r22
    2ab0:	9c 01       	movw	r18, r24
    2ab2:	ad 01       	movw	r20, r26
    2ab4:	c8 01       	movw	r24, r16
    2ab6:	b7 01       	movw	r22, r14
    2ab8:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2abc:	dc 01       	movw	r26, r24
    2abe:	cb 01       	movw	r24, r22
    2ac0:	fe 01       	movw	r30, r28
    2ac2:	ef 5b       	subi	r30, 0xBF	; 191
    2ac4:	ff 4f       	sbci	r31, 0xFF	; 255
    2ac6:	01 90       	ld	r0, Z+
    2ac8:	f0 81       	ld	r31, Z
    2aca:	e0 2d       	mov	r30, r0
    2acc:	84 a3       	std	Z+36, r24	; 0x24
    2ace:	95 a3       	std	Z+37, r25	; 0x25
    2ad0:	a6 a3       	std	Z+38, r26	; 0x26
    2ad2:	b7 a3       	std	Z+39, r27	; 0x27
	    ptr->theta = (taw/(taw + dt))* predictedtheta + (dt/(taw + dt)) * acceltheta;
    2ad4:	6d a9       	ldd	r22, Y+53	; 0x35
    2ad6:	7e a9       	ldd	r23, Y+54	; 0x36
    2ad8:	8f a9       	ldd	r24, Y+55	; 0x37
    2ada:	98 ad       	ldd	r25, Y+56	; 0x38
    2adc:	29 ad       	ldd	r18, Y+57	; 0x39
    2ade:	3a ad       	ldd	r19, Y+58	; 0x3a
    2ae0:	4b ad       	ldd	r20, Y+59	; 0x3b
    2ae2:	5c ad       	ldd	r21, Y+60	; 0x3c
    2ae4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2ae8:	dc 01       	movw	r26, r24
    2aea:	cb 01       	movw	r24, r22
    2aec:	9c 01       	movw	r18, r24
    2aee:	ad 01       	movw	r20, r26
    2af0:	6d a9       	ldd	r22, Y+53	; 0x35
    2af2:	7e a9       	ldd	r23, Y+54	; 0x36
    2af4:	8f a9       	ldd	r24, Y+55	; 0x37
    2af6:	98 ad       	ldd	r25, Y+56	; 0x38
    2af8:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2afc:	dc 01       	movw	r26, r24
    2afe:	cb 01       	movw	r24, r22
    2b00:	bc 01       	movw	r22, r24
    2b02:	cd 01       	movw	r24, r26
    2b04:	29 85       	ldd	r18, Y+9	; 0x09
    2b06:	3a 85       	ldd	r19, Y+10	; 0x0a
    2b08:	4b 85       	ldd	r20, Y+11	; 0x0b
    2b0a:	5c 85       	ldd	r21, Y+12	; 0x0c
    2b0c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2b10:	dc 01       	movw	r26, r24
    2b12:	cb 01       	movw	r24, r22
    2b14:	7c 01       	movw	r14, r24
    2b16:	8d 01       	movw	r16, r26
    2b18:	6d a9       	ldd	r22, Y+53	; 0x35
    2b1a:	7e a9       	ldd	r23, Y+54	; 0x36
    2b1c:	8f a9       	ldd	r24, Y+55	; 0x37
    2b1e:	98 ad       	ldd	r25, Y+56	; 0x38
    2b20:	29 ad       	ldd	r18, Y+57	; 0x39
    2b22:	3a ad       	ldd	r19, Y+58	; 0x3a
    2b24:	4b ad       	ldd	r20, Y+59	; 0x3b
    2b26:	5c ad       	ldd	r21, Y+60	; 0x3c
    2b28:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2b2c:	dc 01       	movw	r26, r24
    2b2e:	cb 01       	movw	r24, r22
    2b30:	9c 01       	movw	r18, r24
    2b32:	ad 01       	movw	r20, r26
    2b34:	69 ad       	ldd	r22, Y+57	; 0x39
    2b36:	7a ad       	ldd	r23, Y+58	; 0x3a
    2b38:	8b ad       	ldd	r24, Y+59	; 0x3b
    2b3a:	9c ad       	ldd	r25, Y+60	; 0x3c
    2b3c:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2b40:	dc 01       	movw	r26, r24
    2b42:	cb 01       	movw	r24, r22
    2b44:	bc 01       	movw	r22, r24
    2b46:	cd 01       	movw	r24, r26
    2b48:	29 81       	ldd	r18, Y+1	; 0x01
    2b4a:	3a 81       	ldd	r19, Y+2	; 0x02
    2b4c:	4b 81       	ldd	r20, Y+3	; 0x03
    2b4e:	5c 81       	ldd	r21, Y+4	; 0x04
    2b50:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2b54:	dc 01       	movw	r26, r24
    2b56:	cb 01       	movw	r24, r22
    2b58:	9c 01       	movw	r18, r24
    2b5a:	ad 01       	movw	r20, r26
    2b5c:	c8 01       	movw	r24, r16
    2b5e:	b7 01       	movw	r22, r14
    2b60:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2b64:	dc 01       	movw	r26, r24
    2b66:	cb 01       	movw	r24, r22
    2b68:	fe 01       	movw	r30, r28
    2b6a:	ef 5b       	subi	r30, 0xBF	; 191
    2b6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2b6e:	01 90       	ld	r0, Z+
    2b70:	f0 81       	ld	r31, Z
    2b72:	e0 2d       	mov	r30, r0
    2b74:	80 a7       	std	Z+40, r24	; 0x28
    2b76:	91 a7       	std	Z+41, r25	; 0x29
    2b78:	a2 a7       	std	Z+42, r26	; 0x2a
    2b7a:	b3 a7       	std	Z+43, r27	; 0x2b
}
    2b7c:	ce 5b       	subi	r28, 0xBE	; 190
    2b7e:	df 4f       	sbci	r29, 0xFF	; 255
    2b80:	0f b6       	in	r0, 0x3f	; 63
    2b82:	f8 94       	cli
    2b84:	de bf       	out	0x3e, r29	; 62
    2b86:	0f be       	out	0x3f, r0	; 63
    2b88:	cd bf       	out	0x3d, r28	; 61
    2b8a:	cf 91       	pop	r28
    2b8c:	df 91       	pop	r29
    2b8e:	1f 91       	pop	r17
    2b90:	0f 91       	pop	r16
    2b92:	ff 90       	pop	r15
    2b94:	ef 90       	pop	r14
    2b96:	08 95       	ret

00002b98 <GPS_Read>:
/* This module prvoides lat, lon, and alt in meters passd by referance
 * please note that alt is meaured from the sea level  not from ground
 */

void GPS_Read(f32 *lon ,f32 *lat ,f32 *alt)
{
    2b98:	df 93       	push	r29
    2b9a:	cf 93       	push	r28
    2b9c:	cd b7       	in	r28, 0x3d	; 61
    2b9e:	de b7       	in	r29, 0x3e	; 62
    2ba0:	cb 54       	subi	r28, 0x4B	; 75
    2ba2:	d0 40       	sbci	r29, 0x00	; 0
    2ba4:	0f b6       	in	r0, 0x3f	; 63
    2ba6:	f8 94       	cli
    2ba8:	de bf       	out	0x3e, r29	; 62
    2baa:	0f be       	out	0x3f, r0	; 63
    2bac:	cd bf       	out	0x3d, r28	; 61
    2bae:	fe 01       	movw	r30, r28
    2bb0:	ea 5b       	subi	r30, 0xBA	; 186
    2bb2:	ff 4f       	sbci	r31, 0xFF	; 255
    2bb4:	91 83       	std	Z+1, r25	; 0x01
    2bb6:	80 83       	st	Z, r24
    2bb8:	fe 01       	movw	r30, r28
    2bba:	e8 5b       	subi	r30, 0xB8	; 184
    2bbc:	ff 4f       	sbci	r31, 0xFF	; 255
    2bbe:	71 83       	std	Z+1, r23	; 0x01
    2bc0:	60 83       	st	Z, r22
    2bc2:	fe 01       	movw	r30, r28
    2bc4:	e6 5b       	subi	r30, 0xB6	; 182
    2bc6:	ff 4f       	sbci	r31, 0xFF	; 255
    2bc8:	51 83       	std	Z+1, r21	; 0x01
    2bca:	40 83       	st	Z, r20
	// temporary variables,
	//if the reading is accepted we change the real variables
	u8 trash[10];

	u8 char1,char2,char3;
	char1 = UART1_receiveByte();
    2bcc:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
    2bd0:	8d 8f       	std	Y+29, r24	; 0x1d
	char2 = UART1_receiveByte();
    2bd2:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
    2bd6:	8c 8f       	std	Y+28, r24	; 0x1c
	while (1)
	{

		char3 = UART1_receiveByte();
    2bd8:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
    2bdc:	8b 8f       	std	Y+27, r24	; 0x1b
		if (char1=='G' && char2=='G' && char3 == 'A')		// the required info start with GGA
    2bde:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2be0:	87 34       	cpi	r24, 0x47	; 71
    2be2:	31 f4       	brne	.+12     	; 0x2bf0 <GPS_Read+0x58>
    2be4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2be6:	87 34       	cpi	r24, 0x47	; 71
    2be8:	19 f4       	brne	.+6      	; 0x2bf0 <GPS_Read+0x58>
    2bea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2bec:	81 34       	cpi	r24, 0x41	; 65
    2bee:	29 f0       	breq	.+10     	; 0x2bfa <GPS_Read+0x62>
			break;  										// break when we find the required info
		char1 = char2;
    2bf0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2bf2:	8d 8f       	std	Y+29, r24	; 0x1d
		char2 = char3;
    2bf4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2bf6:	8c 8f       	std	Y+28, r24	; 0x1c
    2bf8:	ef cf       	rjmp	.-34     	; 0x2bd8 <GPS_Read+0x40>
	}

	UART1_receiveByte();
    2bfa:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
	UART1_receiveString (*trash);
    2bfe:	8c ad       	ldd	r24, Y+60	; 0x3c
    2c00:	88 2f       	mov	r24, r24
    2c02:	90 e0       	ldi	r25, 0x00	; 0
    2c04:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>
	UART1_receiveString(temp_lat);
    2c08:	ce 01       	movw	r24, r28
    2c0a:	4e 96       	adiw	r24, 0x1e	; 30
    2c0c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>

	UART1_receiveByte();
    2c10:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
	UART1_receiveByte();
    2c14:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
	UART1_receiveString(temp_lon);
    2c18:	ce 01       	movw	r24, r28
    2c1a:	88 96       	adiw	r24, 0x28	; 40
    2c1c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>
	UART1_receiveByte();
    2c20:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
	UART1_receiveByte();
    2c24:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>

	//if(UART1_receiveByte() == '0') return; 					// this byte says if the reading is acceptable or not
	UART1_receiveByte();
    2c28:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <UART1_receiveByte>
	UART1_receiveString (*trash);
    2c2c:	8c ad       	ldd	r24, Y+60	; 0x3c
    2c2e:	88 2f       	mov	r24, r24
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>
	UART1_receiveString (*trash);
    2c36:	8c ad       	ldd	r24, Y+60	; 0x3c
    2c38:	88 2f       	mov	r24, r24
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>
	UART1_receiveString(temp_alt);
    2c40:	ce 01       	movw	r24, r28
    2c42:	c2 96       	adiw	r24, 0x32	; 50
    2c44:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <UART1_receiveString>
	f32 lat_num=strTof(temp_lat);											// put the reading in the variables passed by reference
    2c48:	ce 01       	movw	r24, r28
    2c4a:	4e 96       	adiw	r24, 0x1e	; 30
    2c4c:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2c50:	aa 27       	eor	r26, r26
    2c52:	97 fd       	sbrc	r25, 7
    2c54:	a0 95       	com	r26
    2c56:	ba 2f       	mov	r27, r26
    2c58:	bc 01       	movw	r22, r24
    2c5a:	cd 01       	movw	r24, r26
    2c5c:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2c60:	dc 01       	movw	r26, r24
    2c62:	cb 01       	movw	r24, r22
    2c64:	8f 8b       	std	Y+23, r24	; 0x17
    2c66:	98 8f       	std	Y+24, r25	; 0x18
    2c68:	a9 8f       	std	Y+25, r26	; 0x19
    2c6a:	ba 8f       	std	Y+26, r27	; 0x1a
	f32 lon_num=strTof(temp_lon);
    2c6c:	ce 01       	movw	r24, r28
    2c6e:	88 96       	adiw	r24, 0x28	; 40
    2c70:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2c74:	aa 27       	eor	r26, r26
    2c76:	97 fd       	sbrc	r25, 7
    2c78:	a0 95       	com	r26
    2c7a:	ba 2f       	mov	r27, r26
    2c7c:	bc 01       	movw	r22, r24
    2c7e:	cd 01       	movw	r24, r26
    2c80:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2c84:	dc 01       	movw	r26, r24
    2c86:	cb 01       	movw	r24, r22
    2c88:	8b 8b       	std	Y+19, r24	; 0x13
    2c8a:	9c 8b       	std	Y+20, r25	; 0x14
    2c8c:	ad 8b       	std	Y+21, r26	; 0x15
    2c8e:	be 8b       	std	Y+22, r27	; 0x16
	f32 alt_num=strTof(temp_alt);
    2c90:	ce 01       	movw	r24, r28
    2c92:	c2 96       	adiw	r24, 0x32	; 50
    2c94:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2c98:	aa 27       	eor	r26, r26
    2c9a:	97 fd       	sbrc	r25, 7
    2c9c:	a0 95       	com	r26
    2c9e:	ba 2f       	mov	r27, r26
    2ca0:	bc 01       	movw	r22, r24
    2ca2:	cd 01       	movw	r24, r26
    2ca4:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2ca8:	dc 01       	movw	r26, r24
    2caa:	cb 01       	movw	r24, r22
    2cac:	8f 87       	std	Y+15, r24	; 0x0f
    2cae:	98 8b       	std	Y+16, r25	; 0x10
    2cb0:	a9 8b       	std	Y+17, r26	; 0x11
    2cb2:	ba 8b       	std	Y+18, r27	; 0x12
/*how to transform degree to meter .. temp_lat form is ddmm.mmmm .. where d is degree m is mnt
 *  first multi with 10 and get dd alone them multi with 100 to get mnts
 *   devide mnts by 60 to get degree
 *   now add to the old dgrees and multi with 111,139 to get it in meters
 */
	u8 lat_deg=lat_num/100;
    2cb4:	6f 89       	ldd	r22, Y+23	; 0x17
    2cb6:	78 8d       	ldd	r23, Y+24	; 0x18
    2cb8:	89 8d       	ldd	r24, Y+25	; 0x19
    2cba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2cbc:	20 e0       	ldi	r18, 0x00	; 0
    2cbe:	30 e0       	ldi	r19, 0x00	; 0
    2cc0:	48 ec       	ldi	r20, 0xC8	; 200
    2cc2:	52 e4       	ldi	r21, 0x42	; 66
    2cc4:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2cc8:	dc 01       	movw	r26, r24
    2cca:	cb 01       	movw	r24, r22
    2ccc:	bc 01       	movw	r22, r24
    2cce:	cd 01       	movw	r24, r26
    2cd0:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <__fixunssfsi>
    2cd4:	dc 01       	movw	r26, r24
    2cd6:	cb 01       	movw	r24, r22
    2cd8:	8e 87       	std	Y+14, r24	; 0x0e
	f32 temp_mnts = (lat_num-lat_deg) /60;
    2cda:	8e 85       	ldd	r24, Y+14	; 0x0e
    2cdc:	88 2f       	mov	r24, r24
    2cde:	90 e0       	ldi	r25, 0x00	; 0
    2ce0:	aa 27       	eor	r26, r26
    2ce2:	97 fd       	sbrc	r25, 7
    2ce4:	a0 95       	com	r26
    2ce6:	ba 2f       	mov	r27, r26
    2ce8:	bc 01       	movw	r22, r24
    2cea:	cd 01       	movw	r24, r26
    2cec:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2cf0:	9b 01       	movw	r18, r22
    2cf2:	ac 01       	movw	r20, r24
    2cf4:	6f 89       	ldd	r22, Y+23	; 0x17
    2cf6:	78 8d       	ldd	r23, Y+24	; 0x18
    2cf8:	89 8d       	ldd	r24, Y+25	; 0x19
    2cfa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2cfc:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    2d00:	dc 01       	movw	r26, r24
    2d02:	cb 01       	movw	r24, r22
    2d04:	bc 01       	movw	r22, r24
    2d06:	cd 01       	movw	r24, r26
    2d08:	20 e0       	ldi	r18, 0x00	; 0
    2d0a:	30 e0       	ldi	r19, 0x00	; 0
    2d0c:	40 e7       	ldi	r20, 0x70	; 112
    2d0e:	52 e4       	ldi	r21, 0x42	; 66
    2d10:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2d14:	dc 01       	movw	r26, r24
    2d16:	cb 01       	movw	r24, r22
    2d18:	8a 87       	std	Y+10, r24	; 0x0a
    2d1a:	9b 87       	std	Y+11, r25	; 0x0b
    2d1c:	ac 87       	std	Y+12, r26	; 0x0c
    2d1e:	bd 87       	std	Y+13, r27	; 0x0d
	f32 lat_deg_mnt=lat_deg + temp_mnts;
    2d20:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d22:	88 2f       	mov	r24, r24
    2d24:	90 e0       	ldi	r25, 0x00	; 0
    2d26:	aa 27       	eor	r26, r26
    2d28:	97 fd       	sbrc	r25, 7
    2d2a:	a0 95       	com	r26
    2d2c:	ba 2f       	mov	r27, r26
    2d2e:	bc 01       	movw	r22, r24
    2d30:	cd 01       	movw	r24, r26
    2d32:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2d36:	dc 01       	movw	r26, r24
    2d38:	cb 01       	movw	r24, r22
    2d3a:	bc 01       	movw	r22, r24
    2d3c:	cd 01       	movw	r24, r26
    2d3e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d40:	3b 85       	ldd	r19, Y+11	; 0x0b
    2d42:	4c 85       	ldd	r20, Y+12	; 0x0c
    2d44:	5d 85       	ldd	r21, Y+13	; 0x0d
    2d46:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2d4a:	dc 01       	movw	r26, r24
    2d4c:	cb 01       	movw	r24, r22
    2d4e:	8e 83       	std	Y+6, r24	; 0x06
    2d50:	9f 83       	std	Y+7, r25	; 0x07
    2d52:	a8 87       	std	Y+8, r26	; 0x08
    2d54:	b9 87       	std	Y+9, r27	; 0x09
	lat_num= lat_deg_mnt * 111139;
    2d56:	6e 81       	ldd	r22, Y+6	; 0x06
    2d58:	7f 81       	ldd	r23, Y+7	; 0x07
    2d5a:	88 85       	ldd	r24, Y+8	; 0x08
    2d5c:	99 85       	ldd	r25, Y+9	; 0x09
    2d5e:	20 e8       	ldi	r18, 0x80	; 128
    2d60:	31 e1       	ldi	r19, 0x11	; 17
    2d62:	49 ed       	ldi	r20, 0xD9	; 217
    2d64:	57 e4       	ldi	r21, 0x47	; 71
    2d66:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2d6a:	dc 01       	movw	r26, r24
    2d6c:	cb 01       	movw	r24, r22
    2d6e:	8f 8b       	std	Y+23, r24	; 0x17
    2d70:	98 8f       	std	Y+24, r25	; 0x18
    2d72:	a9 8f       	std	Y+25, r26	; 0x19
    2d74:	ba 8f       	std	Y+26, r27	; 0x1a

	u8 lon_deg=lon_num/100;
    2d76:	6b 89       	ldd	r22, Y+19	; 0x13
    2d78:	7c 89       	ldd	r23, Y+20	; 0x14
    2d7a:	8d 89       	ldd	r24, Y+21	; 0x15
    2d7c:	9e 89       	ldd	r25, Y+22	; 0x16
    2d7e:	20 e0       	ldi	r18, 0x00	; 0
    2d80:	30 e0       	ldi	r19, 0x00	; 0
    2d82:	48 ec       	ldi	r20, 0xC8	; 200
    2d84:	52 e4       	ldi	r21, 0x42	; 66
    2d86:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2d8a:	dc 01       	movw	r26, r24
    2d8c:	cb 01       	movw	r24, r22
    2d8e:	bc 01       	movw	r22, r24
    2d90:	cd 01       	movw	r24, r26
    2d92:	0e 94 20 2d 	call	0x5a40	; 0x5a40 <__fixunssfsi>
    2d96:	dc 01       	movw	r26, r24
    2d98:	cb 01       	movw	r24, r22
    2d9a:	8d 83       	std	Y+5, r24	; 0x05
	temp_mnts = (lon_num-lon_deg) /60;
    2d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d9e:	88 2f       	mov	r24, r24
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	aa 27       	eor	r26, r26
    2da4:	97 fd       	sbrc	r25, 7
    2da6:	a0 95       	com	r26
    2da8:	ba 2f       	mov	r27, r26
    2daa:	bc 01       	movw	r22, r24
    2dac:	cd 01       	movw	r24, r26
    2dae:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2db2:	9b 01       	movw	r18, r22
    2db4:	ac 01       	movw	r20, r24
    2db6:	6b 89       	ldd	r22, Y+19	; 0x13
    2db8:	7c 89       	ldd	r23, Y+20	; 0x14
    2dba:	8d 89       	ldd	r24, Y+21	; 0x15
    2dbc:	9e 89       	ldd	r25, Y+22	; 0x16
    2dbe:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    2dc2:	dc 01       	movw	r26, r24
    2dc4:	cb 01       	movw	r24, r22
    2dc6:	bc 01       	movw	r22, r24
    2dc8:	cd 01       	movw	r24, r26
    2dca:	20 e0       	ldi	r18, 0x00	; 0
    2dcc:	30 e0       	ldi	r19, 0x00	; 0
    2dce:	40 e7       	ldi	r20, 0x70	; 112
    2dd0:	52 e4       	ldi	r21, 0x42	; 66
    2dd2:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    2dd6:	dc 01       	movw	r26, r24
    2dd8:	cb 01       	movw	r24, r22
    2dda:	8a 87       	std	Y+10, r24	; 0x0a
    2ddc:	9b 87       	std	Y+11, r25	; 0x0b
    2dde:	ac 87       	std	Y+12, r26	; 0x0c
    2de0:	bd 87       	std	Y+13, r27	; 0x0d
	f32 lon_deg_mnt=lon_deg + temp_mnts;
    2de2:	8d 81       	ldd	r24, Y+5	; 0x05
    2de4:	88 2f       	mov	r24, r24
    2de6:	90 e0       	ldi	r25, 0x00	; 0
    2de8:	aa 27       	eor	r26, r26
    2dea:	97 fd       	sbrc	r25, 7
    2dec:	a0 95       	com	r26
    2dee:	ba 2f       	mov	r27, r26
    2df0:	bc 01       	movw	r22, r24
    2df2:	cd 01       	movw	r24, r26
    2df4:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2df8:	dc 01       	movw	r26, r24
    2dfa:	cb 01       	movw	r24, r22
    2dfc:	bc 01       	movw	r22, r24
    2dfe:	cd 01       	movw	r24, r26
    2e00:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e02:	3b 85       	ldd	r19, Y+11	; 0x0b
    2e04:	4c 85       	ldd	r20, Y+12	; 0x0c
    2e06:	5d 85       	ldd	r21, Y+13	; 0x0d
    2e08:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    2e0c:	dc 01       	movw	r26, r24
    2e0e:	cb 01       	movw	r24, r22
    2e10:	89 83       	std	Y+1, r24	; 0x01
    2e12:	9a 83       	std	Y+2, r25	; 0x02
    2e14:	ab 83       	std	Y+3, r26	; 0x03
    2e16:	bc 83       	std	Y+4, r27	; 0x04
	lon_num= lon_deg_mnt * 111139;
    2e18:	69 81       	ldd	r22, Y+1	; 0x01
    2e1a:	7a 81       	ldd	r23, Y+2	; 0x02
    2e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e20:	20 e8       	ldi	r18, 0x80	; 128
    2e22:	31 e1       	ldi	r19, 0x11	; 17
    2e24:	49 ed       	ldi	r20, 0xD9	; 217
    2e26:	57 e4       	ldi	r21, 0x47	; 71
    2e28:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    2e2c:	dc 01       	movw	r26, r24
    2e2e:	cb 01       	movw	r24, r22
    2e30:	8b 8b       	std	Y+19, r24	; 0x13
    2e32:	9c 8b       	std	Y+20, r25	; 0x14
    2e34:	ad 8b       	std	Y+21, r26	; 0x15
    2e36:	be 8b       	std	Y+22, r27	; 0x16





	*lat=strTof(lat_num);				// put the reading in the variables passed by reference
    2e38:	8f 89       	ldd	r24, Y+23	; 0x17
    2e3a:	98 8d       	ldd	r25, Y+24	; 0x18
    2e3c:	a9 8d       	ldd	r26, Y+25	; 0x19
    2e3e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2e40:	bc 01       	movw	r22, r24
    2e42:	cd 01       	movw	r24, r26
    2e44:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2e48:	aa 27       	eor	r26, r26
    2e4a:	97 fd       	sbrc	r25, 7
    2e4c:	a0 95       	com	r26
    2e4e:	ba 2f       	mov	r27, r26
    2e50:	bc 01       	movw	r22, r24
    2e52:	cd 01       	movw	r24, r26
    2e54:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2e58:	dc 01       	movw	r26, r24
    2e5a:	cb 01       	movw	r24, r22
    2e5c:	fe 01       	movw	r30, r28
    2e5e:	e8 5b       	subi	r30, 0xB8	; 184
    2e60:	ff 4f       	sbci	r31, 0xFF	; 255
    2e62:	01 90       	ld	r0, Z+
    2e64:	f0 81       	ld	r31, Z
    2e66:	e0 2d       	mov	r30, r0
    2e68:	80 83       	st	Z, r24
    2e6a:	91 83       	std	Z+1, r25	; 0x01
    2e6c:	a2 83       	std	Z+2, r26	; 0x02
    2e6e:	b3 83       	std	Z+3, r27	; 0x03
	*lon=strTof(lon_num);
    2e70:	8b 89       	ldd	r24, Y+19	; 0x13
    2e72:	9c 89       	ldd	r25, Y+20	; 0x14
    2e74:	ad 89       	ldd	r26, Y+21	; 0x15
    2e76:	be 89       	ldd	r27, Y+22	; 0x16
    2e78:	bc 01       	movw	r22, r24
    2e7a:	cd 01       	movw	r24, r26
    2e7c:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2e80:	aa 27       	eor	r26, r26
    2e82:	97 fd       	sbrc	r25, 7
    2e84:	a0 95       	com	r26
    2e86:	ba 2f       	mov	r27, r26
    2e88:	bc 01       	movw	r22, r24
    2e8a:	cd 01       	movw	r24, r26
    2e8c:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2e90:	dc 01       	movw	r26, r24
    2e92:	cb 01       	movw	r24, r22
    2e94:	fe 01       	movw	r30, r28
    2e96:	ea 5b       	subi	r30, 0xBA	; 186
    2e98:	ff 4f       	sbci	r31, 0xFF	; 255
    2e9a:	01 90       	ld	r0, Z+
    2e9c:	f0 81       	ld	r31, Z
    2e9e:	e0 2d       	mov	r30, r0
    2ea0:	80 83       	st	Z, r24
    2ea2:	91 83       	std	Z+1, r25	; 0x01
    2ea4:	a2 83       	std	Z+2, r26	; 0x02
    2ea6:	b3 83       	std	Z+3, r27	; 0x03
	*alt=strTof(alt_num);
    2ea8:	8f 85       	ldd	r24, Y+15	; 0x0f
    2eaa:	98 89       	ldd	r25, Y+16	; 0x10
    2eac:	a9 89       	ldd	r26, Y+17	; 0x11
    2eae:	ba 89       	ldd	r27, Y+18	; 0x12
    2eb0:	bc 01       	movw	r22, r24
    2eb2:	cd 01       	movw	r24, r26
    2eb4:	0e 94 7e 24 	call	0x48fc	; 0x48fc <strTof>
    2eb8:	aa 27       	eor	r26, r26
    2eba:	97 fd       	sbrc	r25, 7
    2ebc:	a0 95       	com	r26
    2ebe:	ba 2f       	mov	r27, r26
    2ec0:	bc 01       	movw	r22, r24
    2ec2:	cd 01       	movw	r24, r26
    2ec4:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    2ec8:	dc 01       	movw	r26, r24
    2eca:	cb 01       	movw	r24, r22
    2ecc:	fe 01       	movw	r30, r28
    2ece:	e6 5b       	subi	r30, 0xB6	; 182
    2ed0:	ff 4f       	sbci	r31, 0xFF	; 255
    2ed2:	01 90       	ld	r0, Z+
    2ed4:	f0 81       	ld	r31, Z
    2ed6:	e0 2d       	mov	r30, r0
    2ed8:	80 83       	st	Z, r24
    2eda:	91 83       	std	Z+1, r25	; 0x01
    2edc:	a2 83       	std	Z+2, r26	; 0x02
    2ede:	b3 83       	std	Z+3, r27	; 0x03

	return;
}
    2ee0:	c5 5b       	subi	r28, 0xB5	; 181
    2ee2:	df 4f       	sbci	r29, 0xFF	; 255
    2ee4:	0f b6       	in	r0, 0x3f	; 63
    2ee6:	f8 94       	cli
    2ee8:	de bf       	out	0x3e, r29	; 62
    2eea:	0f be       	out	0x3f, r0	; 63
    2eec:	cd bf       	out	0x3d, r28	; 61
    2eee:	cf 91       	pop	r28
    2ef0:	df 91       	pop	r29
    2ef2:	08 95       	ret

00002ef4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2ef4:	df 93       	push	r29
    2ef6:	cf 93       	push	r28
    2ef8:	00 d0       	rcall	.+0      	; 0x2efa <pvPortMalloc+0x6>
    2efa:	00 d0       	rcall	.+0      	; 0x2efc <pvPortMalloc+0x8>
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
    2f00:	9c 83       	std	Y+4, r25	; 0x04
    2f02:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2f04:	1a 82       	std	Y+2, r1	; 0x02
    2f06:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2f08:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2f0c:	80 91 4a 01 	lds	r24, 0x014A
    2f10:	90 91 4b 01 	lds	r25, 0x014B
    2f14:	2b 81       	ldd	r18, Y+3	; 0x03
    2f16:	3c 81       	ldd	r19, Y+4	; 0x04
    2f18:	82 0f       	add	r24, r18
    2f1a:	93 1f       	adc	r25, r19
    2f1c:	22 e0       	ldi	r18, 0x02	; 2
    2f1e:	88 35       	cpi	r24, 0x58	; 88
    2f20:	92 07       	cpc	r25, r18
    2f22:	18 f5       	brcc	.+70     	; 0x2f6a <pvPortMalloc+0x76>
    2f24:	20 91 4a 01 	lds	r18, 0x014A
    2f28:	30 91 4b 01 	lds	r19, 0x014B
    2f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f30:	28 0f       	add	r18, r24
    2f32:	39 1f       	adc	r19, r25
    2f34:	80 91 4a 01 	lds	r24, 0x014A
    2f38:	90 91 4b 01 	lds	r25, 0x014B
    2f3c:	82 17       	cp	r24, r18
    2f3e:	93 07       	cpc	r25, r19
    2f40:	a0 f4       	brcc	.+40     	; 0x2f6a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2f42:	80 91 4a 01 	lds	r24, 0x014A
    2f46:	90 91 4b 01 	lds	r25, 0x014B
    2f4a:	84 5b       	subi	r24, 0xB4	; 180
    2f4c:	9e 4f       	sbci	r25, 0xFE	; 254
    2f4e:	9a 83       	std	Y+2, r25	; 0x02
    2f50:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2f52:	20 91 4a 01 	lds	r18, 0x014A
    2f56:	30 91 4b 01 	lds	r19, 0x014B
    2f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f5e:	82 0f       	add	r24, r18
    2f60:	93 1f       	adc	r25, r19
    2f62:	90 93 4b 01 	sts	0x014B, r25
    2f66:	80 93 4a 01 	sts	0x014A, r24
		}	
	}
	xTaskResumeAll();
    2f6a:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2f6e:	89 81       	ldd	r24, Y+1	; 0x01
    2f70:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f72:	0f 90       	pop	r0
    2f74:	0f 90       	pop	r0
    2f76:	0f 90       	pop	r0
    2f78:	0f 90       	pop	r0
    2f7a:	cf 91       	pop	r28
    2f7c:	df 91       	pop	r29
    2f7e:	08 95       	ret

00002f80 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2f80:	df 93       	push	r29
    2f82:	cf 93       	push	r28
    2f84:	00 d0       	rcall	.+0      	; 0x2f86 <vPortFree+0x6>
    2f86:	cd b7       	in	r28, 0x3d	; 61
    2f88:	de b7       	in	r29, 0x3e	; 62
    2f8a:	9a 83       	std	Y+2, r25	; 0x02
    2f8c:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2f8e:	0f 90       	pop	r0
    2f90:	0f 90       	pop	r0
    2f92:	cf 91       	pop	r28
    2f94:	df 91       	pop	r29
    2f96:	08 95       	ret

00002f98 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2f98:	df 93       	push	r29
    2f9a:	cf 93       	push	r28
    2f9c:	cd b7       	in	r28, 0x3d	; 61
    2f9e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2fa0:	10 92 4b 01 	sts	0x014B, r1
    2fa4:	10 92 4a 01 	sts	0x014A, r1
}
    2fa8:	cf 91       	pop	r28
    2faa:	df 91       	pop	r29
    2fac:	08 95       	ret

00002fae <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2fae:	df 93       	push	r29
    2fb0:	cf 93       	push	r28
    2fb2:	cd b7       	in	r28, 0x3d	; 61
    2fb4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2fb6:	20 91 4a 01 	lds	r18, 0x014A
    2fba:	30 91 4b 01 	lds	r19, 0x014B
    2fbe:	88 e5       	ldi	r24, 0x58	; 88
    2fc0:	92 e0       	ldi	r25, 0x02	; 2
    2fc2:	82 1b       	sub	r24, r18
    2fc4:	93 0b       	sbc	r25, r19
}
    2fc6:	cf 91       	pop	r28
    2fc8:	df 91       	pop	r29
    2fca:	08 95       	ret

00002fcc <I2C_Init>:
#include "DDIO_128.h"
#include "i2c.h"


void I2C_Init(u8 bit_rate)
{
    2fcc:	df 93       	push	r29
    2fce:	cf 93       	push	r28
    2fd0:	0f 92       	push	r0
    2fd2:	cd b7       	in	r28, 0x3d	; 61
    2fd4:	de b7       	in	r29, 0x3e	; 62
    2fd6:	89 83       	std	Y+1, r24	; 0x01
	TWCR = 0x00;
    2fd8:	e4 e7       	ldi	r30, 0x74	; 116
    2fda:	f0 e0       	ldi	r31, 0x00	; 0
    2fdc:	10 82       	st	Z, r1
	TWBR = bit_rate;
    2fde:	e0 e7       	ldi	r30, 0x70	; 112
    2fe0:	f0 e0       	ldi	r31, 0x00	; 0
    2fe2:	89 81       	ldd	r24, Y+1	; 0x01
    2fe4:	80 83       	st	Z, r24

}
    2fe6:	0f 90       	pop	r0
    2fe8:	cf 91       	pop	r28
    2fea:	df 91       	pop	r29
    2fec:	08 95       	ret

00002fee <I2C_Start>:

void I2C_Start(void)
{
    2fee:	df 93       	push	r29
    2ff0:	cf 93       	push	r28
    2ff2:	cd b7       	in	r28, 0x3d	; 61
    2ff4:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWSTA)|(1<<TWEN)|(1<<TWINT);
    2ff6:	e4 e7       	ldi	r30, 0x74	; 116
    2ff8:	f0 e0       	ldi	r31, 0x00	; 0
    2ffa:	84 ea       	ldi	r24, 0xA4	; 164
    2ffc:	80 83       	st	Z, r24

	while(GET_BIT(TWCR, TWINT) == 0);
    2ffe:	e4 e7       	ldi	r30, 0x74	; 116
    3000:	f0 e0       	ldi	r31, 0x00	; 0
    3002:	80 81       	ld	r24, Z
    3004:	88 23       	and	r24, r24
    3006:	dc f7       	brge	.-10     	; 0x2ffe <I2C_Start+0x10>

	while((TWSR & (0xF8)) != 0x08  && (TWSR & (0xF8)) != 0x10); //start status ok
    3008:	e1 e7       	ldi	r30, 0x71	; 113
    300a:	f0 e0       	ldi	r31, 0x00	; 0
    300c:	80 81       	ld	r24, Z
    300e:	88 2f       	mov	r24, r24
    3010:	90 e0       	ldi	r25, 0x00	; 0
    3012:	88 7f       	andi	r24, 0xF8	; 248
    3014:	90 70       	andi	r25, 0x00	; 0
    3016:	88 30       	cpi	r24, 0x08	; 8
    3018:	91 05       	cpc	r25, r1
    301a:	51 f0       	breq	.+20     	; 0x3030 <I2C_Start+0x42>
    301c:	e1 e7       	ldi	r30, 0x71	; 113
    301e:	f0 e0       	ldi	r31, 0x00	; 0
    3020:	80 81       	ld	r24, Z
    3022:	88 2f       	mov	r24, r24
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	88 7f       	andi	r24, 0xF8	; 248
    3028:	90 70       	andi	r25, 0x00	; 0
    302a:	80 31       	cpi	r24, 0x10	; 16
    302c:	91 05       	cpc	r25, r1
    302e:	61 f7       	brne	.-40     	; 0x3008 <I2C_Start+0x1a>
}
    3030:	cf 91       	pop	r28
    3032:	df 91       	pop	r29
    3034:	08 95       	ret

00003036 <I2C_Add>:

void I2C_Add(u8 Add)
{
    3036:	df 93       	push	r29
    3038:	cf 93       	push	r28
    303a:	00 d0       	rcall	.+0      	; 0x303c <I2C_Add+0x6>
    303c:	0f 92       	push	r0
    303e:	cd b7       	in	r28, 0x3d	; 61
    3040:	de b7       	in	r29, 0x3e	; 62
    3042:	89 83       	std	Y+1, r24	; 0x01
	TWDR = Add;
    3044:	e3 e7       	ldi	r30, 0x73	; 115
    3046:	f0 e0       	ldi	r31, 0x00	; 0
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	80 83       	st	Z, r24
	CLEAR_BIT(TWCR,TWSTA);
    304c:	a4 e7       	ldi	r26, 0x74	; 116
    304e:	b0 e0       	ldi	r27, 0x00	; 0
    3050:	e4 e7       	ldi	r30, 0x74	; 116
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	80 81       	ld	r24, Z
    3056:	8f 7d       	andi	r24, 0xDF	; 223
    3058:	8c 93       	st	X, r24
	TWCR = (1<<TWEN)|(1<<TWINT);
    305a:	e4 e7       	ldi	r30, 0x74	; 116
    305c:	f0 e0       	ldi	r31, 0x00	; 0
    305e:	84 e8       	ldi	r24, 0x84	; 132
    3060:	80 83       	st	Z, r24

	while (!(TWCR & (1<<TWINT)));
    3062:	e4 e7       	ldi	r30, 0x74	; 116
    3064:	f0 e0       	ldi	r31, 0x00	; 0
    3066:	80 81       	ld	r24, Z
    3068:	88 23       	and	r24, r24
    306a:	dc f7       	brge	.-10     	; 0x3062 <I2C_Add+0x2c>
	while((TWSR & (0xF8)) != 0x18 &(TWSR & (0xF8)) != 0x40);
    306c:	e1 e7       	ldi	r30, 0x71	; 113
    306e:	f0 e0       	ldi	r31, 0x00	; 0
    3070:	80 81       	ld	r24, Z
    3072:	88 2f       	mov	r24, r24
    3074:	90 e0       	ldi	r25, 0x00	; 0
    3076:	88 7f       	andi	r24, 0xF8	; 248
    3078:	90 70       	andi	r25, 0x00	; 0
    307a:	1b 82       	std	Y+3, r1	; 0x03
    307c:	88 31       	cpi	r24, 0x18	; 24
    307e:	91 05       	cpc	r25, r1
    3080:	11 f0       	breq	.+4      	; 0x3086 <I2C_Add+0x50>
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	8b 83       	std	Y+3, r24	; 0x03
    3086:	e1 e7       	ldi	r30, 0x71	; 113
    3088:	f0 e0       	ldi	r31, 0x00	; 0
    308a:	80 81       	ld	r24, Z
    308c:	88 2f       	mov	r24, r24
    308e:	90 e0       	ldi	r25, 0x00	; 0
    3090:	88 7f       	andi	r24, 0xF8	; 248
    3092:	90 70       	andi	r25, 0x00	; 0
    3094:	1a 82       	std	Y+2, r1	; 0x02
    3096:	80 34       	cpi	r24, 0x40	; 64
    3098:	91 05       	cpc	r25, r1
    309a:	11 f0       	breq	.+4      	; 0x30a0 <I2C_Add+0x6a>
    309c:	91 e0       	ldi	r25, 0x01	; 1
    309e:	9a 83       	std	Y+2, r25	; 0x02
    30a0:	8b 81       	ldd	r24, Y+3	; 0x03
    30a2:	9a 81       	ldd	r25, Y+2	; 0x02
    30a4:	89 23       	and	r24, r25
    30a6:	88 23       	and	r24, r24
    30a8:	09 f7       	brne	.-62     	; 0x306c <I2C_Add+0x36>
}
    30aa:	0f 90       	pop	r0
    30ac:	0f 90       	pop	r0
    30ae:	0f 90       	pop	r0
    30b0:	cf 91       	pop	r28
    30b2:	df 91       	pop	r29
    30b4:	08 95       	ret

000030b6 <I2C_Write>:
void I2C_Write(u8 data)
{
    30b6:	df 93       	push	r29
    30b8:	cf 93       	push	r28
    30ba:	00 d0       	rcall	.+0      	; 0x30bc <I2C_Write+0x6>
    30bc:	cd b7       	in	r28, 0x3d	; 61
    30be:	de b7       	in	r29, 0x3e	; 62
    30c0:	8a 83       	std	Y+2, r24	; 0x02
	u8 status;
	TWDR = data;
    30c2:	e3 e7       	ldi	r30, 0x73	; 115
    30c4:	f0 e0       	ldi	r31, 0x00	; 0
    30c6:	8a 81       	ldd	r24, Y+2	; 0x02
    30c8:	80 83       	st	Z, r24
	TWCR = (1<<TWEN)|(1<<TWINT);
    30ca:	e4 e7       	ldi	r30, 0x74	; 116
    30cc:	f0 e0       	ldi	r31, 0x00	; 0
    30ce:	84 e8       	ldi	r24, 0x84	; 132
    30d0:	80 83       	st	Z, r24
	while(GET_BIT(TWCR, TWINT) == 0);
    30d2:	e4 e7       	ldi	r30, 0x74	; 116
    30d4:	f0 e0       	ldi	r31, 0x00	; 0
    30d6:	80 81       	ld	r24, Z
    30d8:	88 23       	and	r24, r24
    30da:	dc f7       	brge	.-10     	; 0x30d2 <I2C_Write+0x1c>
	status=TWSR& 0xF8;
    30dc:	e1 e7       	ldi	r30, 0x71	; 113
    30de:	f0 e0       	ldi	r31, 0x00	; 0
    30e0:	80 81       	ld	r24, Z
    30e2:	88 7f       	andi	r24, 0xF8	; 248
    30e4:	89 83       	std	Y+1, r24	; 0x01
	while(status!= 0x28);
    30e6:	89 81       	ldd	r24, Y+1	; 0x01
    30e8:	88 32       	cpi	r24, 0x28	; 40
    30ea:	e9 f7       	brne	.-6      	; 0x30e6 <I2C_Write+0x30>

}
    30ec:	0f 90       	pop	r0
    30ee:	0f 90       	pop	r0
    30f0:	cf 91       	pop	r28
    30f2:	df 91       	pop	r29
    30f4:	08 95       	ret

000030f6 <I2C_Stop>:
void I2C_Stop(void)
{
    30f6:	df 93       	push	r29
    30f8:	cf 93       	push	r28
    30fa:	cd b7       	in	r28, 0x3d	; 61
    30fc:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
    30fe:	e4 e7       	ldi	r30, 0x74	; 116
    3100:	f0 e0       	ldi	r31, 0x00	; 0
    3102:	84 e9       	ldi	r24, 0x94	; 148
    3104:	80 83       	st	Z, r24
}
    3106:	cf 91       	pop	r28
    3108:	df 91       	pop	r29
    310a:	08 95       	ret

0000310c <I2C_Read>:

u8 I2C_Read(void)
{
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1<<TWEA)|(1<<TWEN)|(1<<TWINT);
    3114:	e4 e7       	ldi	r30, 0x74	; 116
    3116:	f0 e0       	ldi	r31, 0x00	; 0
    3118:	84 ec       	ldi	r24, 0xC4	; 196
    311a:	80 83       	st	Z, r24


	while(GET_BIT(TWCR, TWINT) == 0);
    311c:	e4 e7       	ldi	r30, 0x74	; 116
    311e:	f0 e0       	ldi	r31, 0x00	; 0
    3120:	80 81       	ld	r24, Z
    3122:	88 23       	and	r24, r24
    3124:	dc f7       	brge	.-10     	; 0x311c <I2C_Read+0x10>
	return TWDR;
    3126:	e3 e7       	ldi	r30, 0x73	; 115
    3128:	f0 e0       	ldi	r31, 0x00	; 0
    312a:	80 81       	ld	r24, Z
}
    312c:	cf 91       	pop	r28
    312e:	df 91       	pop	r29
    3130:	08 95       	ret

00003132 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    3132:	df 93       	push	r29
    3134:	cf 93       	push	r28
    3136:	00 d0       	rcall	.+0      	; 0x3138 <vListInitialise+0x6>
    3138:	cd b7       	in	r28, 0x3d	; 61
    313a:	de b7       	in	r29, 0x3e	; 62
    313c:	9a 83       	std	Y+2, r25	; 0x02
    313e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    3140:	89 81       	ldd	r24, Y+1	; 0x01
    3142:	9a 81       	ldd	r25, Y+2	; 0x02
    3144:	03 96       	adiw	r24, 0x03	; 3
    3146:	e9 81       	ldd	r30, Y+1	; 0x01
    3148:	fa 81       	ldd	r31, Y+2	; 0x02
    314a:	92 83       	std	Z+2, r25	; 0x02
    314c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    314e:	e9 81       	ldd	r30, Y+1	; 0x01
    3150:	fa 81       	ldd	r31, Y+2	; 0x02
    3152:	8f ef       	ldi	r24, 0xFF	; 255
    3154:	9f ef       	ldi	r25, 0xFF	; 255
    3156:	94 83       	std	Z+4, r25	; 0x04
    3158:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    315a:	89 81       	ldd	r24, Y+1	; 0x01
    315c:	9a 81       	ldd	r25, Y+2	; 0x02
    315e:	03 96       	adiw	r24, 0x03	; 3
    3160:	e9 81       	ldd	r30, Y+1	; 0x01
    3162:	fa 81       	ldd	r31, Y+2	; 0x02
    3164:	96 83       	std	Z+6, r25	; 0x06
    3166:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3168:	89 81       	ldd	r24, Y+1	; 0x01
    316a:	9a 81       	ldd	r25, Y+2	; 0x02
    316c:	03 96       	adiw	r24, 0x03	; 3
    316e:	e9 81       	ldd	r30, Y+1	; 0x01
    3170:	fa 81       	ldd	r31, Y+2	; 0x02
    3172:	90 87       	std	Z+8, r25	; 0x08
    3174:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    3176:	e9 81       	ldd	r30, Y+1	; 0x01
    3178:	fa 81       	ldd	r31, Y+2	; 0x02
    317a:	10 82       	st	Z, r1
}
    317c:	0f 90       	pop	r0
    317e:	0f 90       	pop	r0
    3180:	cf 91       	pop	r28
    3182:	df 91       	pop	r29
    3184:	08 95       	ret

00003186 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    3186:	df 93       	push	r29
    3188:	cf 93       	push	r28
    318a:	00 d0       	rcall	.+0      	; 0x318c <vListInitialiseItem+0x6>
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	9a 83       	std	Y+2, r25	; 0x02
    3192:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    3194:	e9 81       	ldd	r30, Y+1	; 0x01
    3196:	fa 81       	ldd	r31, Y+2	; 0x02
    3198:	11 86       	std	Z+9, r1	; 0x09
    319a:	10 86       	std	Z+8, r1	; 0x08
}
    319c:	0f 90       	pop	r0
    319e:	0f 90       	pop	r0
    31a0:	cf 91       	pop	r28
    31a2:	df 91       	pop	r29
    31a4:	08 95       	ret

000031a6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    31a6:	df 93       	push	r29
    31a8:	cf 93       	push	r28
    31aa:	00 d0       	rcall	.+0      	; 0x31ac <vListInsertEnd+0x6>
    31ac:	00 d0       	rcall	.+0      	; 0x31ae <vListInsertEnd+0x8>
    31ae:	00 d0       	rcall	.+0      	; 0x31b0 <vListInsertEnd+0xa>
    31b0:	cd b7       	in	r28, 0x3d	; 61
    31b2:	de b7       	in	r29, 0x3e	; 62
    31b4:	9c 83       	std	Y+4, r25	; 0x04
    31b6:	8b 83       	std	Y+3, r24	; 0x03
    31b8:	7e 83       	std	Y+6, r23	; 0x06
    31ba:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    31bc:	eb 81       	ldd	r30, Y+3	; 0x03
    31be:	fc 81       	ldd	r31, Y+4	; 0x04
    31c0:	81 81       	ldd	r24, Z+1	; 0x01
    31c2:	92 81       	ldd	r25, Z+2	; 0x02
    31c4:	9a 83       	std	Y+2, r25	; 0x02
    31c6:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    31c8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ca:	fa 81       	ldd	r31, Y+2	; 0x02
    31cc:	82 81       	ldd	r24, Z+2	; 0x02
    31ce:	93 81       	ldd	r25, Z+3	; 0x03
    31d0:	ed 81       	ldd	r30, Y+5	; 0x05
    31d2:	fe 81       	ldd	r31, Y+6	; 0x06
    31d4:	93 83       	std	Z+3, r25	; 0x03
    31d6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    31d8:	eb 81       	ldd	r30, Y+3	; 0x03
    31da:	fc 81       	ldd	r31, Y+4	; 0x04
    31dc:	81 81       	ldd	r24, Z+1	; 0x01
    31de:	92 81       	ldd	r25, Z+2	; 0x02
    31e0:	ed 81       	ldd	r30, Y+5	; 0x05
    31e2:	fe 81       	ldd	r31, Y+6	; 0x06
    31e4:	95 83       	std	Z+5, r25	; 0x05
    31e6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    31e8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ea:	fa 81       	ldd	r31, Y+2	; 0x02
    31ec:	02 80       	ldd	r0, Z+2	; 0x02
    31ee:	f3 81       	ldd	r31, Z+3	; 0x03
    31f0:	e0 2d       	mov	r30, r0
    31f2:	8d 81       	ldd	r24, Y+5	; 0x05
    31f4:	9e 81       	ldd	r25, Y+6	; 0x06
    31f6:	95 83       	std	Z+5, r25	; 0x05
    31f8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    31fa:	8d 81       	ldd	r24, Y+5	; 0x05
    31fc:	9e 81       	ldd	r25, Y+6	; 0x06
    31fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3200:	fa 81       	ldd	r31, Y+2	; 0x02
    3202:	93 83       	std	Z+3, r25	; 0x03
    3204:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    3206:	8d 81       	ldd	r24, Y+5	; 0x05
    3208:	9e 81       	ldd	r25, Y+6	; 0x06
    320a:	eb 81       	ldd	r30, Y+3	; 0x03
    320c:	fc 81       	ldd	r31, Y+4	; 0x04
    320e:	92 83       	std	Z+2, r25	; 0x02
    3210:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3212:	ed 81       	ldd	r30, Y+5	; 0x05
    3214:	fe 81       	ldd	r31, Y+6	; 0x06
    3216:	8b 81       	ldd	r24, Y+3	; 0x03
    3218:	9c 81       	ldd	r25, Y+4	; 0x04
    321a:	91 87       	std	Z+9, r25	; 0x09
    321c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    321e:	eb 81       	ldd	r30, Y+3	; 0x03
    3220:	fc 81       	ldd	r31, Y+4	; 0x04
    3222:	80 81       	ld	r24, Z
    3224:	8f 5f       	subi	r24, 0xFF	; 255
    3226:	eb 81       	ldd	r30, Y+3	; 0x03
    3228:	fc 81       	ldd	r31, Y+4	; 0x04
    322a:	80 83       	st	Z, r24
}
    322c:	26 96       	adiw	r28, 0x06	; 6
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	cf 91       	pop	r28
    323a:	df 91       	pop	r29
    323c:	08 95       	ret

0000323e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    323e:	df 93       	push	r29
    3240:	cf 93       	push	r28
    3242:	cd b7       	in	r28, 0x3d	; 61
    3244:	de b7       	in	r29, 0x3e	; 62
    3246:	28 97       	sbiw	r28, 0x08	; 8
    3248:	0f b6       	in	r0, 0x3f	; 63
    324a:	f8 94       	cli
    324c:	de bf       	out	0x3e, r29	; 62
    324e:	0f be       	out	0x3f, r0	; 63
    3250:	cd bf       	out	0x3d, r28	; 61
    3252:	9e 83       	std	Y+6, r25	; 0x06
    3254:	8d 83       	std	Y+5, r24	; 0x05
    3256:	78 87       	std	Y+8, r23	; 0x08
    3258:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    325a:	ef 81       	ldd	r30, Y+7	; 0x07
    325c:	f8 85       	ldd	r31, Y+8	; 0x08
    325e:	80 81       	ld	r24, Z
    3260:	91 81       	ldd	r25, Z+1	; 0x01
    3262:	9a 83       	std	Y+2, r25	; 0x02
    3264:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3266:	89 81       	ldd	r24, Y+1	; 0x01
    3268:	9a 81       	ldd	r25, Y+2	; 0x02
    326a:	2f ef       	ldi	r18, 0xFF	; 255
    326c:	8f 3f       	cpi	r24, 0xFF	; 255
    326e:	92 07       	cpc	r25, r18
    3270:	39 f4       	brne	.+14     	; 0x3280 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3272:	ed 81       	ldd	r30, Y+5	; 0x05
    3274:	fe 81       	ldd	r31, Y+6	; 0x06
    3276:	87 81       	ldd	r24, Z+7	; 0x07
    3278:	90 85       	ldd	r25, Z+8	; 0x08
    327a:	9c 83       	std	Y+4, r25	; 0x04
    327c:	8b 83       	std	Y+3, r24	; 0x03
    327e:	18 c0       	rjmp	.+48     	; 0x32b0 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    3280:	8d 81       	ldd	r24, Y+5	; 0x05
    3282:	9e 81       	ldd	r25, Y+6	; 0x06
    3284:	03 96       	adiw	r24, 0x03	; 3
    3286:	9c 83       	std	Y+4, r25	; 0x04
    3288:	8b 83       	std	Y+3, r24	; 0x03
    328a:	06 c0       	rjmp	.+12     	; 0x3298 <vListInsert+0x5a>
    328c:	eb 81       	ldd	r30, Y+3	; 0x03
    328e:	fc 81       	ldd	r31, Y+4	; 0x04
    3290:	82 81       	ldd	r24, Z+2	; 0x02
    3292:	93 81       	ldd	r25, Z+3	; 0x03
    3294:	9c 83       	std	Y+4, r25	; 0x04
    3296:	8b 83       	std	Y+3, r24	; 0x03
    3298:	eb 81       	ldd	r30, Y+3	; 0x03
    329a:	fc 81       	ldd	r31, Y+4	; 0x04
    329c:	02 80       	ldd	r0, Z+2	; 0x02
    329e:	f3 81       	ldd	r31, Z+3	; 0x03
    32a0:	e0 2d       	mov	r30, r0
    32a2:	20 81       	ld	r18, Z
    32a4:	31 81       	ldd	r19, Z+1	; 0x01
    32a6:	89 81       	ldd	r24, Y+1	; 0x01
    32a8:	9a 81       	ldd	r25, Y+2	; 0x02
    32aa:	82 17       	cp	r24, r18
    32ac:	93 07       	cpc	r25, r19
    32ae:	70 f7       	brcc	.-36     	; 0x328c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    32b0:	eb 81       	ldd	r30, Y+3	; 0x03
    32b2:	fc 81       	ldd	r31, Y+4	; 0x04
    32b4:	82 81       	ldd	r24, Z+2	; 0x02
    32b6:	93 81       	ldd	r25, Z+3	; 0x03
    32b8:	ef 81       	ldd	r30, Y+7	; 0x07
    32ba:	f8 85       	ldd	r31, Y+8	; 0x08
    32bc:	93 83       	std	Z+3, r25	; 0x03
    32be:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    32c0:	ef 81       	ldd	r30, Y+7	; 0x07
    32c2:	f8 85       	ldd	r31, Y+8	; 0x08
    32c4:	02 80       	ldd	r0, Z+2	; 0x02
    32c6:	f3 81       	ldd	r31, Z+3	; 0x03
    32c8:	e0 2d       	mov	r30, r0
    32ca:	8f 81       	ldd	r24, Y+7	; 0x07
    32cc:	98 85       	ldd	r25, Y+8	; 0x08
    32ce:	95 83       	std	Z+5, r25	; 0x05
    32d0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    32d2:	ef 81       	ldd	r30, Y+7	; 0x07
    32d4:	f8 85       	ldd	r31, Y+8	; 0x08
    32d6:	8b 81       	ldd	r24, Y+3	; 0x03
    32d8:	9c 81       	ldd	r25, Y+4	; 0x04
    32da:	95 83       	std	Z+5, r25	; 0x05
    32dc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    32de:	8f 81       	ldd	r24, Y+7	; 0x07
    32e0:	98 85       	ldd	r25, Y+8	; 0x08
    32e2:	eb 81       	ldd	r30, Y+3	; 0x03
    32e4:	fc 81       	ldd	r31, Y+4	; 0x04
    32e6:	93 83       	std	Z+3, r25	; 0x03
    32e8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    32ea:	ef 81       	ldd	r30, Y+7	; 0x07
    32ec:	f8 85       	ldd	r31, Y+8	; 0x08
    32ee:	8d 81       	ldd	r24, Y+5	; 0x05
    32f0:	9e 81       	ldd	r25, Y+6	; 0x06
    32f2:	91 87       	std	Z+9, r25	; 0x09
    32f4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    32f6:	ed 81       	ldd	r30, Y+5	; 0x05
    32f8:	fe 81       	ldd	r31, Y+6	; 0x06
    32fa:	80 81       	ld	r24, Z
    32fc:	8f 5f       	subi	r24, 0xFF	; 255
    32fe:	ed 81       	ldd	r30, Y+5	; 0x05
    3300:	fe 81       	ldd	r31, Y+6	; 0x06
    3302:	80 83       	st	Z, r24
}
    3304:	28 96       	adiw	r28, 0x08	; 8
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	de bf       	out	0x3e, r29	; 62
    330c:	0f be       	out	0x3f, r0	; 63
    330e:	cd bf       	out	0x3d, r28	; 61
    3310:	cf 91       	pop	r28
    3312:	df 91       	pop	r29
    3314:	08 95       	ret

00003316 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    3316:	df 93       	push	r29
    3318:	cf 93       	push	r28
    331a:	00 d0       	rcall	.+0      	; 0x331c <vListRemove+0x6>
    331c:	00 d0       	rcall	.+0      	; 0x331e <vListRemove+0x8>
    331e:	cd b7       	in	r28, 0x3d	; 61
    3320:	de b7       	in	r29, 0x3e	; 62
    3322:	9c 83       	std	Y+4, r25	; 0x04
    3324:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3326:	eb 81       	ldd	r30, Y+3	; 0x03
    3328:	fc 81       	ldd	r31, Y+4	; 0x04
    332a:	a2 81       	ldd	r26, Z+2	; 0x02
    332c:	b3 81       	ldd	r27, Z+3	; 0x03
    332e:	eb 81       	ldd	r30, Y+3	; 0x03
    3330:	fc 81       	ldd	r31, Y+4	; 0x04
    3332:	84 81       	ldd	r24, Z+4	; 0x04
    3334:	95 81       	ldd	r25, Z+5	; 0x05
    3336:	15 96       	adiw	r26, 0x05	; 5
    3338:	9c 93       	st	X, r25
    333a:	8e 93       	st	-X, r24
    333c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    333e:	eb 81       	ldd	r30, Y+3	; 0x03
    3340:	fc 81       	ldd	r31, Y+4	; 0x04
    3342:	a4 81       	ldd	r26, Z+4	; 0x04
    3344:	b5 81       	ldd	r27, Z+5	; 0x05
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	82 81       	ldd	r24, Z+2	; 0x02
    334c:	93 81       	ldd	r25, Z+3	; 0x03
    334e:	13 96       	adiw	r26, 0x03	; 3
    3350:	9c 93       	st	X, r25
    3352:	8e 93       	st	-X, r24
    3354:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3356:	eb 81       	ldd	r30, Y+3	; 0x03
    3358:	fc 81       	ldd	r31, Y+4	; 0x04
    335a:	80 85       	ldd	r24, Z+8	; 0x08
    335c:	91 85       	ldd	r25, Z+9	; 0x09
    335e:	9a 83       	std	Y+2, r25	; 0x02
    3360:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3362:	e9 81       	ldd	r30, Y+1	; 0x01
    3364:	fa 81       	ldd	r31, Y+2	; 0x02
    3366:	21 81       	ldd	r18, Z+1	; 0x01
    3368:	32 81       	ldd	r19, Z+2	; 0x02
    336a:	8b 81       	ldd	r24, Y+3	; 0x03
    336c:	9c 81       	ldd	r25, Y+4	; 0x04
    336e:	28 17       	cp	r18, r24
    3370:	39 07       	cpc	r19, r25
    3372:	41 f4       	brne	.+16     	; 0x3384 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3374:	eb 81       	ldd	r30, Y+3	; 0x03
    3376:	fc 81       	ldd	r31, Y+4	; 0x04
    3378:	84 81       	ldd	r24, Z+4	; 0x04
    337a:	95 81       	ldd	r25, Z+5	; 0x05
    337c:	e9 81       	ldd	r30, Y+1	; 0x01
    337e:	fa 81       	ldd	r31, Y+2	; 0x02
    3380:	92 83       	std	Z+2, r25	; 0x02
    3382:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    3384:	eb 81       	ldd	r30, Y+3	; 0x03
    3386:	fc 81       	ldd	r31, Y+4	; 0x04
    3388:	11 86       	std	Z+9, r1	; 0x09
    338a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    338c:	e9 81       	ldd	r30, Y+1	; 0x01
    338e:	fa 81       	ldd	r31, Y+2	; 0x02
    3390:	80 81       	ld	r24, Z
    3392:	81 50       	subi	r24, 0x01	; 1
    3394:	e9 81       	ldd	r30, Y+1	; 0x01
    3396:	fa 81       	ldd	r31, Y+2	; 0x02
    3398:	80 83       	st	Z, r24
}
    339a:	0f 90       	pop	r0
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	0f 90       	pop	r0
    33a2:	cf 91       	pop	r28
    33a4:	df 91       	pop	r29
    33a6:	08 95       	ret

000033a8 <main>:
#include "PWM.h"
#include"avr/delay.h"


void main(void)
{
    33a8:	df 93       	push	r29
    33aa:	cf 93       	push	r28
    33ac:	cd b7       	in	r28, 0x3d	; 61
    33ae:	de b7       	in	r29, 0x3e	; 62
    33b0:	c8 59       	subi	r28, 0x98	; 152
    33b2:	d0 40       	sbci	r29, 0x00	; 0
    33b4:	0f b6       	in	r0, 0x3f	; 63
    33b6:	f8 94       	cli
    33b8:	de bf       	out	0x3e, r29	; 62
    33ba:	0f be       	out	0x3f, r0	; 63
    33bc:	cd bf       	out	0x3d, r28	; 61
	xTaskCreate(yaw_controller,"yaw", configMINIMAL_STACK_SIZE, &parameter, 3, NULL);
	xTaskCreate(roll_pitch,"roll&pitch", configMINIMAL_STACK_SIZE, &parameter, 4, NULL);
	xTaskCreate(body_rates,"body_rates", configMINIMAL_STACK_SIZE, &parameter, 5, NULL);

*/
	ARM_Motors();
    33be:	0e 94 03 0c 	call	0x1806	; 0x1806 <ARM_Motors>
    33c2:	ff cf       	rjmp	.-2      	; 0x33c2 <main+0x1a>

000033c4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    33c4:	df 93       	push	r29
    33c6:	cf 93       	push	r28
    33c8:	cd b7       	in	r28, 0x3d	; 61
    33ca:	de b7       	in	r29, 0x3e	; 62
    33cc:	28 97       	sbiw	r28, 0x08	; 8
    33ce:	0f b6       	in	r0, 0x3f	; 63
    33d0:	f8 94       	cli
    33d2:	de bf       	out	0x3e, r29	; 62
    33d4:	0f be       	out	0x3f, r0	; 63
    33d6:	cd bf       	out	0x3d, r28	; 61
    33d8:	9c 83       	std	Y+4, r25	; 0x04
    33da:	8b 83       	std	Y+3, r24	; 0x03
    33dc:	7e 83       	std	Y+6, r23	; 0x06
    33de:	6d 83       	std	Y+5, r22	; 0x05
    33e0:	58 87       	std	Y+8, r21	; 0x08
    33e2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    33e4:	eb 81       	ldd	r30, Y+3	; 0x03
    33e6:	fc 81       	ldd	r31, Y+4	; 0x04
    33e8:	81 e1       	ldi	r24, 0x11	; 17
    33ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    33ec:	8b 81       	ldd	r24, Y+3	; 0x03
    33ee:	9c 81       	ldd	r25, Y+4	; 0x04
    33f0:	01 97       	sbiw	r24, 0x01	; 1
    33f2:	9c 83       	std	Y+4, r25	; 0x04
    33f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    33f6:	eb 81       	ldd	r30, Y+3	; 0x03
    33f8:	fc 81       	ldd	r31, Y+4	; 0x04
    33fa:	82 e2       	ldi	r24, 0x22	; 34
    33fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    33fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3400:	9c 81       	ldd	r25, Y+4	; 0x04
    3402:	01 97       	sbiw	r24, 0x01	; 1
    3404:	9c 83       	std	Y+4, r25	; 0x04
    3406:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3408:	eb 81       	ldd	r30, Y+3	; 0x03
    340a:	fc 81       	ldd	r31, Y+4	; 0x04
    340c:	83 e3       	ldi	r24, 0x33	; 51
    340e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3410:	8b 81       	ldd	r24, Y+3	; 0x03
    3412:	9c 81       	ldd	r25, Y+4	; 0x04
    3414:	01 97       	sbiw	r24, 0x01	; 1
    3416:	9c 83       	std	Y+4, r25	; 0x04
    3418:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    341a:	8d 81       	ldd	r24, Y+5	; 0x05
    341c:	9e 81       	ldd	r25, Y+6	; 0x06
    341e:	9a 83       	std	Y+2, r25	; 0x02
    3420:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3422:	89 81       	ldd	r24, Y+1	; 0x01
    3424:	eb 81       	ldd	r30, Y+3	; 0x03
    3426:	fc 81       	ldd	r31, Y+4	; 0x04
    3428:	80 83       	st	Z, r24
	pxTopOfStack--;
    342a:	8b 81       	ldd	r24, Y+3	; 0x03
    342c:	9c 81       	ldd	r25, Y+4	; 0x04
    342e:	01 97       	sbiw	r24, 0x01	; 1
    3430:	9c 83       	std	Y+4, r25	; 0x04
    3432:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3434:	89 81       	ldd	r24, Y+1	; 0x01
    3436:	9a 81       	ldd	r25, Y+2	; 0x02
    3438:	89 2f       	mov	r24, r25
    343a:	99 27       	eor	r25, r25
    343c:	9a 83       	std	Y+2, r25	; 0x02
    343e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3440:	89 81       	ldd	r24, Y+1	; 0x01
    3442:	eb 81       	ldd	r30, Y+3	; 0x03
    3444:	fc 81       	ldd	r31, Y+4	; 0x04
    3446:	80 83       	st	Z, r24
	pxTopOfStack--;
    3448:	8b 81       	ldd	r24, Y+3	; 0x03
    344a:	9c 81       	ldd	r25, Y+4	; 0x04
    344c:	01 97       	sbiw	r24, 0x01	; 1
    344e:	9c 83       	std	Y+4, r25	; 0x04
    3450:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    3452:	eb 81       	ldd	r30, Y+3	; 0x03
    3454:	fc 81       	ldd	r31, Y+4	; 0x04
    3456:	10 82       	st	Z, r1
	pxTopOfStack--;
    3458:	8b 81       	ldd	r24, Y+3	; 0x03
    345a:	9c 81       	ldd	r25, Y+4	; 0x04
    345c:	01 97       	sbiw	r24, 0x01	; 1
    345e:	9c 83       	std	Y+4, r25	; 0x04
    3460:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3462:	eb 81       	ldd	r30, Y+3	; 0x03
    3464:	fc 81       	ldd	r31, Y+4	; 0x04
    3466:	80 e8       	ldi	r24, 0x80	; 128
    3468:	80 83       	st	Z, r24
	pxTopOfStack--;
    346a:	8b 81       	ldd	r24, Y+3	; 0x03
    346c:	9c 81       	ldd	r25, Y+4	; 0x04
    346e:	01 97       	sbiw	r24, 0x01	; 1
    3470:	9c 83       	std	Y+4, r25	; 0x04
    3472:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3474:	eb 81       	ldd	r30, Y+3	; 0x03
    3476:	fc 81       	ldd	r31, Y+4	; 0x04
    3478:	10 82       	st	Z, r1
	pxTopOfStack--;
    347a:	8b 81       	ldd	r24, Y+3	; 0x03
    347c:	9c 81       	ldd	r25, Y+4	; 0x04
    347e:	01 97       	sbiw	r24, 0x01	; 1
    3480:	9c 83       	std	Y+4, r25	; 0x04
    3482:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3484:	eb 81       	ldd	r30, Y+3	; 0x03
    3486:	fc 81       	ldd	r31, Y+4	; 0x04
    3488:	82 e0       	ldi	r24, 0x02	; 2
    348a:	80 83       	st	Z, r24
	pxTopOfStack--;
    348c:	8b 81       	ldd	r24, Y+3	; 0x03
    348e:	9c 81       	ldd	r25, Y+4	; 0x04
    3490:	01 97       	sbiw	r24, 0x01	; 1
    3492:	9c 83       	std	Y+4, r25	; 0x04
    3494:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3496:	eb 81       	ldd	r30, Y+3	; 0x03
    3498:	fc 81       	ldd	r31, Y+4	; 0x04
    349a:	83 e0       	ldi	r24, 0x03	; 3
    349c:	80 83       	st	Z, r24
	pxTopOfStack--;
    349e:	8b 81       	ldd	r24, Y+3	; 0x03
    34a0:	9c 81       	ldd	r25, Y+4	; 0x04
    34a2:	01 97       	sbiw	r24, 0x01	; 1
    34a4:	9c 83       	std	Y+4, r25	; 0x04
    34a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    34a8:	eb 81       	ldd	r30, Y+3	; 0x03
    34aa:	fc 81       	ldd	r31, Y+4	; 0x04
    34ac:	84 e0       	ldi	r24, 0x04	; 4
    34ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    34b0:	8b 81       	ldd	r24, Y+3	; 0x03
    34b2:	9c 81       	ldd	r25, Y+4	; 0x04
    34b4:	01 97       	sbiw	r24, 0x01	; 1
    34b6:	9c 83       	std	Y+4, r25	; 0x04
    34b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    34ba:	eb 81       	ldd	r30, Y+3	; 0x03
    34bc:	fc 81       	ldd	r31, Y+4	; 0x04
    34be:	85 e0       	ldi	r24, 0x05	; 5
    34c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34c2:	8b 81       	ldd	r24, Y+3	; 0x03
    34c4:	9c 81       	ldd	r25, Y+4	; 0x04
    34c6:	01 97       	sbiw	r24, 0x01	; 1
    34c8:	9c 83       	std	Y+4, r25	; 0x04
    34ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    34cc:	eb 81       	ldd	r30, Y+3	; 0x03
    34ce:	fc 81       	ldd	r31, Y+4	; 0x04
    34d0:	86 e0       	ldi	r24, 0x06	; 6
    34d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    34d4:	8b 81       	ldd	r24, Y+3	; 0x03
    34d6:	9c 81       	ldd	r25, Y+4	; 0x04
    34d8:	01 97       	sbiw	r24, 0x01	; 1
    34da:	9c 83       	std	Y+4, r25	; 0x04
    34dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    34de:	eb 81       	ldd	r30, Y+3	; 0x03
    34e0:	fc 81       	ldd	r31, Y+4	; 0x04
    34e2:	87 e0       	ldi	r24, 0x07	; 7
    34e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    34e6:	8b 81       	ldd	r24, Y+3	; 0x03
    34e8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ea:	01 97       	sbiw	r24, 0x01	; 1
    34ec:	9c 83       	std	Y+4, r25	; 0x04
    34ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    34f0:	eb 81       	ldd	r30, Y+3	; 0x03
    34f2:	fc 81       	ldd	r31, Y+4	; 0x04
    34f4:	88 e0       	ldi	r24, 0x08	; 8
    34f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    34f8:	8b 81       	ldd	r24, Y+3	; 0x03
    34fa:	9c 81       	ldd	r25, Y+4	; 0x04
    34fc:	01 97       	sbiw	r24, 0x01	; 1
    34fe:	9c 83       	std	Y+4, r25	; 0x04
    3500:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3502:	eb 81       	ldd	r30, Y+3	; 0x03
    3504:	fc 81       	ldd	r31, Y+4	; 0x04
    3506:	89 e0       	ldi	r24, 0x09	; 9
    3508:	80 83       	st	Z, r24
	pxTopOfStack--;
    350a:	8b 81       	ldd	r24, Y+3	; 0x03
    350c:	9c 81       	ldd	r25, Y+4	; 0x04
    350e:	01 97       	sbiw	r24, 0x01	; 1
    3510:	9c 83       	std	Y+4, r25	; 0x04
    3512:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3514:	eb 81       	ldd	r30, Y+3	; 0x03
    3516:	fc 81       	ldd	r31, Y+4	; 0x04
    3518:	80 e1       	ldi	r24, 0x10	; 16
    351a:	80 83       	st	Z, r24
	pxTopOfStack--;
    351c:	8b 81       	ldd	r24, Y+3	; 0x03
    351e:	9c 81       	ldd	r25, Y+4	; 0x04
    3520:	01 97       	sbiw	r24, 0x01	; 1
    3522:	9c 83       	std	Y+4, r25	; 0x04
    3524:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3526:	eb 81       	ldd	r30, Y+3	; 0x03
    3528:	fc 81       	ldd	r31, Y+4	; 0x04
    352a:	81 e1       	ldi	r24, 0x11	; 17
    352c:	80 83       	st	Z, r24
	pxTopOfStack--;
    352e:	8b 81       	ldd	r24, Y+3	; 0x03
    3530:	9c 81       	ldd	r25, Y+4	; 0x04
    3532:	01 97       	sbiw	r24, 0x01	; 1
    3534:	9c 83       	std	Y+4, r25	; 0x04
    3536:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3538:	eb 81       	ldd	r30, Y+3	; 0x03
    353a:	fc 81       	ldd	r31, Y+4	; 0x04
    353c:	82 e1       	ldi	r24, 0x12	; 18
    353e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3540:	8b 81       	ldd	r24, Y+3	; 0x03
    3542:	9c 81       	ldd	r25, Y+4	; 0x04
    3544:	01 97       	sbiw	r24, 0x01	; 1
    3546:	9c 83       	std	Y+4, r25	; 0x04
    3548:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    354a:	eb 81       	ldd	r30, Y+3	; 0x03
    354c:	fc 81       	ldd	r31, Y+4	; 0x04
    354e:	83 e1       	ldi	r24, 0x13	; 19
    3550:	80 83       	st	Z, r24
	pxTopOfStack--;
    3552:	8b 81       	ldd	r24, Y+3	; 0x03
    3554:	9c 81       	ldd	r25, Y+4	; 0x04
    3556:	01 97       	sbiw	r24, 0x01	; 1
    3558:	9c 83       	std	Y+4, r25	; 0x04
    355a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    355c:	eb 81       	ldd	r30, Y+3	; 0x03
    355e:	fc 81       	ldd	r31, Y+4	; 0x04
    3560:	84 e1       	ldi	r24, 0x14	; 20
    3562:	80 83       	st	Z, r24
	pxTopOfStack--;
    3564:	8b 81       	ldd	r24, Y+3	; 0x03
    3566:	9c 81       	ldd	r25, Y+4	; 0x04
    3568:	01 97       	sbiw	r24, 0x01	; 1
    356a:	9c 83       	std	Y+4, r25	; 0x04
    356c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    356e:	eb 81       	ldd	r30, Y+3	; 0x03
    3570:	fc 81       	ldd	r31, Y+4	; 0x04
    3572:	85 e1       	ldi	r24, 0x15	; 21
    3574:	80 83       	st	Z, r24
	pxTopOfStack--;
    3576:	8b 81       	ldd	r24, Y+3	; 0x03
    3578:	9c 81       	ldd	r25, Y+4	; 0x04
    357a:	01 97       	sbiw	r24, 0x01	; 1
    357c:	9c 83       	std	Y+4, r25	; 0x04
    357e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3580:	eb 81       	ldd	r30, Y+3	; 0x03
    3582:	fc 81       	ldd	r31, Y+4	; 0x04
    3584:	86 e1       	ldi	r24, 0x16	; 22
    3586:	80 83       	st	Z, r24
	pxTopOfStack--;
    3588:	8b 81       	ldd	r24, Y+3	; 0x03
    358a:	9c 81       	ldd	r25, Y+4	; 0x04
    358c:	01 97       	sbiw	r24, 0x01	; 1
    358e:	9c 83       	std	Y+4, r25	; 0x04
    3590:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3592:	eb 81       	ldd	r30, Y+3	; 0x03
    3594:	fc 81       	ldd	r31, Y+4	; 0x04
    3596:	87 e1       	ldi	r24, 0x17	; 23
    3598:	80 83       	st	Z, r24
	pxTopOfStack--;
    359a:	8b 81       	ldd	r24, Y+3	; 0x03
    359c:	9c 81       	ldd	r25, Y+4	; 0x04
    359e:	01 97       	sbiw	r24, 0x01	; 1
    35a0:	9c 83       	std	Y+4, r25	; 0x04
    35a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    35a4:	eb 81       	ldd	r30, Y+3	; 0x03
    35a6:	fc 81       	ldd	r31, Y+4	; 0x04
    35a8:	88 e1       	ldi	r24, 0x18	; 24
    35aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    35ac:	8b 81       	ldd	r24, Y+3	; 0x03
    35ae:	9c 81       	ldd	r25, Y+4	; 0x04
    35b0:	01 97       	sbiw	r24, 0x01	; 1
    35b2:	9c 83       	std	Y+4, r25	; 0x04
    35b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    35b6:	eb 81       	ldd	r30, Y+3	; 0x03
    35b8:	fc 81       	ldd	r31, Y+4	; 0x04
    35ba:	89 e1       	ldi	r24, 0x19	; 25
    35bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    35be:	8b 81       	ldd	r24, Y+3	; 0x03
    35c0:	9c 81       	ldd	r25, Y+4	; 0x04
    35c2:	01 97       	sbiw	r24, 0x01	; 1
    35c4:	9c 83       	std	Y+4, r25	; 0x04
    35c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    35c8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ca:	fc 81       	ldd	r31, Y+4	; 0x04
    35cc:	80 e2       	ldi	r24, 0x20	; 32
    35ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    35d0:	8b 81       	ldd	r24, Y+3	; 0x03
    35d2:	9c 81       	ldd	r25, Y+4	; 0x04
    35d4:	01 97       	sbiw	r24, 0x01	; 1
    35d6:	9c 83       	std	Y+4, r25	; 0x04
    35d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    35da:	eb 81       	ldd	r30, Y+3	; 0x03
    35dc:	fc 81       	ldd	r31, Y+4	; 0x04
    35de:	81 e2       	ldi	r24, 0x21	; 33
    35e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    35e2:	8b 81       	ldd	r24, Y+3	; 0x03
    35e4:	9c 81       	ldd	r25, Y+4	; 0x04
    35e6:	01 97       	sbiw	r24, 0x01	; 1
    35e8:	9c 83       	std	Y+4, r25	; 0x04
    35ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    35ec:	eb 81       	ldd	r30, Y+3	; 0x03
    35ee:	fc 81       	ldd	r31, Y+4	; 0x04
    35f0:	82 e2       	ldi	r24, 0x22	; 34
    35f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    35f4:	8b 81       	ldd	r24, Y+3	; 0x03
    35f6:	9c 81       	ldd	r25, Y+4	; 0x04
    35f8:	01 97       	sbiw	r24, 0x01	; 1
    35fa:	9c 83       	std	Y+4, r25	; 0x04
    35fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    35fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3600:	fc 81       	ldd	r31, Y+4	; 0x04
    3602:	83 e2       	ldi	r24, 0x23	; 35
    3604:	80 83       	st	Z, r24
	pxTopOfStack--;
    3606:	8b 81       	ldd	r24, Y+3	; 0x03
    3608:	9c 81       	ldd	r25, Y+4	; 0x04
    360a:	01 97       	sbiw	r24, 0x01	; 1
    360c:	9c 83       	std	Y+4, r25	; 0x04
    360e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    3610:	8f 81       	ldd	r24, Y+7	; 0x07
    3612:	98 85       	ldd	r25, Y+8	; 0x08
    3614:	9a 83       	std	Y+2, r25	; 0x02
    3616:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3618:	89 81       	ldd	r24, Y+1	; 0x01
    361a:	eb 81       	ldd	r30, Y+3	; 0x03
    361c:	fc 81       	ldd	r31, Y+4	; 0x04
    361e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3620:	8b 81       	ldd	r24, Y+3	; 0x03
    3622:	9c 81       	ldd	r25, Y+4	; 0x04
    3624:	01 97       	sbiw	r24, 0x01	; 1
    3626:	9c 83       	std	Y+4, r25	; 0x04
    3628:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    362a:	89 81       	ldd	r24, Y+1	; 0x01
    362c:	9a 81       	ldd	r25, Y+2	; 0x02
    362e:	89 2f       	mov	r24, r25
    3630:	99 27       	eor	r25, r25
    3632:	9a 83       	std	Y+2, r25	; 0x02
    3634:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3636:	89 81       	ldd	r24, Y+1	; 0x01
    3638:	eb 81       	ldd	r30, Y+3	; 0x03
    363a:	fc 81       	ldd	r31, Y+4	; 0x04
    363c:	80 83       	st	Z, r24
	pxTopOfStack--;
    363e:	8b 81       	ldd	r24, Y+3	; 0x03
    3640:	9c 81       	ldd	r25, Y+4	; 0x04
    3642:	01 97       	sbiw	r24, 0x01	; 1
    3644:	9c 83       	std	Y+4, r25	; 0x04
    3646:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3648:	eb 81       	ldd	r30, Y+3	; 0x03
    364a:	fc 81       	ldd	r31, Y+4	; 0x04
    364c:	86 e2       	ldi	r24, 0x26	; 38
    364e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3650:	8b 81       	ldd	r24, Y+3	; 0x03
    3652:	9c 81       	ldd	r25, Y+4	; 0x04
    3654:	01 97       	sbiw	r24, 0x01	; 1
    3656:	9c 83       	std	Y+4, r25	; 0x04
    3658:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    365a:	eb 81       	ldd	r30, Y+3	; 0x03
    365c:	fc 81       	ldd	r31, Y+4	; 0x04
    365e:	87 e2       	ldi	r24, 0x27	; 39
    3660:	80 83       	st	Z, r24
	pxTopOfStack--;
    3662:	8b 81       	ldd	r24, Y+3	; 0x03
    3664:	9c 81       	ldd	r25, Y+4	; 0x04
    3666:	01 97       	sbiw	r24, 0x01	; 1
    3668:	9c 83       	std	Y+4, r25	; 0x04
    366a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    366c:	eb 81       	ldd	r30, Y+3	; 0x03
    366e:	fc 81       	ldd	r31, Y+4	; 0x04
    3670:	88 e2       	ldi	r24, 0x28	; 40
    3672:	80 83       	st	Z, r24
	pxTopOfStack--;
    3674:	8b 81       	ldd	r24, Y+3	; 0x03
    3676:	9c 81       	ldd	r25, Y+4	; 0x04
    3678:	01 97       	sbiw	r24, 0x01	; 1
    367a:	9c 83       	std	Y+4, r25	; 0x04
    367c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    367e:	eb 81       	ldd	r30, Y+3	; 0x03
    3680:	fc 81       	ldd	r31, Y+4	; 0x04
    3682:	89 e2       	ldi	r24, 0x29	; 41
    3684:	80 83       	st	Z, r24
	pxTopOfStack--;
    3686:	8b 81       	ldd	r24, Y+3	; 0x03
    3688:	9c 81       	ldd	r25, Y+4	; 0x04
    368a:	01 97       	sbiw	r24, 0x01	; 1
    368c:	9c 83       	std	Y+4, r25	; 0x04
    368e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3690:	eb 81       	ldd	r30, Y+3	; 0x03
    3692:	fc 81       	ldd	r31, Y+4	; 0x04
    3694:	80 e3       	ldi	r24, 0x30	; 48
    3696:	80 83       	st	Z, r24
	pxTopOfStack--;
    3698:	8b 81       	ldd	r24, Y+3	; 0x03
    369a:	9c 81       	ldd	r25, Y+4	; 0x04
    369c:	01 97       	sbiw	r24, 0x01	; 1
    369e:	9c 83       	std	Y+4, r25	; 0x04
    36a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    36a2:	eb 81       	ldd	r30, Y+3	; 0x03
    36a4:	fc 81       	ldd	r31, Y+4	; 0x04
    36a6:	81 e3       	ldi	r24, 0x31	; 49
    36a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    36aa:	8b 81       	ldd	r24, Y+3	; 0x03
    36ac:	9c 81       	ldd	r25, Y+4	; 0x04
    36ae:	01 97       	sbiw	r24, 0x01	; 1
    36b0:	9c 83       	std	Y+4, r25	; 0x04
    36b2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    36b4:	8b 81       	ldd	r24, Y+3	; 0x03
    36b6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    36b8:	28 96       	adiw	r28, 0x08	; 8
    36ba:	0f b6       	in	r0, 0x3f	; 63
    36bc:	f8 94       	cli
    36be:	de bf       	out	0x3e, r29	; 62
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	cd bf       	out	0x3d, r28	; 61
    36c4:	cf 91       	pop	r28
    36c6:	df 91       	pop	r29
    36c8:	08 95       	ret

000036ca <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    36ca:	df 93       	push	r29
    36cc:	cf 93       	push	r28
    36ce:	cd b7       	in	r28, 0x3d	; 61
    36d0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    36d2:	0e 94 55 1c 	call	0x38aa	; 0x38aa <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    36d6:	a0 91 a4 03 	lds	r26, 0x03A4
    36da:	b0 91 a5 03 	lds	r27, 0x03A5
    36de:	cd 91       	ld	r28, X+
    36e0:	cd bf       	out	0x3d, r28	; 61
    36e2:	dd 91       	ld	r29, X+
    36e4:	de bf       	out	0x3e, r29	; 62
    36e6:	ff 91       	pop	r31
    36e8:	ef 91       	pop	r30
    36ea:	df 91       	pop	r29
    36ec:	cf 91       	pop	r28
    36ee:	bf 91       	pop	r27
    36f0:	af 91       	pop	r26
    36f2:	9f 91       	pop	r25
    36f4:	8f 91       	pop	r24
    36f6:	7f 91       	pop	r23
    36f8:	6f 91       	pop	r22
    36fa:	5f 91       	pop	r21
    36fc:	4f 91       	pop	r20
    36fe:	3f 91       	pop	r19
    3700:	2f 91       	pop	r18
    3702:	1f 91       	pop	r17
    3704:	0f 91       	pop	r16
    3706:	ff 90       	pop	r15
    3708:	ef 90       	pop	r14
    370a:	df 90       	pop	r13
    370c:	cf 90       	pop	r12
    370e:	bf 90       	pop	r11
    3710:	af 90       	pop	r10
    3712:	9f 90       	pop	r9
    3714:	8f 90       	pop	r8
    3716:	7f 90       	pop	r7
    3718:	6f 90       	pop	r6
    371a:	5f 90       	pop	r5
    371c:	4f 90       	pop	r4
    371e:	3f 90       	pop	r3
    3720:	2f 90       	pop	r2
    3722:	1f 90       	pop	r1
    3724:	0f 90       	pop	r0
    3726:	0f be       	out	0x3f, r0	; 63
    3728:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    372a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    372c:	81 e0       	ldi	r24, 0x01	; 1
}
    372e:	cf 91       	pop	r28
    3730:	df 91       	pop	r29
    3732:	08 95       	ret

00003734 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3734:	df 93       	push	r29
    3736:	cf 93       	push	r28
    3738:	cd b7       	in	r28, 0x3d	; 61
    373a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    373c:	cf 91       	pop	r28
    373e:	df 91       	pop	r29
    3740:	08 95       	ret

00003742 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3742:	0f 92       	push	r0
    3744:	0f b6       	in	r0, 0x3f	; 63
    3746:	f8 94       	cli
    3748:	0f 92       	push	r0
    374a:	1f 92       	push	r1
    374c:	11 24       	eor	r1, r1
    374e:	2f 92       	push	r2
    3750:	3f 92       	push	r3
    3752:	4f 92       	push	r4
    3754:	5f 92       	push	r5
    3756:	6f 92       	push	r6
    3758:	7f 92       	push	r7
    375a:	8f 92       	push	r8
    375c:	9f 92       	push	r9
    375e:	af 92       	push	r10
    3760:	bf 92       	push	r11
    3762:	cf 92       	push	r12
    3764:	df 92       	push	r13
    3766:	ef 92       	push	r14
    3768:	ff 92       	push	r15
    376a:	0f 93       	push	r16
    376c:	1f 93       	push	r17
    376e:	2f 93       	push	r18
    3770:	3f 93       	push	r19
    3772:	4f 93       	push	r20
    3774:	5f 93       	push	r21
    3776:	6f 93       	push	r22
    3778:	7f 93       	push	r23
    377a:	8f 93       	push	r24
    377c:	9f 93       	push	r25
    377e:	af 93       	push	r26
    3780:	bf 93       	push	r27
    3782:	cf 93       	push	r28
    3784:	df 93       	push	r29
    3786:	ef 93       	push	r30
    3788:	ff 93       	push	r31
    378a:	a0 91 a4 03 	lds	r26, 0x03A4
    378e:	b0 91 a5 03 	lds	r27, 0x03A5
    3792:	0d b6       	in	r0, 0x3d	; 61
    3794:	0d 92       	st	X+, r0
    3796:	0e b6       	in	r0, 0x3e	; 62
    3798:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    379a:	0e 94 40 29 	call	0x5280	; 0x5280 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    379e:	a0 91 a4 03 	lds	r26, 0x03A4
    37a2:	b0 91 a5 03 	lds	r27, 0x03A5
    37a6:	cd 91       	ld	r28, X+
    37a8:	cd bf       	out	0x3d, r28	; 61
    37aa:	dd 91       	ld	r29, X+
    37ac:	de bf       	out	0x3e, r29	; 62
    37ae:	ff 91       	pop	r31
    37b0:	ef 91       	pop	r30
    37b2:	df 91       	pop	r29
    37b4:	cf 91       	pop	r28
    37b6:	bf 91       	pop	r27
    37b8:	af 91       	pop	r26
    37ba:	9f 91       	pop	r25
    37bc:	8f 91       	pop	r24
    37be:	7f 91       	pop	r23
    37c0:	6f 91       	pop	r22
    37c2:	5f 91       	pop	r21
    37c4:	4f 91       	pop	r20
    37c6:	3f 91       	pop	r19
    37c8:	2f 91       	pop	r18
    37ca:	1f 91       	pop	r17
    37cc:	0f 91       	pop	r16
    37ce:	ff 90       	pop	r15
    37d0:	ef 90       	pop	r14
    37d2:	df 90       	pop	r13
    37d4:	cf 90       	pop	r12
    37d6:	bf 90       	pop	r11
    37d8:	af 90       	pop	r10
    37da:	9f 90       	pop	r9
    37dc:	8f 90       	pop	r8
    37de:	7f 90       	pop	r7
    37e0:	6f 90       	pop	r6
    37e2:	5f 90       	pop	r5
    37e4:	4f 90       	pop	r4
    37e6:	3f 90       	pop	r3
    37e8:	2f 90       	pop	r2
    37ea:	1f 90       	pop	r1
    37ec:	0f 90       	pop	r0
    37ee:	0f be       	out	0x3f, r0	; 63
    37f0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    37f2:	08 95       	ret

000037f4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    37f4:	0f 92       	push	r0
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	0f 92       	push	r0
    37fc:	1f 92       	push	r1
    37fe:	11 24       	eor	r1, r1
    3800:	2f 92       	push	r2
    3802:	3f 92       	push	r3
    3804:	4f 92       	push	r4
    3806:	5f 92       	push	r5
    3808:	6f 92       	push	r6
    380a:	7f 92       	push	r7
    380c:	8f 92       	push	r8
    380e:	9f 92       	push	r9
    3810:	af 92       	push	r10
    3812:	bf 92       	push	r11
    3814:	cf 92       	push	r12
    3816:	df 92       	push	r13
    3818:	ef 92       	push	r14
    381a:	ff 92       	push	r15
    381c:	0f 93       	push	r16
    381e:	1f 93       	push	r17
    3820:	2f 93       	push	r18
    3822:	3f 93       	push	r19
    3824:	4f 93       	push	r20
    3826:	5f 93       	push	r21
    3828:	6f 93       	push	r22
    382a:	7f 93       	push	r23
    382c:	8f 93       	push	r24
    382e:	9f 93       	push	r25
    3830:	af 93       	push	r26
    3832:	bf 93       	push	r27
    3834:	cf 93       	push	r28
    3836:	df 93       	push	r29
    3838:	ef 93       	push	r30
    383a:	ff 93       	push	r31
    383c:	a0 91 a4 03 	lds	r26, 0x03A4
    3840:	b0 91 a5 03 	lds	r27, 0x03A5
    3844:	0d b6       	in	r0, 0x3d	; 61
    3846:	0d 92       	st	X+, r0
    3848:	0e b6       	in	r0, 0x3e	; 62
    384a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    384c:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskIncrementTick>
	vTaskSwitchContext();
    3850:	0e 94 40 29 	call	0x5280	; 0x5280 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3854:	a0 91 a4 03 	lds	r26, 0x03A4
    3858:	b0 91 a5 03 	lds	r27, 0x03A5
    385c:	cd 91       	ld	r28, X+
    385e:	cd bf       	out	0x3d, r28	; 61
    3860:	dd 91       	ld	r29, X+
    3862:	de bf       	out	0x3e, r29	; 62
    3864:	ff 91       	pop	r31
    3866:	ef 91       	pop	r30
    3868:	df 91       	pop	r29
    386a:	cf 91       	pop	r28
    386c:	bf 91       	pop	r27
    386e:	af 91       	pop	r26
    3870:	9f 91       	pop	r25
    3872:	8f 91       	pop	r24
    3874:	7f 91       	pop	r23
    3876:	6f 91       	pop	r22
    3878:	5f 91       	pop	r21
    387a:	4f 91       	pop	r20
    387c:	3f 91       	pop	r19
    387e:	2f 91       	pop	r18
    3880:	1f 91       	pop	r17
    3882:	0f 91       	pop	r16
    3884:	ff 90       	pop	r15
    3886:	ef 90       	pop	r14
    3888:	df 90       	pop	r13
    388a:	cf 90       	pop	r12
    388c:	bf 90       	pop	r11
    388e:	af 90       	pop	r10
    3890:	9f 90       	pop	r9
    3892:	8f 90       	pop	r8
    3894:	7f 90       	pop	r7
    3896:	6f 90       	pop	r6
    3898:	5f 90       	pop	r5
    389a:	4f 90       	pop	r4
    389c:	3f 90       	pop	r3
    389e:	2f 90       	pop	r2
    38a0:	1f 90       	pop	r1
    38a2:	0f 90       	pop	r0
    38a4:	0f be       	out	0x3f, r0	; 63
    38a6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    38a8:	08 95       	ret

000038aa <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    38aa:	df 93       	push	r29
    38ac:	cf 93       	push	r28
    38ae:	00 d0       	rcall	.+0      	; 0x38b0 <prvSetupTimerInterrupt+0x6>
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <prvSetupTimerInterrupt+0x8>
    38b2:	00 d0       	rcall	.+0      	; 0x38b4 <prvSetupTimerInterrupt+0xa>
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    38b8:	80 ee       	ldi	r24, 0xE0	; 224
    38ba:	9e e2       	ldi	r25, 0x2E	; 46
    38bc:	a0 e0       	ldi	r26, 0x00	; 0
    38be:	b0 e0       	ldi	r27, 0x00	; 0
    38c0:	8b 83       	std	Y+3, r24	; 0x03
    38c2:	9c 83       	std	Y+4, r25	; 0x04
    38c4:	ad 83       	std	Y+5, r26	; 0x05
    38c6:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    38c8:	8b 81       	ldd	r24, Y+3	; 0x03
    38ca:	9c 81       	ldd	r25, Y+4	; 0x04
    38cc:	ad 81       	ldd	r26, Y+5	; 0x05
    38ce:	be 81       	ldd	r27, Y+6	; 0x06
    38d0:	68 94       	set
    38d2:	15 f8       	bld	r1, 5
    38d4:	b6 95       	lsr	r27
    38d6:	a7 95       	ror	r26
    38d8:	97 95       	ror	r25
    38da:	87 95       	ror	r24
    38dc:	16 94       	lsr	r1
    38de:	d1 f7       	brne	.-12     	; 0x38d4 <prvSetupTimerInterrupt+0x2a>
    38e0:	8b 83       	std	Y+3, r24	; 0x03
    38e2:	9c 83       	std	Y+4, r25	; 0x04
    38e4:	ad 83       	std	Y+5, r26	; 0x05
    38e6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    38e8:	8b 81       	ldd	r24, Y+3	; 0x03
    38ea:	9c 81       	ldd	r25, Y+4	; 0x04
    38ec:	ad 81       	ldd	r26, Y+5	; 0x05
    38ee:	be 81       	ldd	r27, Y+6	; 0x06
    38f0:	01 97       	sbiw	r24, 0x01	; 1
    38f2:	a1 09       	sbc	r26, r1
    38f4:	b1 09       	sbc	r27, r1
    38f6:	8b 83       	std	Y+3, r24	; 0x03
    38f8:	9c 83       	std	Y+4, r25	; 0x04
    38fa:	ad 83       	std	Y+5, r26	; 0x05
    38fc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    38fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3900:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3902:	8b 81       	ldd	r24, Y+3	; 0x03
    3904:	9c 81       	ldd	r25, Y+4	; 0x04
    3906:	ad 81       	ldd	r26, Y+5	; 0x05
    3908:	be 81       	ldd	r27, Y+6	; 0x06
    390a:	89 2f       	mov	r24, r25
    390c:	9a 2f       	mov	r25, r26
    390e:	ab 2f       	mov	r26, r27
    3910:	bb 27       	eor	r27, r27
    3912:	8b 83       	std	Y+3, r24	; 0x03
    3914:	9c 83       	std	Y+4, r25	; 0x04
    3916:	ad 83       	std	Y+5, r26	; 0x05
    3918:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    391e:	eb e4       	ldi	r30, 0x4B	; 75
    3920:	f0 e0       	ldi	r31, 0x00	; 0
    3922:	8a 81       	ldd	r24, Y+2	; 0x02
    3924:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3926:	ea e4       	ldi	r30, 0x4A	; 74
    3928:	f0 e0       	ldi	r31, 0x00	; 0
    392a:	89 81       	ldd	r24, Y+1	; 0x01
    392c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    392e:	8b e0       	ldi	r24, 0x0B	; 11
    3930:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3932:	ee e4       	ldi	r30, 0x4E	; 78
    3934:	f0 e0       	ldi	r31, 0x00	; 0
    3936:	89 81       	ldd	r24, Y+1	; 0x01
    3938:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    393a:	e7 e5       	ldi	r30, 0x57	; 87
    393c:	f0 e0       	ldi	r31, 0x00	; 0
    393e:	80 81       	ld	r24, Z
    3940:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3942:	89 81       	ldd	r24, Y+1	; 0x01
    3944:	80 61       	ori	r24, 0x10	; 16
    3946:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3948:	e7 e5       	ldi	r30, 0x57	; 87
    394a:	f0 e0       	ldi	r31, 0x00	; 0
    394c:	89 81       	ldd	r24, Y+1	; 0x01
    394e:	80 83       	st	Z, r24
}
    3950:	26 96       	adiw	r28, 0x06	; 6
    3952:	0f b6       	in	r0, 0x3f	; 63
    3954:	f8 94       	cli
    3956:	de bf       	out	0x3e, r29	; 62
    3958:	0f be       	out	0x3f, r0	; 63
    395a:	cd bf       	out	0x3d, r28	; 61
    395c:	cf 91       	pop	r28
    395e:	df 91       	pop	r29
    3960:	08 95       	ret

00003962 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3962:	0e 94 fa 1b 	call	0x37f4	; 0x37f4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3966:	18 95       	reti

00003968 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3968:	df 93       	push	r29
    396a:	cf 93       	push	r28
    396c:	cd b7       	in	r28, 0x3d	; 61
    396e:	de b7       	in	r29, 0x3e	; 62
    3970:	28 97       	sbiw	r28, 0x08	; 8
    3972:	0f b6       	in	r0, 0x3f	; 63
    3974:	f8 94       	cli
    3976:	de bf       	out	0x3e, r29	; 62
    3978:	0f be       	out	0x3f, r0	; 63
    397a:	cd bf       	out	0x3d, r28	; 61
    397c:	8f 83       	std	Y+7, r24	; 0x07
    397e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3980:	1a 82       	std	Y+2, r1	; 0x02
    3982:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3984:	8f 81       	ldd	r24, Y+7	; 0x07
    3986:	88 23       	and	r24, r24
    3988:	09 f4       	brne	.+2      	; 0x398c <xQueueCreate+0x24>
    398a:	8c c0       	rjmp	.+280    	; 0x3aa4 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    398c:	8f e1       	ldi	r24, 0x1F	; 31
    398e:	90 e0       	ldi	r25, 0x00	; 0
    3990:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <pvPortMalloc>
    3994:	9e 83       	std	Y+6, r25	; 0x06
    3996:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3998:	8d 81       	ldd	r24, Y+5	; 0x05
    399a:	9e 81       	ldd	r25, Y+6	; 0x06
    399c:	00 97       	sbiw	r24, 0x00	; 0
    399e:	09 f4       	brne	.+2      	; 0x39a2 <xQueueCreate+0x3a>
    39a0:	81 c0       	rjmp	.+258    	; 0x3aa4 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    39a2:	8f 81       	ldd	r24, Y+7	; 0x07
    39a4:	28 2f       	mov	r18, r24
    39a6:	30 e0       	ldi	r19, 0x00	; 0
    39a8:	88 85       	ldd	r24, Y+8	; 0x08
    39aa:	88 2f       	mov	r24, r24
    39ac:	90 e0       	ldi	r25, 0x00	; 0
    39ae:	ac 01       	movw	r20, r24
    39b0:	24 9f       	mul	r18, r20
    39b2:	c0 01       	movw	r24, r0
    39b4:	25 9f       	mul	r18, r21
    39b6:	90 0d       	add	r25, r0
    39b8:	34 9f       	mul	r19, r20
    39ba:	90 0d       	add	r25, r0
    39bc:	11 24       	eor	r1, r1
    39be:	01 96       	adiw	r24, 0x01	; 1
    39c0:	9c 83       	std	Y+4, r25	; 0x04
    39c2:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    39c4:	8b 81       	ldd	r24, Y+3	; 0x03
    39c6:	9c 81       	ldd	r25, Y+4	; 0x04
    39c8:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <pvPortMalloc>
    39cc:	ed 81       	ldd	r30, Y+5	; 0x05
    39ce:	fe 81       	ldd	r31, Y+6	; 0x06
    39d0:	91 83       	std	Z+1, r25	; 0x01
    39d2:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    39d4:	ed 81       	ldd	r30, Y+5	; 0x05
    39d6:	fe 81       	ldd	r31, Y+6	; 0x06
    39d8:	80 81       	ld	r24, Z
    39da:	91 81       	ldd	r25, Z+1	; 0x01
    39dc:	00 97       	sbiw	r24, 0x00	; 0
    39de:	09 f4       	brne	.+2      	; 0x39e2 <xQueueCreate+0x7a>
    39e0:	5d c0       	rjmp	.+186    	; 0x3a9c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    39e2:	ed 81       	ldd	r30, Y+5	; 0x05
    39e4:	fe 81       	ldd	r31, Y+6	; 0x06
    39e6:	40 81       	ld	r20, Z
    39e8:	51 81       	ldd	r21, Z+1	; 0x01
    39ea:	8f 81       	ldd	r24, Y+7	; 0x07
    39ec:	28 2f       	mov	r18, r24
    39ee:	30 e0       	ldi	r19, 0x00	; 0
    39f0:	88 85       	ldd	r24, Y+8	; 0x08
    39f2:	88 2f       	mov	r24, r24
    39f4:	90 e0       	ldi	r25, 0x00	; 0
    39f6:	bc 01       	movw	r22, r24
    39f8:	26 9f       	mul	r18, r22
    39fa:	c0 01       	movw	r24, r0
    39fc:	27 9f       	mul	r18, r23
    39fe:	90 0d       	add	r25, r0
    3a00:	36 9f       	mul	r19, r22
    3a02:	90 0d       	add	r25, r0
    3a04:	11 24       	eor	r1, r1
    3a06:	84 0f       	add	r24, r20
    3a08:	95 1f       	adc	r25, r21
    3a0a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a0c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a0e:	93 83       	std	Z+3, r25	; 0x03
    3a10:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3a12:	ed 81       	ldd	r30, Y+5	; 0x05
    3a14:	fe 81       	ldd	r31, Y+6	; 0x06
    3a16:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3a18:	ed 81       	ldd	r30, Y+5	; 0x05
    3a1a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a1c:	80 81       	ld	r24, Z
    3a1e:	91 81       	ldd	r25, Z+1	; 0x01
    3a20:	ed 81       	ldd	r30, Y+5	; 0x05
    3a22:	fe 81       	ldd	r31, Y+6	; 0x06
    3a24:	95 83       	std	Z+5, r25	; 0x05
    3a26:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3a28:	ed 81       	ldd	r30, Y+5	; 0x05
    3a2a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a2c:	40 81       	ld	r20, Z
    3a2e:	51 81       	ldd	r21, Z+1	; 0x01
    3a30:	8f 81       	ldd	r24, Y+7	; 0x07
    3a32:	88 2f       	mov	r24, r24
    3a34:	90 e0       	ldi	r25, 0x00	; 0
    3a36:	9c 01       	movw	r18, r24
    3a38:	21 50       	subi	r18, 0x01	; 1
    3a3a:	30 40       	sbci	r19, 0x00	; 0
    3a3c:	88 85       	ldd	r24, Y+8	; 0x08
    3a3e:	88 2f       	mov	r24, r24
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	bc 01       	movw	r22, r24
    3a44:	26 9f       	mul	r18, r22
    3a46:	c0 01       	movw	r24, r0
    3a48:	27 9f       	mul	r18, r23
    3a4a:	90 0d       	add	r25, r0
    3a4c:	36 9f       	mul	r19, r22
    3a4e:	90 0d       	add	r25, r0
    3a50:	11 24       	eor	r1, r1
    3a52:	84 0f       	add	r24, r20
    3a54:	95 1f       	adc	r25, r21
    3a56:	ed 81       	ldd	r30, Y+5	; 0x05
    3a58:	fe 81       	ldd	r31, Y+6	; 0x06
    3a5a:	97 83       	std	Z+7, r25	; 0x07
    3a5c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3a5e:	ed 81       	ldd	r30, Y+5	; 0x05
    3a60:	fe 81       	ldd	r31, Y+6	; 0x06
    3a62:	8f 81       	ldd	r24, Y+7	; 0x07
    3a64:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3a66:	ed 81       	ldd	r30, Y+5	; 0x05
    3a68:	fe 81       	ldd	r31, Y+6	; 0x06
    3a6a:	88 85       	ldd	r24, Y+8	; 0x08
    3a6c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3a6e:	ed 81       	ldd	r30, Y+5	; 0x05
    3a70:	fe 81       	ldd	r31, Y+6	; 0x06
    3a72:	8f ef       	ldi	r24, 0xFF	; 255
    3a74:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3a76:	ed 81       	ldd	r30, Y+5	; 0x05
    3a78:	fe 81       	ldd	r31, Y+6	; 0x06
    3a7a:	8f ef       	ldi	r24, 0xFF	; 255
    3a7c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3a7e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a80:	9e 81       	ldd	r25, Y+6	; 0x06
    3a82:	08 96       	adiw	r24, 0x08	; 8
    3a84:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3a88:	8d 81       	ldd	r24, Y+5	; 0x05
    3a8a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a8c:	41 96       	adiw	r24, 0x11	; 17
    3a8e:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3a92:	8d 81       	ldd	r24, Y+5	; 0x05
    3a94:	9e 81       	ldd	r25, Y+6	; 0x06
    3a96:	9a 83       	std	Y+2, r25	; 0x02
    3a98:	89 83       	std	Y+1, r24	; 0x01
    3a9a:	04 c0       	rjmp	.+8      	; 0x3aa4 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3a9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3aa0:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3aa8:	28 96       	adiw	r28, 0x08	; 8
    3aaa:	0f b6       	in	r0, 0x3f	; 63
    3aac:	f8 94       	cli
    3aae:	de bf       	out	0x3e, r29	; 62
    3ab0:	0f be       	out	0x3f, r0	; 63
    3ab2:	cd bf       	out	0x3d, r28	; 61
    3ab4:	cf 91       	pop	r28
    3ab6:	df 91       	pop	r29
    3ab8:	08 95       	ret

00003aba <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3aba:	df 93       	push	r29
    3abc:	cf 93       	push	r28
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62
    3ac2:	2c 97       	sbiw	r28, 0x0c	; 12
    3ac4:	0f b6       	in	r0, 0x3f	; 63
    3ac6:	f8 94       	cli
    3ac8:	de bf       	out	0x3e, r29	; 62
    3aca:	0f be       	out	0x3f, r0	; 63
    3acc:	cd bf       	out	0x3d, r28	; 61
    3ace:	9e 83       	std	Y+6, r25	; 0x06
    3ad0:	8d 83       	std	Y+5, r24	; 0x05
    3ad2:	78 87       	std	Y+8, r23	; 0x08
    3ad4:	6f 83       	std	Y+7, r22	; 0x07
    3ad6:	5a 87       	std	Y+10, r21	; 0x0a
    3ad8:	49 87       	std	Y+9, r20	; 0x09
    3ada:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3adc:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3ade:	0f b6       	in	r0, 0x3f	; 63
    3ae0:	f8 94       	cli
    3ae2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3ae4:	ed 81       	ldd	r30, Y+5	; 0x05
    3ae6:	fe 81       	ldd	r31, Y+6	; 0x06
    3ae8:	92 8d       	ldd	r25, Z+26	; 0x1a
    3aea:	ed 81       	ldd	r30, Y+5	; 0x05
    3aec:	fe 81       	ldd	r31, Y+6	; 0x06
    3aee:	83 8d       	ldd	r24, Z+27	; 0x1b
    3af0:	98 17       	cp	r25, r24
    3af2:	d8 f4       	brcc	.+54     	; 0x3b2a <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3af4:	8d 81       	ldd	r24, Y+5	; 0x05
    3af6:	9e 81       	ldd	r25, Y+6	; 0x06
    3af8:	2f 81       	ldd	r18, Y+7	; 0x07
    3afa:	38 85       	ldd	r19, Y+8	; 0x08
    3afc:	b9 01       	movw	r22, r18
    3afe:	4b 85       	ldd	r20, Y+11	; 0x0b
    3b00:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b04:	ed 81       	ldd	r30, Y+5	; 0x05
    3b06:	fe 81       	ldd	r31, Y+6	; 0x06
    3b08:	81 89       	ldd	r24, Z+17	; 0x11
    3b0a:	88 23       	and	r24, r24
    3b0c:	49 f0       	breq	.+18     	; 0x3b20 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b10:	9e 81       	ldd	r25, Y+6	; 0x06
    3b12:	41 96       	adiw	r24, 0x11	; 17
    3b14:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    3b18:	81 30       	cpi	r24, 0x01	; 1
    3b1a:	11 f4       	brne	.+4      	; 0x3b20 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3b1c:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3b20:	0f 90       	pop	r0
    3b22:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3b24:	81 e0       	ldi	r24, 0x01	; 1
    3b26:	8c 87       	std	Y+12, r24	; 0x0c
    3b28:	5c c0       	rjmp	.+184    	; 0x3be2 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3b2a:	89 85       	ldd	r24, Y+9	; 0x09
    3b2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b2e:	00 97       	sbiw	r24, 0x00	; 0
    3b30:	21 f4       	brne	.+8      	; 0x3b3a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3b32:	0f 90       	pop	r0
    3b34:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3b36:	1c 86       	std	Y+12, r1	; 0x0c
    3b38:	54 c0       	rjmp	.+168    	; 0x3be2 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3b3a:	89 81       	ldd	r24, Y+1	; 0x01
    3b3c:	88 23       	and	r24, r24
    3b3e:	31 f4       	brne	.+12     	; 0x3b4c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3b40:	ce 01       	movw	r24, r28
    3b42:	02 96       	adiw	r24, 0x02	; 2
    3b44:	0e 94 44 2a 	call	0x5488	; 0x5488 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3b48:	81 e0       	ldi	r24, 0x01	; 1
    3b4a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3b4c:	0f 90       	pop	r0
    3b4e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3b50:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	0f 92       	push	r0
    3b5a:	ed 81       	ldd	r30, Y+5	; 0x05
    3b5c:	fe 81       	ldd	r31, Y+6	; 0x06
    3b5e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b60:	8f 3f       	cpi	r24, 0xFF	; 255
    3b62:	19 f4       	brne	.+6      	; 0x3b6a <xQueueGenericSend+0xb0>
    3b64:	ed 81       	ldd	r30, Y+5	; 0x05
    3b66:	fe 81       	ldd	r31, Y+6	; 0x06
    3b68:	15 8e       	std	Z+29, r1	; 0x1d
    3b6a:	ed 81       	ldd	r30, Y+5	; 0x05
    3b6c:	fe 81       	ldd	r31, Y+6	; 0x06
    3b6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b70:	8f 3f       	cpi	r24, 0xFF	; 255
    3b72:	19 f4       	brne	.+6      	; 0x3b7a <xQueueGenericSend+0xc0>
    3b74:	ed 81       	ldd	r30, Y+5	; 0x05
    3b76:	fe 81       	ldd	r31, Y+6	; 0x06
    3b78:	16 8e       	std	Z+30, r1	; 0x1e
    3b7a:	0f 90       	pop	r0
    3b7c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b7e:	ce 01       	movw	r24, r28
    3b80:	02 96       	adiw	r24, 0x02	; 2
    3b82:	9e 01       	movw	r18, r28
    3b84:	27 5f       	subi	r18, 0xF7	; 247
    3b86:	3f 4f       	sbci	r19, 0xFF	; 255
    3b88:	b9 01       	movw	r22, r18
    3b8a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <xTaskCheckForTimeOut>
    3b8e:	88 23       	and	r24, r24
    3b90:	09 f5       	brne	.+66     	; 0x3bd4 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3b92:	8d 81       	ldd	r24, Y+5	; 0x05
    3b94:	9e 81       	ldd	r25, Y+6	; 0x06
    3b96:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <prvIsQueueFull>
    3b9a:	88 23       	and	r24, r24
    3b9c:	a1 f0       	breq	.+40     	; 0x3bc6 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3b9e:	8d 81       	ldd	r24, Y+5	; 0x05
    3ba0:	9e 81       	ldd	r25, Y+6	; 0x06
    3ba2:	08 96       	adiw	r24, 0x08	; 8
    3ba4:	29 85       	ldd	r18, Y+9	; 0x09
    3ba6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ba8:	b9 01       	movw	r22, r18
    3baa:	0e 94 a6 29 	call	0x534c	; 0x534c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3bae:	8d 81       	ldd	r24, Y+5	; 0x05
    3bb0:	9e 81       	ldd	r25, Y+6	; 0x06
    3bb2:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3bb6:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    3bba:	88 23       	and	r24, r24
    3bbc:	09 f0       	breq	.+2      	; 0x3bc0 <xQueueGenericSend+0x106>
    3bbe:	8f cf       	rjmp	.-226    	; 0x3ade <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3bc0:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
    3bc4:	8c cf       	rjmp	.-232    	; 0x3ade <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    3bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    3bca:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3bce:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    3bd2:	85 cf       	rjmp	.-246    	; 0x3ade <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3bd4:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd6:	9e 81       	ldd	r25, Y+6	; 0x06
    3bd8:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3bdc:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3be0:	1c 86       	std	Y+12, r1	; 0x0c
    3be2:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3be4:	2c 96       	adiw	r28, 0x0c	; 12
    3be6:	0f b6       	in	r0, 0x3f	; 63
    3be8:	f8 94       	cli
    3bea:	de bf       	out	0x3e, r29	; 62
    3bec:	0f be       	out	0x3f, r0	; 63
    3bee:	cd bf       	out	0x3d, r28	; 61
    3bf0:	cf 91       	pop	r28
    3bf2:	df 91       	pop	r29
    3bf4:	08 95       	ret

00003bf6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3bf6:	df 93       	push	r29
    3bf8:	cf 93       	push	r28
    3bfa:	cd b7       	in	r28, 0x3d	; 61
    3bfc:	de b7       	in	r29, 0x3e	; 62
    3bfe:	29 97       	sbiw	r28, 0x09	; 9
    3c00:	0f b6       	in	r0, 0x3f	; 63
    3c02:	f8 94       	cli
    3c04:	de bf       	out	0x3e, r29	; 62
    3c06:	0f be       	out	0x3f, r0	; 63
    3c08:	cd bf       	out	0x3d, r28	; 61
    3c0a:	9c 83       	std	Y+4, r25	; 0x04
    3c0c:	8b 83       	std	Y+3, r24	; 0x03
    3c0e:	7e 83       	std	Y+6, r23	; 0x06
    3c10:	6d 83       	std	Y+5, r22	; 0x05
    3c12:	58 87       	std	Y+8, r21	; 0x08
    3c14:	4f 83       	std	Y+7, r20	; 0x07
    3c16:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c18:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c1e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c20:	eb 81       	ldd	r30, Y+3	; 0x03
    3c22:	fc 81       	ldd	r31, Y+4	; 0x04
    3c24:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c26:	98 17       	cp	r25, r24
    3c28:	40 f5       	brcc	.+80     	; 0x3c7a <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c2e:	2d 81       	ldd	r18, Y+5	; 0x05
    3c30:	3e 81       	ldd	r19, Y+6	; 0x06
    3c32:	b9 01       	movw	r22, r18
    3c34:	49 85       	ldd	r20, Y+9	; 0x09
    3c36:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3c3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c40:	8f 3f       	cpi	r24, 0xFF	; 255
    3c42:	89 f4       	brne	.+34     	; 0x3c66 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3c44:	eb 81       	ldd	r30, Y+3	; 0x03
    3c46:	fc 81       	ldd	r31, Y+4	; 0x04
    3c48:	81 89       	ldd	r24, Z+17	; 0x11
    3c4a:	88 23       	and	r24, r24
    3c4c:	99 f0       	breq	.+38     	; 0x3c74 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3c4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c50:	9c 81       	ldd	r25, Y+4	; 0x04
    3c52:	41 96       	adiw	r24, 0x11	; 17
    3c54:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    3c58:	88 23       	and	r24, r24
    3c5a:	61 f0       	breq	.+24     	; 0x3c74 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c5c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c5e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c60:	81 e0       	ldi	r24, 0x01	; 1
    3c62:	80 83       	st	Z, r24
    3c64:	07 c0       	rjmp	.+14     	; 0x3c74 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3c66:	eb 81       	ldd	r30, Y+3	; 0x03
    3c68:	fc 81       	ldd	r31, Y+4	; 0x04
    3c6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c6c:	8f 5f       	subi	r24, 0xFF	; 255
    3c6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c70:	fc 81       	ldd	r31, Y+4	; 0x04
    3c72:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3c74:	81 e0       	ldi	r24, 0x01	; 1
    3c76:	8a 83       	std	Y+2, r24	; 0x02
    3c78:	01 c0       	rjmp	.+2      	; 0x3c7c <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3c7a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c7c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3c7e:	29 96       	adiw	r28, 0x09	; 9
    3c80:	0f b6       	in	r0, 0x3f	; 63
    3c82:	f8 94       	cli
    3c84:	de bf       	out	0x3e, r29	; 62
    3c86:	0f be       	out	0x3f, r0	; 63
    3c88:	cd bf       	out	0x3d, r28	; 61
    3c8a:	cf 91       	pop	r28
    3c8c:	df 91       	pop	r29
    3c8e:	08 95       	ret

00003c90 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3c90:	df 93       	push	r29
    3c92:	cf 93       	push	r28
    3c94:	cd b7       	in	r28, 0x3d	; 61
    3c96:	de b7       	in	r29, 0x3e	; 62
    3c98:	2e 97       	sbiw	r28, 0x0e	; 14
    3c9a:	0f b6       	in	r0, 0x3f	; 63
    3c9c:	f8 94       	cli
    3c9e:	de bf       	out	0x3e, r29	; 62
    3ca0:	0f be       	out	0x3f, r0	; 63
    3ca2:	cd bf       	out	0x3d, r28	; 61
    3ca4:	98 87       	std	Y+8, r25	; 0x08
    3ca6:	8f 83       	std	Y+7, r24	; 0x07
    3ca8:	7a 87       	std	Y+10, r23	; 0x0a
    3caa:	69 87       	std	Y+9, r22	; 0x09
    3cac:	5c 87       	std	Y+12, r21	; 0x0c
    3cae:	4b 87       	std	Y+11, r20	; 0x0b
    3cb0:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3cb2:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3cb4:	0f b6       	in	r0, 0x3f	; 63
    3cb6:	f8 94       	cli
    3cb8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3cba:	ef 81       	ldd	r30, Y+7	; 0x07
    3cbc:	f8 85       	ldd	r31, Y+8	; 0x08
    3cbe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cc0:	88 23       	and	r24, r24
    3cc2:	09 f4       	brne	.+2      	; 0x3cc6 <xQueueGenericReceive+0x36>
    3cc4:	3f c0       	rjmp	.+126    	; 0x3d44 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    3cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cca:	86 81       	ldd	r24, Z+6	; 0x06
    3ccc:	97 81       	ldd	r25, Z+7	; 0x07
    3cce:	9a 83       	std	Y+2, r25	; 0x02
    3cd0:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3cd2:	8f 81       	ldd	r24, Y+7	; 0x07
    3cd4:	98 85       	ldd	r25, Y+8	; 0x08
    3cd6:	29 85       	ldd	r18, Y+9	; 0x09
    3cd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cda:	b9 01       	movw	r22, r18
    3cdc:	0e 94 2d 20 	call	0x405a	; 0x405a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3ce0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ce2:	88 23       	and	r24, r24
    3ce4:	b1 f4       	brne	.+44     	; 0x3d12 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3ce6:	ef 81       	ldd	r30, Y+7	; 0x07
    3ce8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cea:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cec:	81 50       	subi	r24, 0x01	; 1
    3cee:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf0:	f8 85       	ldd	r31, Y+8	; 0x08
    3cf2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3cf4:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf6:	f8 85       	ldd	r31, Y+8	; 0x08
    3cf8:	80 85       	ldd	r24, Z+8	; 0x08
    3cfa:	88 23       	and	r24, r24
    3cfc:	f1 f0       	breq	.+60     	; 0x3d3a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3cfe:	8f 81       	ldd	r24, Y+7	; 0x07
    3d00:	98 85       	ldd	r25, Y+8	; 0x08
    3d02:	08 96       	adiw	r24, 0x08	; 8
    3d04:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    3d08:	81 30       	cpi	r24, 0x01	; 1
    3d0a:	b9 f4       	brne	.+46     	; 0x3d3a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3d0c:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
    3d10:	14 c0       	rjmp	.+40     	; 0x3d3a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3d12:	ef 81       	ldd	r30, Y+7	; 0x07
    3d14:	f8 85       	ldd	r31, Y+8	; 0x08
    3d16:	89 81       	ldd	r24, Y+1	; 0x01
    3d18:	9a 81       	ldd	r25, Y+2	; 0x02
    3d1a:	97 83       	std	Z+7, r25	; 0x07
    3d1c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d1e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d20:	f8 85       	ldd	r31, Y+8	; 0x08
    3d22:	81 89       	ldd	r24, Z+17	; 0x11
    3d24:	88 23       	and	r24, r24
    3d26:	49 f0       	breq	.+18     	; 0x3d3a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d28:	8f 81       	ldd	r24, Y+7	; 0x07
    3d2a:	98 85       	ldd	r25, Y+8	; 0x08
    3d2c:	41 96       	adiw	r24, 0x11	; 17
    3d2e:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    3d32:	88 23       	and	r24, r24
    3d34:	11 f0       	breq	.+4      	; 0x3d3a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3d36:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3d3a:	0f 90       	pop	r0
    3d3c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	8e 87       	std	Y+14, r24	; 0x0e
    3d42:	5c c0       	rjmp	.+184    	; 0x3dfc <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3d44:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d46:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d48:	00 97       	sbiw	r24, 0x00	; 0
    3d4a:	21 f4       	brne	.+8      	; 0x3d54 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3d4c:	0f 90       	pop	r0
    3d4e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3d50:	1e 86       	std	Y+14, r1	; 0x0e
    3d52:	54 c0       	rjmp	.+168    	; 0x3dfc <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3d54:	8b 81       	ldd	r24, Y+3	; 0x03
    3d56:	88 23       	and	r24, r24
    3d58:	31 f4       	brne	.+12     	; 0x3d66 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3d5a:	ce 01       	movw	r24, r28
    3d5c:	04 96       	adiw	r24, 0x04	; 4
    3d5e:	0e 94 44 2a 	call	0x5488	; 0x5488 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3d62:	81 e0       	ldi	r24, 0x01	; 1
    3d64:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3d66:	0f 90       	pop	r0
    3d68:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3d6a:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3d6e:	0f b6       	in	r0, 0x3f	; 63
    3d70:	f8 94       	cli
    3d72:	0f 92       	push	r0
    3d74:	ef 81       	ldd	r30, Y+7	; 0x07
    3d76:	f8 85       	ldd	r31, Y+8	; 0x08
    3d78:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d7a:	8f 3f       	cpi	r24, 0xFF	; 255
    3d7c:	19 f4       	brne	.+6      	; 0x3d84 <xQueueGenericReceive+0xf4>
    3d7e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d80:	f8 85       	ldd	r31, Y+8	; 0x08
    3d82:	15 8e       	std	Z+29, r1	; 0x1d
    3d84:	ef 81       	ldd	r30, Y+7	; 0x07
    3d86:	f8 85       	ldd	r31, Y+8	; 0x08
    3d88:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d8a:	8f 3f       	cpi	r24, 0xFF	; 255
    3d8c:	19 f4       	brne	.+6      	; 0x3d94 <xQueueGenericReceive+0x104>
    3d8e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d90:	f8 85       	ldd	r31, Y+8	; 0x08
    3d92:	16 8e       	std	Z+30, r1	; 0x1e
    3d94:	0f 90       	pop	r0
    3d96:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3d98:	ce 01       	movw	r24, r28
    3d9a:	04 96       	adiw	r24, 0x04	; 4
    3d9c:	9e 01       	movw	r18, r28
    3d9e:	25 5f       	subi	r18, 0xF5	; 245
    3da0:	3f 4f       	sbci	r19, 0xFF	; 255
    3da2:	b9 01       	movw	r22, r18
    3da4:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <xTaskCheckForTimeOut>
    3da8:	88 23       	and	r24, r24
    3daa:	09 f5       	brne	.+66     	; 0x3dee <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3dac:	8f 81       	ldd	r24, Y+7	; 0x07
    3dae:	98 85       	ldd	r25, Y+8	; 0x08
    3db0:	0e 94 c9 20 	call	0x4192	; 0x4192 <prvIsQueueEmpty>
    3db4:	88 23       	and	r24, r24
    3db6:	a1 f0       	breq	.+40     	; 0x3de0 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3db8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dba:	98 85       	ldd	r25, Y+8	; 0x08
    3dbc:	41 96       	adiw	r24, 0x11	; 17
    3dbe:	2b 85       	ldd	r18, Y+11	; 0x0b
    3dc0:	3c 85       	ldd	r19, Y+12	; 0x0c
    3dc2:	b9 01       	movw	r22, r18
    3dc4:	0e 94 a6 29 	call	0x534c	; 0x534c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3dc8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dca:	98 85       	ldd	r25, Y+8	; 0x08
    3dcc:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3dd0:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    3dd4:	88 23       	and	r24, r24
    3dd6:	09 f0       	breq	.+2      	; 0x3dda <xQueueGenericReceive+0x14a>
    3dd8:	6d cf       	rjmp	.-294    	; 0x3cb4 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3dda:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
    3dde:	6a cf       	rjmp	.-300    	; 0x3cb4 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3de0:	8f 81       	ldd	r24, Y+7	; 0x07
    3de2:	98 85       	ldd	r25, Y+8	; 0x08
    3de4:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3de8:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    3dec:	63 cf       	rjmp	.-314    	; 0x3cb4 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3dee:	8f 81       	ldd	r24, Y+7	; 0x07
    3df0:	98 85       	ldd	r25, Y+8	; 0x08
    3df2:	0e 94 75 20 	call	0x40ea	; 0x40ea <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3df6:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3dfa:	1e 86       	std	Y+14, r1	; 0x0e
    3dfc:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3dfe:	2e 96       	adiw	r28, 0x0e	; 14
    3e00:	0f b6       	in	r0, 0x3f	; 63
    3e02:	f8 94       	cli
    3e04:	de bf       	out	0x3e, r29	; 62
    3e06:	0f be       	out	0x3f, r0	; 63
    3e08:	cd bf       	out	0x3d, r28	; 61
    3e0a:	cf 91       	pop	r28
    3e0c:	df 91       	pop	r29
    3e0e:	08 95       	ret

00003e10 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3e10:	df 93       	push	r29
    3e12:	cf 93       	push	r28
    3e14:	cd b7       	in	r28, 0x3d	; 61
    3e16:	de b7       	in	r29, 0x3e	; 62
    3e18:	28 97       	sbiw	r28, 0x08	; 8
    3e1a:	0f b6       	in	r0, 0x3f	; 63
    3e1c:	f8 94       	cli
    3e1e:	de bf       	out	0x3e, r29	; 62
    3e20:	0f be       	out	0x3f, r0	; 63
    3e22:	cd bf       	out	0x3d, r28	; 61
    3e24:	9c 83       	std	Y+4, r25	; 0x04
    3e26:	8b 83       	std	Y+3, r24	; 0x03
    3e28:	7e 83       	std	Y+6, r23	; 0x06
    3e2a:	6d 83       	std	Y+5, r22	; 0x05
    3e2c:	58 87       	std	Y+8, r21	; 0x08
    3e2e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3e30:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3e32:	eb 81       	ldd	r30, Y+3	; 0x03
    3e34:	fc 81       	ldd	r31, Y+4	; 0x04
    3e36:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e38:	88 23       	and	r24, r24
    3e3a:	71 f1       	breq	.+92     	; 0x3e98 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e40:	2d 81       	ldd	r18, Y+5	; 0x05
    3e42:	3e 81       	ldd	r19, Y+6	; 0x06
    3e44:	b9 01       	movw	r22, r18
    3e46:	0e 94 2d 20 	call	0x405a	; 0x405a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e50:	81 50       	subi	r24, 0x01	; 1
    3e52:	eb 81       	ldd	r30, Y+3	; 0x03
    3e54:	fc 81       	ldd	r31, Y+4	; 0x04
    3e56:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3e58:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e5e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e60:	89 f4       	brne	.+34     	; 0x3e84 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e62:	eb 81       	ldd	r30, Y+3	; 0x03
    3e64:	fc 81       	ldd	r31, Y+4	; 0x04
    3e66:	80 85       	ldd	r24, Z+8	; 0x08
    3e68:	88 23       	and	r24, r24
    3e6a:	99 f0       	breq	.+38     	; 0x3e92 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e70:	08 96       	adiw	r24, 0x08	; 8
    3e72:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    3e76:	88 23       	and	r24, r24
    3e78:	61 f0       	breq	.+24     	; 0x3e92 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3e7a:	ef 81       	ldd	r30, Y+7	; 0x07
    3e7c:	f8 85       	ldd	r31, Y+8	; 0x08
    3e7e:	81 e0       	ldi	r24, 0x01	; 1
    3e80:	80 83       	st	Z, r24
    3e82:	07 c0       	rjmp	.+14     	; 0x3e92 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3e84:	eb 81       	ldd	r30, Y+3	; 0x03
    3e86:	fc 81       	ldd	r31, Y+4	; 0x04
    3e88:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e8a:	8f 5f       	subi	r24, 0xFF	; 255
    3e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e90:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3e92:	81 e0       	ldi	r24, 0x01	; 1
    3e94:	8a 83       	std	Y+2, r24	; 0x02
    3e96:	01 c0       	rjmp	.+2      	; 0x3e9a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3e98:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3e9a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3e9c:	28 96       	adiw	r28, 0x08	; 8
    3e9e:	0f b6       	in	r0, 0x3f	; 63
    3ea0:	f8 94       	cli
    3ea2:	de bf       	out	0x3e, r29	; 62
    3ea4:	0f be       	out	0x3f, r0	; 63
    3ea6:	cd bf       	out	0x3d, r28	; 61
    3ea8:	cf 91       	pop	r28
    3eaa:	df 91       	pop	r29
    3eac:	08 95       	ret

00003eae <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3eae:	df 93       	push	r29
    3eb0:	cf 93       	push	r28
    3eb2:	00 d0       	rcall	.+0      	; 0x3eb4 <uxQueueMessagesWaiting+0x6>
    3eb4:	0f 92       	push	r0
    3eb6:	cd b7       	in	r28, 0x3d	; 61
    3eb8:	de b7       	in	r29, 0x3e	; 62
    3eba:	9b 83       	std	Y+3, r25	; 0x03
    3ebc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3ebe:	0f b6       	in	r0, 0x3f	; 63
    3ec0:	f8 94       	cli
    3ec2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3ec4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ec6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ec8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3eca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3ecc:	0f 90       	pop	r0
    3ece:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3ed0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ed2:	0f 90       	pop	r0
    3ed4:	0f 90       	pop	r0
    3ed6:	0f 90       	pop	r0
    3ed8:	cf 91       	pop	r28
    3eda:	df 91       	pop	r29
    3edc:	08 95       	ret

00003ede <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3ede:	df 93       	push	r29
    3ee0:	cf 93       	push	r28
    3ee2:	00 d0       	rcall	.+0      	; 0x3ee4 <uxQueueMessagesWaitingFromISR+0x6>
    3ee4:	0f 92       	push	r0
    3ee6:	cd b7       	in	r28, 0x3d	; 61
    3ee8:	de b7       	in	r29, 0x3e	; 62
    3eea:	9b 83       	std	Y+3, r25	; 0x03
    3eec:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3eee:	ea 81       	ldd	r30, Y+2	; 0x02
    3ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ef2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ef4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3ef6:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ef8:	0f 90       	pop	r0
    3efa:	0f 90       	pop	r0
    3efc:	0f 90       	pop	r0
    3efe:	cf 91       	pop	r28
    3f00:	df 91       	pop	r29
    3f02:	08 95       	ret

00003f04 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3f04:	df 93       	push	r29
    3f06:	cf 93       	push	r28
    3f08:	00 d0       	rcall	.+0      	; 0x3f0a <vQueueDelete+0x6>
    3f0a:	cd b7       	in	r28, 0x3d	; 61
    3f0c:	de b7       	in	r29, 0x3e	; 62
    3f0e:	9a 83       	std	Y+2, r25	; 0x02
    3f10:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3f12:	e9 81       	ldd	r30, Y+1	; 0x01
    3f14:	fa 81       	ldd	r31, Y+2	; 0x02
    3f16:	80 81       	ld	r24, Z
    3f18:	91 81       	ldd	r25, Z+1	; 0x01
    3f1a:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
	vPortFree( pxQueue );
    3f1e:	89 81       	ldd	r24, Y+1	; 0x01
    3f20:	9a 81       	ldd	r25, Y+2	; 0x02
    3f22:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
}
    3f26:	0f 90       	pop	r0
    3f28:	0f 90       	pop	r0
    3f2a:	cf 91       	pop	r28
    3f2c:	df 91       	pop	r29
    3f2e:	08 95       	ret

00003f30 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3f30:	df 93       	push	r29
    3f32:	cf 93       	push	r28
    3f34:	00 d0       	rcall	.+0      	; 0x3f36 <prvCopyDataToQueue+0x6>
    3f36:	00 d0       	rcall	.+0      	; 0x3f38 <prvCopyDataToQueue+0x8>
    3f38:	0f 92       	push	r0
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	9a 83       	std	Y+2, r25	; 0x02
    3f40:	89 83       	std	Y+1, r24	; 0x01
    3f42:	7c 83       	std	Y+4, r23	; 0x04
    3f44:	6b 83       	std	Y+3, r22	; 0x03
    3f46:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3f48:	e9 81       	ldd	r30, Y+1	; 0x01
    3f4a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f4e:	88 23       	and	r24, r24
    3f50:	09 f4       	brne	.+2      	; 0x3f54 <prvCopyDataToQueue+0x24>
    3f52:	74 c0       	rjmp	.+232    	; 0x403c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3f54:	8d 81       	ldd	r24, Y+5	; 0x05
    3f56:	88 23       	and	r24, r24
    3f58:	99 f5       	brne	.+102    	; 0x3fc0 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3f5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f5e:	64 81       	ldd	r22, Z+4	; 0x04
    3f60:	75 81       	ldd	r23, Z+5	; 0x05
    3f62:	e9 81       	ldd	r30, Y+1	; 0x01
    3f64:	fa 81       	ldd	r31, Y+2	; 0x02
    3f66:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f68:	48 2f       	mov	r20, r24
    3f6a:	50 e0       	ldi	r21, 0x00	; 0
    3f6c:	2b 81       	ldd	r18, Y+3	; 0x03
    3f6e:	3c 81       	ldd	r19, Y+4	; 0x04
    3f70:	cb 01       	movw	r24, r22
    3f72:	b9 01       	movw	r22, r18
    3f74:	0e 94 98 2e 	call	0x5d30	; 0x5d30 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3f78:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7c:	24 81       	ldd	r18, Z+4	; 0x04
    3f7e:	35 81       	ldd	r19, Z+5	; 0x05
    3f80:	e9 81       	ldd	r30, Y+1	; 0x01
    3f82:	fa 81       	ldd	r31, Y+2	; 0x02
    3f84:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f86:	88 2f       	mov	r24, r24
    3f88:	90 e0       	ldi	r25, 0x00	; 0
    3f8a:	82 0f       	add	r24, r18
    3f8c:	93 1f       	adc	r25, r19
    3f8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f90:	fa 81       	ldd	r31, Y+2	; 0x02
    3f92:	95 83       	std	Z+5, r25	; 0x05
    3f94:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3f96:	e9 81       	ldd	r30, Y+1	; 0x01
    3f98:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9a:	24 81       	ldd	r18, Z+4	; 0x04
    3f9c:	35 81       	ldd	r19, Z+5	; 0x05
    3f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa2:	82 81       	ldd	r24, Z+2	; 0x02
    3fa4:	93 81       	ldd	r25, Z+3	; 0x03
    3fa6:	28 17       	cp	r18, r24
    3fa8:	39 07       	cpc	r19, r25
    3faa:	08 f4       	brcc	.+2      	; 0x3fae <prvCopyDataToQueue+0x7e>
    3fac:	47 c0       	rjmp	.+142    	; 0x403c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3fae:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb2:	80 81       	ld	r24, Z
    3fb4:	91 81       	ldd	r25, Z+1	; 0x01
    3fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fba:	95 83       	std	Z+5, r25	; 0x05
    3fbc:	84 83       	std	Z+4, r24	; 0x04
    3fbe:	3e c0       	rjmp	.+124    	; 0x403c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc4:	66 81       	ldd	r22, Z+6	; 0x06
    3fc6:	77 81       	ldd	r23, Z+7	; 0x07
    3fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fca:	fa 81       	ldd	r31, Y+2	; 0x02
    3fcc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fce:	48 2f       	mov	r20, r24
    3fd0:	50 e0       	ldi	r21, 0x00	; 0
    3fd2:	2b 81       	ldd	r18, Y+3	; 0x03
    3fd4:	3c 81       	ldd	r19, Y+4	; 0x04
    3fd6:	cb 01       	movw	r24, r22
    3fd8:	b9 01       	movw	r22, r18
    3fda:	0e 94 98 2e 	call	0x5d30	; 0x5d30 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3fde:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe2:	26 81       	ldd	r18, Z+6	; 0x06
    3fe4:	37 81       	ldd	r19, Z+7	; 0x07
    3fe6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fea:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fec:	88 2f       	mov	r24, r24
    3fee:	90 e0       	ldi	r25, 0x00	; 0
    3ff0:	90 95       	com	r25
    3ff2:	81 95       	neg	r24
    3ff4:	9f 4f       	sbci	r25, 0xFF	; 255
    3ff6:	82 0f       	add	r24, r18
    3ff8:	93 1f       	adc	r25, r19
    3ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffe:	97 83       	std	Z+7, r25	; 0x07
    4000:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4002:	e9 81       	ldd	r30, Y+1	; 0x01
    4004:	fa 81       	ldd	r31, Y+2	; 0x02
    4006:	26 81       	ldd	r18, Z+6	; 0x06
    4008:	37 81       	ldd	r19, Z+7	; 0x07
    400a:	e9 81       	ldd	r30, Y+1	; 0x01
    400c:	fa 81       	ldd	r31, Y+2	; 0x02
    400e:	80 81       	ld	r24, Z
    4010:	91 81       	ldd	r25, Z+1	; 0x01
    4012:	28 17       	cp	r18, r24
    4014:	39 07       	cpc	r19, r25
    4016:	90 f4       	brcc	.+36     	; 0x403c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4018:	e9 81       	ldd	r30, Y+1	; 0x01
    401a:	fa 81       	ldd	r31, Y+2	; 0x02
    401c:	22 81       	ldd	r18, Z+2	; 0x02
    401e:	33 81       	ldd	r19, Z+3	; 0x03
    4020:	e9 81       	ldd	r30, Y+1	; 0x01
    4022:	fa 81       	ldd	r31, Y+2	; 0x02
    4024:	84 8d       	ldd	r24, Z+28	; 0x1c
    4026:	88 2f       	mov	r24, r24
    4028:	90 e0       	ldi	r25, 0x00	; 0
    402a:	90 95       	com	r25
    402c:	81 95       	neg	r24
    402e:	9f 4f       	sbci	r25, 0xFF	; 255
    4030:	82 0f       	add	r24, r18
    4032:	93 1f       	adc	r25, r19
    4034:	e9 81       	ldd	r30, Y+1	; 0x01
    4036:	fa 81       	ldd	r31, Y+2	; 0x02
    4038:	97 83       	std	Z+7, r25	; 0x07
    403a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    403c:	e9 81       	ldd	r30, Y+1	; 0x01
    403e:	fa 81       	ldd	r31, Y+2	; 0x02
    4040:	82 8d       	ldd	r24, Z+26	; 0x1a
    4042:	8f 5f       	subi	r24, 0xFF	; 255
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	82 8f       	std	Z+26, r24	; 0x1a
}
    404a:	0f 90       	pop	r0
    404c:	0f 90       	pop	r0
    404e:	0f 90       	pop	r0
    4050:	0f 90       	pop	r0
    4052:	0f 90       	pop	r0
    4054:	cf 91       	pop	r28
    4056:	df 91       	pop	r29
    4058:	08 95       	ret

0000405a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    405a:	df 93       	push	r29
    405c:	cf 93       	push	r28
    405e:	00 d0       	rcall	.+0      	; 0x4060 <prvCopyDataFromQueue+0x6>
    4060:	00 d0       	rcall	.+0      	; 0x4062 <prvCopyDataFromQueue+0x8>
    4062:	cd b7       	in	r28, 0x3d	; 61
    4064:	de b7       	in	r29, 0x3e	; 62
    4066:	9a 83       	std	Y+2, r25	; 0x02
    4068:	89 83       	std	Y+1, r24	; 0x01
    406a:	7c 83       	std	Y+4, r23	; 0x04
    406c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    406e:	e9 81       	ldd	r30, Y+1	; 0x01
    4070:	fa 81       	ldd	r31, Y+2	; 0x02
    4072:	80 81       	ld	r24, Z
    4074:	91 81       	ldd	r25, Z+1	; 0x01
    4076:	00 97       	sbiw	r24, 0x00	; 0
    4078:	89 f1       	breq	.+98     	; 0x40dc <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    407a:	e9 81       	ldd	r30, Y+1	; 0x01
    407c:	fa 81       	ldd	r31, Y+2	; 0x02
    407e:	26 81       	ldd	r18, Z+6	; 0x06
    4080:	37 81       	ldd	r19, Z+7	; 0x07
    4082:	e9 81       	ldd	r30, Y+1	; 0x01
    4084:	fa 81       	ldd	r31, Y+2	; 0x02
    4086:	84 8d       	ldd	r24, Z+28	; 0x1c
    4088:	88 2f       	mov	r24, r24
    408a:	90 e0       	ldi	r25, 0x00	; 0
    408c:	82 0f       	add	r24, r18
    408e:	93 1f       	adc	r25, r19
    4090:	e9 81       	ldd	r30, Y+1	; 0x01
    4092:	fa 81       	ldd	r31, Y+2	; 0x02
    4094:	97 83       	std	Z+7, r25	; 0x07
    4096:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    4098:	e9 81       	ldd	r30, Y+1	; 0x01
    409a:	fa 81       	ldd	r31, Y+2	; 0x02
    409c:	26 81       	ldd	r18, Z+6	; 0x06
    409e:	37 81       	ldd	r19, Z+7	; 0x07
    40a0:	e9 81       	ldd	r30, Y+1	; 0x01
    40a2:	fa 81       	ldd	r31, Y+2	; 0x02
    40a4:	82 81       	ldd	r24, Z+2	; 0x02
    40a6:	93 81       	ldd	r25, Z+3	; 0x03
    40a8:	28 17       	cp	r18, r24
    40aa:	39 07       	cpc	r19, r25
    40ac:	40 f0       	brcs	.+16     	; 0x40be <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    40ae:	e9 81       	ldd	r30, Y+1	; 0x01
    40b0:	fa 81       	ldd	r31, Y+2	; 0x02
    40b2:	80 81       	ld	r24, Z
    40b4:	91 81       	ldd	r25, Z+1	; 0x01
    40b6:	e9 81       	ldd	r30, Y+1	; 0x01
    40b8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ba:	97 83       	std	Z+7, r25	; 0x07
    40bc:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    40be:	e9 81       	ldd	r30, Y+1	; 0x01
    40c0:	fa 81       	ldd	r31, Y+2	; 0x02
    40c2:	46 81       	ldd	r20, Z+6	; 0x06
    40c4:	57 81       	ldd	r21, Z+7	; 0x07
    40c6:	e9 81       	ldd	r30, Y+1	; 0x01
    40c8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    40cc:	28 2f       	mov	r18, r24
    40ce:	30 e0       	ldi	r19, 0x00	; 0
    40d0:	8b 81       	ldd	r24, Y+3	; 0x03
    40d2:	9c 81       	ldd	r25, Y+4	; 0x04
    40d4:	ba 01       	movw	r22, r20
    40d6:	a9 01       	movw	r20, r18
    40d8:	0e 94 98 2e 	call	0x5d30	; 0x5d30 <memcpy>
	}
}
    40dc:	0f 90       	pop	r0
    40de:	0f 90       	pop	r0
    40e0:	0f 90       	pop	r0
    40e2:	0f 90       	pop	r0
    40e4:	cf 91       	pop	r28
    40e6:	df 91       	pop	r29
    40e8:	08 95       	ret

000040ea <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    40ea:	df 93       	push	r29
    40ec:	cf 93       	push	r28
    40ee:	00 d0       	rcall	.+0      	; 0x40f0 <prvUnlockQueue+0x6>
    40f0:	cd b7       	in	r28, 0x3d	; 61
    40f2:	de b7       	in	r29, 0x3e	; 62
    40f4:	9a 83       	std	Y+2, r25	; 0x02
    40f6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    40f8:	0f b6       	in	r0, 0x3f	; 63
    40fa:	f8 94       	cli
    40fc:	0f 92       	push	r0
    40fe:	15 c0       	rjmp	.+42     	; 0x412a <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4100:	e9 81       	ldd	r30, Y+1	; 0x01
    4102:	fa 81       	ldd	r31, Y+2	; 0x02
    4104:	81 89       	ldd	r24, Z+17	; 0x11
    4106:	88 23       	and	r24, r24
    4108:	a9 f0       	breq	.+42     	; 0x4134 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    410a:	89 81       	ldd	r24, Y+1	; 0x01
    410c:	9a 81       	ldd	r25, Y+2	; 0x02
    410e:	41 96       	adiw	r24, 0x11	; 17
    4110:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    4114:	88 23       	and	r24, r24
    4116:	11 f0       	breq	.+4      	; 0x411c <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4118:	0e 94 ba 2a 	call	0x5574	; 0x5574 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    411c:	e9 81       	ldd	r30, Y+1	; 0x01
    411e:	fa 81       	ldd	r31, Y+2	; 0x02
    4120:	86 8d       	ldd	r24, Z+30	; 0x1e
    4122:	81 50       	subi	r24, 0x01	; 1
    4124:	e9 81       	ldd	r30, Y+1	; 0x01
    4126:	fa 81       	ldd	r31, Y+2	; 0x02
    4128:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    412a:	e9 81       	ldd	r30, Y+1	; 0x01
    412c:	fa 81       	ldd	r31, Y+2	; 0x02
    412e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4130:	18 16       	cp	r1, r24
    4132:	34 f3       	brlt	.-52     	; 0x4100 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4134:	e9 81       	ldd	r30, Y+1	; 0x01
    4136:	fa 81       	ldd	r31, Y+2	; 0x02
    4138:	8f ef       	ldi	r24, 0xFF	; 255
    413a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    413c:	0f 90       	pop	r0
    413e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4140:	0f b6       	in	r0, 0x3f	; 63
    4142:	f8 94       	cli
    4144:	0f 92       	push	r0
    4146:	15 c0       	rjmp	.+42     	; 0x4172 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4148:	e9 81       	ldd	r30, Y+1	; 0x01
    414a:	fa 81       	ldd	r31, Y+2	; 0x02
    414c:	80 85       	ldd	r24, Z+8	; 0x08
    414e:	88 23       	and	r24, r24
    4150:	a9 f0       	breq	.+42     	; 0x417c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4152:	89 81       	ldd	r24, Y+1	; 0x01
    4154:	9a 81       	ldd	r25, Y+2	; 0x02
    4156:	08 96       	adiw	r24, 0x08	; 8
    4158:	0e 94 dc 29 	call	0x53b8	; 0x53b8 <xTaskRemoveFromEventList>
    415c:	88 23       	and	r24, r24
    415e:	11 f0       	breq	.+4      	; 0x4164 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4160:	0e 94 ba 2a 	call	0x5574	; 0x5574 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4164:	e9 81       	ldd	r30, Y+1	; 0x01
    4166:	fa 81       	ldd	r31, Y+2	; 0x02
    4168:	85 8d       	ldd	r24, Z+29	; 0x1d
    416a:	81 50       	subi	r24, 0x01	; 1
    416c:	e9 81       	ldd	r30, Y+1	; 0x01
    416e:	fa 81       	ldd	r31, Y+2	; 0x02
    4170:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4172:	e9 81       	ldd	r30, Y+1	; 0x01
    4174:	fa 81       	ldd	r31, Y+2	; 0x02
    4176:	85 8d       	ldd	r24, Z+29	; 0x1d
    4178:	18 16       	cp	r1, r24
    417a:	34 f3       	brlt	.-52     	; 0x4148 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    417c:	e9 81       	ldd	r30, Y+1	; 0x01
    417e:	fa 81       	ldd	r31, Y+2	; 0x02
    4180:	8f ef       	ldi	r24, 0xFF	; 255
    4182:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4184:	0f 90       	pop	r0
    4186:	0f be       	out	0x3f, r0	; 63
}
    4188:	0f 90       	pop	r0
    418a:	0f 90       	pop	r0
    418c:	cf 91       	pop	r28
    418e:	df 91       	pop	r29
    4190:	08 95       	ret

00004192 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4192:	df 93       	push	r29
    4194:	cf 93       	push	r28
    4196:	00 d0       	rcall	.+0      	; 0x4198 <prvIsQueueEmpty+0x6>
    4198:	0f 92       	push	r0
    419a:	cd b7       	in	r28, 0x3d	; 61
    419c:	de b7       	in	r29, 0x3e	; 62
    419e:	9b 83       	std	Y+3, r25	; 0x03
    41a0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    41a2:	0f b6       	in	r0, 0x3f	; 63
    41a4:	f8 94       	cli
    41a6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    41a8:	ea 81       	ldd	r30, Y+2	; 0x02
    41aa:	fb 81       	ldd	r31, Y+3	; 0x03
    41ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    41ae:	19 82       	std	Y+1, r1	; 0x01
    41b0:	88 23       	and	r24, r24
    41b2:	11 f4       	brne	.+4      	; 0x41b8 <prvIsQueueEmpty+0x26>
    41b4:	81 e0       	ldi	r24, 0x01	; 1
    41b6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    41b8:	0f 90       	pop	r0
    41ba:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    41bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    41be:	0f 90       	pop	r0
    41c0:	0f 90       	pop	r0
    41c2:	0f 90       	pop	r0
    41c4:	cf 91       	pop	r28
    41c6:	df 91       	pop	r29
    41c8:	08 95       	ret

000041ca <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    41ca:	df 93       	push	r29
    41cc:	cf 93       	push	r28
    41ce:	00 d0       	rcall	.+0      	; 0x41d0 <xQueueIsQueueEmptyFromISR+0x6>
    41d0:	0f 92       	push	r0
    41d2:	cd b7       	in	r28, 0x3d	; 61
    41d4:	de b7       	in	r29, 0x3e	; 62
    41d6:	9b 83       	std	Y+3, r25	; 0x03
    41d8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    41da:	ea 81       	ldd	r30, Y+2	; 0x02
    41dc:	fb 81       	ldd	r31, Y+3	; 0x03
    41de:	82 8d       	ldd	r24, Z+26	; 0x1a
    41e0:	19 82       	std	Y+1, r1	; 0x01
    41e2:	88 23       	and	r24, r24
    41e4:	11 f4       	brne	.+4      	; 0x41ea <xQueueIsQueueEmptyFromISR+0x20>
    41e6:	81 e0       	ldi	r24, 0x01	; 1
    41e8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    41ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    41ec:	0f 90       	pop	r0
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	cf 91       	pop	r28
    41f4:	df 91       	pop	r29
    41f6:	08 95       	ret

000041f8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    41f8:	df 93       	push	r29
    41fa:	cf 93       	push	r28
    41fc:	00 d0       	rcall	.+0      	; 0x41fe <prvIsQueueFull+0x6>
    41fe:	0f 92       	push	r0
    4200:	cd b7       	in	r28, 0x3d	; 61
    4202:	de b7       	in	r29, 0x3e	; 62
    4204:	9b 83       	std	Y+3, r25	; 0x03
    4206:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4208:	0f b6       	in	r0, 0x3f	; 63
    420a:	f8 94       	cli
    420c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    420e:	ea 81       	ldd	r30, Y+2	; 0x02
    4210:	fb 81       	ldd	r31, Y+3	; 0x03
    4212:	92 8d       	ldd	r25, Z+26	; 0x1a
    4214:	ea 81       	ldd	r30, Y+2	; 0x02
    4216:	fb 81       	ldd	r31, Y+3	; 0x03
    4218:	83 8d       	ldd	r24, Z+27	; 0x1b
    421a:	19 82       	std	Y+1, r1	; 0x01
    421c:	98 17       	cp	r25, r24
    421e:	11 f4       	brne	.+4      	; 0x4224 <prvIsQueueFull+0x2c>
    4220:	81 e0       	ldi	r24, 0x01	; 1
    4222:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4224:	0f 90       	pop	r0
    4226:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4228:	89 81       	ldd	r24, Y+1	; 0x01
}
    422a:	0f 90       	pop	r0
    422c:	0f 90       	pop	r0
    422e:	0f 90       	pop	r0
    4230:	cf 91       	pop	r28
    4232:	df 91       	pop	r29
    4234:	08 95       	ret

00004236 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4236:	df 93       	push	r29
    4238:	cf 93       	push	r28
    423a:	00 d0       	rcall	.+0      	; 0x423c <xQueueIsQueueFullFromISR+0x6>
    423c:	0f 92       	push	r0
    423e:	cd b7       	in	r28, 0x3d	; 61
    4240:	de b7       	in	r29, 0x3e	; 62
    4242:	9b 83       	std	Y+3, r25	; 0x03
    4244:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4246:	ea 81       	ldd	r30, Y+2	; 0x02
    4248:	fb 81       	ldd	r31, Y+3	; 0x03
    424a:	92 8d       	ldd	r25, Z+26	; 0x1a
    424c:	ea 81       	ldd	r30, Y+2	; 0x02
    424e:	fb 81       	ldd	r31, Y+3	; 0x03
    4250:	83 8d       	ldd	r24, Z+27	; 0x1b
    4252:	19 82       	std	Y+1, r1	; 0x01
    4254:	98 17       	cp	r25, r24
    4256:	11 f4       	brne	.+4      	; 0x425c <xQueueIsQueueFullFromISR+0x26>
    4258:	81 e0       	ldi	r24, 0x01	; 1
    425a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    425c:	89 81       	ldd	r24, Y+1	; 0x01
}
    425e:	0f 90       	pop	r0
    4260:	0f 90       	pop	r0
    4262:	0f 90       	pop	r0
    4264:	cf 91       	pop	r28
    4266:	df 91       	pop	r29
    4268:	08 95       	ret

0000426a <power>:
 */
#include "STD_TYPES.h"
#include "quickmath.h"


float power(float base, int exp) {
    426a:	df 93       	push	r29
    426c:	cf 93       	push	r28
    426e:	cd b7       	in	r28, 0x3d	; 61
    4270:	de b7       	in	r29, 0x3e	; 62
    4272:	2a 97       	sbiw	r28, 0x0a	; 10
    4274:	0f b6       	in	r0, 0x3f	; 63
    4276:	f8 94       	cli
    4278:	de bf       	out	0x3e, r29	; 62
    427a:	0f be       	out	0x3f, r0	; 63
    427c:	cd bf       	out	0x3d, r28	; 61
    427e:	69 83       	std	Y+1, r22	; 0x01
    4280:	7a 83       	std	Y+2, r23	; 0x02
    4282:	8b 83       	std	Y+3, r24	; 0x03
    4284:	9c 83       	std	Y+4, r25	; 0x04
    4286:	5e 83       	std	Y+6, r21	; 0x06
    4288:	4d 83       	std	Y+5, r20	; 0x05
    if(exp < 0) {
    428a:	8d 81       	ldd	r24, Y+5	; 0x05
    428c:	9e 81       	ldd	r25, Y+6	; 0x06
    428e:	99 23       	and	r25, r25
    4290:	0c f0       	brlt	.+2      	; 0x4294 <power+0x2a>
    4292:	3e c0       	rjmp	.+124    	; 0x4310 <power+0xa6>
        if(base == 0)
    4294:	69 81       	ldd	r22, Y+1	; 0x01
    4296:	7a 81       	ldd	r23, Y+2	; 0x02
    4298:	8b 81       	ldd	r24, Y+3	; 0x03
    429a:	9c 81       	ldd	r25, Y+4	; 0x04
    429c:	20 e0       	ldi	r18, 0x00	; 0
    429e:	30 e0       	ldi	r19, 0x00	; 0
    42a0:	40 e0       	ldi	r20, 0x00	; 0
    42a2:	50 e0       	ldi	r21, 0x00	; 0
    42a4:	0e 94 b4 2c 	call	0x5968	; 0x5968 <__cmpsf2>
    42a8:	88 23       	and	r24, r24
    42aa:	49 f4       	brne	.+18     	; 0x42be <power+0x54>
            return -0; // Error!!
    42ac:	80 e0       	ldi	r24, 0x00	; 0
    42ae:	90 e0       	ldi	r25, 0x00	; 0
    42b0:	a0 e0       	ldi	r26, 0x00	; 0
    42b2:	b0 e0       	ldi	r27, 0x00	; 0
    42b4:	8f 83       	std	Y+7, r24	; 0x07
    42b6:	98 87       	std	Y+8, r25	; 0x08
    42b8:	a9 87       	std	Y+9, r26	; 0x09
    42ba:	ba 87       	std	Y+10, r27	; 0x0a
    42bc:	62 c0       	rjmp	.+196    	; 0x4382 <power+0x118>
        return 1 / (base * power(base, (-exp) - 1));
    42be:	8d 81       	ldd	r24, Y+5	; 0x05
    42c0:	9e 81       	ldd	r25, Y+6	; 0x06
    42c2:	9c 01       	movw	r18, r24
    42c4:	20 95       	com	r18
    42c6:	30 95       	com	r19
    42c8:	89 81       	ldd	r24, Y+1	; 0x01
    42ca:	9a 81       	ldd	r25, Y+2	; 0x02
    42cc:	ab 81       	ldd	r26, Y+3	; 0x03
    42ce:	bc 81       	ldd	r27, Y+4	; 0x04
    42d0:	bc 01       	movw	r22, r24
    42d2:	cd 01       	movw	r24, r26
    42d4:	a9 01       	movw	r20, r18
    42d6:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    42da:	dc 01       	movw	r26, r24
    42dc:	cb 01       	movw	r24, r22
    42de:	bc 01       	movw	r22, r24
    42e0:	cd 01       	movw	r24, r26
    42e2:	29 81       	ldd	r18, Y+1	; 0x01
    42e4:	3a 81       	ldd	r19, Y+2	; 0x02
    42e6:	4b 81       	ldd	r20, Y+3	; 0x03
    42e8:	5c 81       	ldd	r21, Y+4	; 0x04
    42ea:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    42ee:	dc 01       	movw	r26, r24
    42f0:	cb 01       	movw	r24, r22
    42f2:	9c 01       	movw	r18, r24
    42f4:	ad 01       	movw	r20, r26
    42f6:	60 e0       	ldi	r22, 0x00	; 0
    42f8:	70 e0       	ldi	r23, 0x00	; 0
    42fa:	80 e8       	ldi	r24, 0x80	; 128
    42fc:	9f e3       	ldi	r25, 0x3F	; 63
    42fe:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    4302:	dc 01       	movw	r26, r24
    4304:	cb 01       	movw	r24, r22
    4306:	8f 83       	std	Y+7, r24	; 0x07
    4308:	98 87       	std	Y+8, r25	; 0x08
    430a:	a9 87       	std	Y+9, r26	; 0x09
    430c:	ba 87       	std	Y+10, r27	; 0x0a
    430e:	39 c0       	rjmp	.+114    	; 0x4382 <power+0x118>
    }
    if(exp == 0)
    4310:	8d 81       	ldd	r24, Y+5	; 0x05
    4312:	9e 81       	ldd	r25, Y+6	; 0x06
    4314:	00 97       	sbiw	r24, 0x00	; 0
    4316:	49 f4       	brne	.+18     	; 0x432a <power+0xc0>
        return 1;
    4318:	80 e0       	ldi	r24, 0x00	; 0
    431a:	90 e0       	ldi	r25, 0x00	; 0
    431c:	a0 e8       	ldi	r26, 0x80	; 128
    431e:	bf e3       	ldi	r27, 0x3F	; 63
    4320:	8f 83       	std	Y+7, r24	; 0x07
    4322:	98 87       	std	Y+8, r25	; 0x08
    4324:	a9 87       	std	Y+9, r26	; 0x09
    4326:	ba 87       	std	Y+10, r27	; 0x0a
    4328:	2c c0       	rjmp	.+88     	; 0x4382 <power+0x118>
    if(exp == 1)
    432a:	8d 81       	ldd	r24, Y+5	; 0x05
    432c:	9e 81       	ldd	r25, Y+6	; 0x06
    432e:	81 30       	cpi	r24, 0x01	; 1
    4330:	91 05       	cpc	r25, r1
    4332:	49 f4       	brne	.+18     	; 0x4346 <power+0xdc>
        return base;
    4334:	89 81       	ldd	r24, Y+1	; 0x01
    4336:	9a 81       	ldd	r25, Y+2	; 0x02
    4338:	ab 81       	ldd	r26, Y+3	; 0x03
    433a:	bc 81       	ldd	r27, Y+4	; 0x04
    433c:	8f 83       	std	Y+7, r24	; 0x07
    433e:	98 87       	std	Y+8, r25	; 0x08
    4340:	a9 87       	std	Y+9, r26	; 0x09
    4342:	ba 87       	std	Y+10, r27	; 0x0a
    4344:	1e c0       	rjmp	.+60     	; 0x4382 <power+0x118>
    return base * power(base, exp - 1);
    4346:	8d 81       	ldd	r24, Y+5	; 0x05
    4348:	9e 81       	ldd	r25, Y+6	; 0x06
    434a:	9c 01       	movw	r18, r24
    434c:	21 50       	subi	r18, 0x01	; 1
    434e:	30 40       	sbci	r19, 0x00	; 0
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	9a 81       	ldd	r25, Y+2	; 0x02
    4354:	ab 81       	ldd	r26, Y+3	; 0x03
    4356:	bc 81       	ldd	r27, Y+4	; 0x04
    4358:	bc 01       	movw	r22, r24
    435a:	cd 01       	movw	r24, r26
    435c:	a9 01       	movw	r20, r18
    435e:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    4362:	dc 01       	movw	r26, r24
    4364:	cb 01       	movw	r24, r22
    4366:	bc 01       	movw	r22, r24
    4368:	cd 01       	movw	r24, r26
    436a:	29 81       	ldd	r18, Y+1	; 0x01
    436c:	3a 81       	ldd	r19, Y+2	; 0x02
    436e:	4b 81       	ldd	r20, Y+3	; 0x03
    4370:	5c 81       	ldd	r21, Y+4	; 0x04
    4372:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    4376:	dc 01       	movw	r26, r24
    4378:	cb 01       	movw	r24, r22
    437a:	8f 83       	std	Y+7, r24	; 0x07
    437c:	98 87       	std	Y+8, r25	; 0x08
    437e:	a9 87       	std	Y+9, r26	; 0x09
    4380:	ba 87       	std	Y+10, r27	; 0x0a
    4382:	8f 81       	ldd	r24, Y+7	; 0x07
    4384:	98 85       	ldd	r25, Y+8	; 0x08
    4386:	a9 85       	ldd	r26, Y+9	; 0x09
    4388:	ba 85       	ldd	r27, Y+10	; 0x0a
}
    438a:	bc 01       	movw	r22, r24
    438c:	cd 01       	movw	r24, r26
    438e:	2a 96       	adiw	r28, 0x0a	; 10
    4390:	0f b6       	in	r0, 0x3f	; 63
    4392:	f8 94       	cli
    4394:	de bf       	out	0x3e, r29	; 62
    4396:	0f be       	out	0x3f, r0	; 63
    4398:	cd bf       	out	0x3d, r28	; 61
    439a:	cf 91       	pop	r28
    439c:	df 91       	pop	r29
    439e:	08 95       	ret

000043a0 <fact>:

int fact(int n) {
    43a0:	df 93       	push	r29
    43a2:	cf 93       	push	r28
    43a4:	00 d0       	rcall	.+0      	; 0x43a6 <fact+0x6>
    43a6:	00 d0       	rcall	.+0      	; 0x43a8 <fact+0x8>
    43a8:	cd b7       	in	r28, 0x3d	; 61
    43aa:	de b7       	in	r29, 0x3e	; 62
    43ac:	9a 83       	std	Y+2, r25	; 0x02
    43ae:	89 83       	std	Y+1, r24	; 0x01
    return n <= 0 ? 1 : n * fact(n-1);
    43b0:	89 81       	ldd	r24, Y+1	; 0x01
    43b2:	9a 81       	ldd	r25, Y+2	; 0x02
    43b4:	18 16       	cp	r1, r24
    43b6:	19 06       	cpc	r1, r25
    43b8:	94 f4       	brge	.+36     	; 0x43de <fact+0x3e>
    43ba:	89 81       	ldd	r24, Y+1	; 0x01
    43bc:	9a 81       	ldd	r25, Y+2	; 0x02
    43be:	01 97       	sbiw	r24, 0x01	; 1
    43c0:	0e 94 d0 21 	call	0x43a0	; 0x43a0 <fact>
    43c4:	9c 01       	movw	r18, r24
    43c6:	89 81       	ldd	r24, Y+1	; 0x01
    43c8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ca:	28 9f       	mul	r18, r24
    43cc:	a0 01       	movw	r20, r0
    43ce:	29 9f       	mul	r18, r25
    43d0:	50 0d       	add	r21, r0
    43d2:	38 9f       	mul	r19, r24
    43d4:	50 0d       	add	r21, r0
    43d6:	11 24       	eor	r1, r1
    43d8:	5c 83       	std	Y+4, r21	; 0x04
    43da:	4b 83       	std	Y+3, r20	; 0x03
    43dc:	04 c0       	rjmp	.+8      	; 0x43e6 <fact+0x46>
    43de:	81 e0       	ldi	r24, 0x01	; 1
    43e0:	90 e0       	ldi	r25, 0x00	; 0
    43e2:	9c 83       	std	Y+4, r25	; 0x04
    43e4:	8b 83       	std	Y+3, r24	; 0x03
    43e6:	8b 81       	ldd	r24, Y+3	; 0x03
    43e8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    43ea:	0f 90       	pop	r0
    43ec:	0f 90       	pop	r0
    43ee:	0f 90       	pop	r0
    43f0:	0f 90       	pop	r0
    43f2:	cf 91       	pop	r28
    43f4:	df 91       	pop	r29
    43f6:	08 95       	ret

000043f8 <sine>:
//new comment

float sine(f32 deg) {
    43f8:	ef 92       	push	r14
    43fa:	ff 92       	push	r15
    43fc:	0f 93       	push	r16
    43fe:	1f 93       	push	r17
    4400:	df 93       	push	r29
    4402:	cf 93       	push	r28
    4404:	cd b7       	in	r28, 0x3d	; 61
    4406:	de b7       	in	r29, 0x3e	; 62
    4408:	2e 97       	sbiw	r28, 0x0e	; 14
    440a:	0f b6       	in	r0, 0x3f	; 63
    440c:	f8 94       	cli
    440e:	de bf       	out	0x3e, r29	; 62
    4410:	0f be       	out	0x3f, r0	; 63
    4412:	cd bf       	out	0x3d, r28	; 61
    4414:	6b 87       	std	Y+11, r22	; 0x0b
    4416:	7c 87       	std	Y+12, r23	; 0x0c
    4418:	8d 87       	std	Y+13, r24	; 0x0d
    441a:	9e 87       	std	Y+14, r25	; 0x0e
    441c:	10 c0       	rjmp	.+32     	; 0x443e <sine+0x46>
    while(deg>360)
    {
    	deg-=360;
    441e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4420:	7c 85       	ldd	r23, Y+12	; 0x0c
    4422:	8d 85       	ldd	r24, Y+13	; 0x0d
    4424:	9e 85       	ldd	r25, Y+14	; 0x0e
    4426:	20 e0       	ldi	r18, 0x00	; 0
    4428:	30 e0       	ldi	r19, 0x00	; 0
    442a:	44 eb       	ldi	r20, 0xB4	; 180
    442c:	53 e4       	ldi	r21, 0x43	; 67
    442e:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    4432:	dc 01       	movw	r26, r24
    4434:	cb 01       	movw	r24, r22
    4436:	8b 87       	std	Y+11, r24	; 0x0b
    4438:	9c 87       	std	Y+12, r25	; 0x0c
    443a:	ad 87       	std	Y+13, r26	; 0x0d
    443c:	be 87       	std	Y+14, r27	; 0x0e
    return n <= 0 ? 1 : n * fact(n-1);
}
//new comment

float sine(f32 deg) {
    while(deg>360)
    443e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4440:	7c 85       	ldd	r23, Y+12	; 0x0c
    4442:	8d 85       	ldd	r24, Y+13	; 0x0d
    4444:	9e 85       	ldd	r25, Y+14	; 0x0e
    4446:	20 e0       	ldi	r18, 0x00	; 0
    4448:	30 e0       	ldi	r19, 0x00	; 0
    444a:	44 eb       	ldi	r20, 0xB4	; 180
    444c:	53 e4       	ldi	r21, 0x43	; 67
    444e:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <__gesf2>
    4452:	18 16       	cp	r1, r24
    4454:	24 f3       	brlt	.-56     	; 0x441e <sine+0x26>
    4456:	10 c0       	rjmp	.+32     	; 0x4478 <sine+0x80>
    {
    	deg-=360;
    }
    while(deg<-360)
    {
    	deg+=360;
    4458:	6b 85       	ldd	r22, Y+11	; 0x0b
    445a:	7c 85       	ldd	r23, Y+12	; 0x0c
    445c:	8d 85       	ldd	r24, Y+13	; 0x0d
    445e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4460:	20 e0       	ldi	r18, 0x00	; 0
    4462:	30 e0       	ldi	r19, 0x00	; 0
    4464:	44 eb       	ldi	r20, 0xB4	; 180
    4466:	53 e4       	ldi	r21, 0x43	; 67
    4468:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    446c:	dc 01       	movw	r26, r24
    446e:	cb 01       	movw	r24, r22
    4470:	8b 87       	std	Y+11, r24	; 0x0b
    4472:	9c 87       	std	Y+12, r25	; 0x0c
    4474:	ad 87       	std	Y+13, r26	; 0x0d
    4476:	be 87       	std	Y+14, r27	; 0x0e
float sine(f32 deg) {
    while(deg>360)
    {
    	deg-=360;
    }
    while(deg<-360)
    4478:	6b 85       	ldd	r22, Y+11	; 0x0b
    447a:	7c 85       	ldd	r23, Y+12	; 0x0c
    447c:	8d 85       	ldd	r24, Y+13	; 0x0d
    447e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4480:	20 e0       	ldi	r18, 0x00	; 0
    4482:	30 e0       	ldi	r19, 0x00	; 0
    4484:	44 eb       	ldi	r20, 0xB4	; 180
    4486:	53 ec       	ldi	r21, 0xC3	; 195
    4488:	0e 94 b4 2c 	call	0x5968	; 0x5968 <__cmpsf2>
    448c:	88 23       	and	r24, r24
    448e:	24 f3       	brlt	.-56     	; 0x4458 <sine+0x60>
    {
    	deg+=360;
    }
    float rad = deg * PI / 180;
    4490:	6b 85       	ldd	r22, Y+11	; 0x0b
    4492:	7c 85       	ldd	r23, Y+12	; 0x0c
    4494:	8d 85       	ldd	r24, Y+13	; 0x0d
    4496:	9e 85       	ldd	r25, Y+14	; 0x0e
    4498:	20 ed       	ldi	r18, 0xD0	; 208
    449a:	3f e0       	ldi	r19, 0x0F	; 15
    449c:	49 e4       	ldi	r20, 0x49	; 73
    449e:	50 e4       	ldi	r21, 0x40	; 64
    44a0:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    44a4:	dc 01       	movw	r26, r24
    44a6:	cb 01       	movw	r24, r22
    44a8:	bc 01       	movw	r22, r24
    44aa:	cd 01       	movw	r24, r26
    44ac:	20 e0       	ldi	r18, 0x00	; 0
    44ae:	30 e0       	ldi	r19, 0x00	; 0
    44b0:	44 e3       	ldi	r20, 0x34	; 52
    44b2:	53 e4       	ldi	r21, 0x43	; 67
    44b4:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    44b8:	dc 01       	movw	r26, r24
    44ba:	cb 01       	movw	r24, r22
    44bc:	8f 83       	std	Y+7, r24	; 0x07
    44be:	98 87       	std	Y+8, r25	; 0x08
    44c0:	a9 87       	std	Y+9, r26	; 0x09
    44c2:	ba 87       	std	Y+10, r27	; 0x0a
    float sin = 0;
    44c4:	80 e0       	ldi	r24, 0x00	; 0
    44c6:	90 e0       	ldi	r25, 0x00	; 0
    44c8:	a0 e0       	ldi	r26, 0x00	; 0
    44ca:	b0 e0       	ldi	r27, 0x00	; 0
    44cc:	8b 83       	std	Y+3, r24	; 0x03
    44ce:	9c 83       	std	Y+4, r25	; 0x04
    44d0:	ad 83       	std	Y+5, r26	; 0x05
    44d2:	be 83       	std	Y+6, r27	; 0x06

    int i;
    for(i = 0; i < TERMS; i++) { // That's Taylor series!!
    44d4:	1a 82       	std	Y+2, r1	; 0x02
    44d6:	19 82       	std	Y+1, r1	; 0x01
    44d8:	4f c0       	rjmp	.+158    	; 0x4578 <sine+0x180>
        sin += power(-1, i) * power(rad, 2 * i + 1) / fact(2 * i + 1);
    44da:	29 81       	ldd	r18, Y+1	; 0x01
    44dc:	3a 81       	ldd	r19, Y+2	; 0x02
    44de:	60 e0       	ldi	r22, 0x00	; 0
    44e0:	70 e0       	ldi	r23, 0x00	; 0
    44e2:	80 e8       	ldi	r24, 0x80	; 128
    44e4:	9f eb       	ldi	r25, 0xBF	; 191
    44e6:	a9 01       	movw	r20, r18
    44e8:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    44ec:	7b 01       	movw	r14, r22
    44ee:	8c 01       	movw	r16, r24
    44f0:	89 81       	ldd	r24, Y+1	; 0x01
    44f2:	9a 81       	ldd	r25, Y+2	; 0x02
    44f4:	88 0f       	add	r24, r24
    44f6:	99 1f       	adc	r25, r25
    44f8:	9c 01       	movw	r18, r24
    44fa:	2f 5f       	subi	r18, 0xFF	; 255
    44fc:	3f 4f       	sbci	r19, 0xFF	; 255
    44fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4500:	98 85       	ldd	r25, Y+8	; 0x08
    4502:	a9 85       	ldd	r26, Y+9	; 0x09
    4504:	ba 85       	ldd	r27, Y+10	; 0x0a
    4506:	bc 01       	movw	r22, r24
    4508:	cd 01       	movw	r24, r26
    450a:	a9 01       	movw	r20, r18
    450c:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    4510:	9b 01       	movw	r18, r22
    4512:	ac 01       	movw	r20, r24
    4514:	c8 01       	movw	r24, r16
    4516:	b7 01       	movw	r22, r14
    4518:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    451c:	dc 01       	movw	r26, r24
    451e:	cb 01       	movw	r24, r22
    4520:	7c 01       	movw	r14, r24
    4522:	8d 01       	movw	r16, r26
    4524:	89 81       	ldd	r24, Y+1	; 0x01
    4526:	9a 81       	ldd	r25, Y+2	; 0x02
    4528:	88 0f       	add	r24, r24
    452a:	99 1f       	adc	r25, r25
    452c:	01 96       	adiw	r24, 0x01	; 1
    452e:	0e 94 d0 21 	call	0x43a0	; 0x43a0 <fact>
    4532:	aa 27       	eor	r26, r26
    4534:	97 fd       	sbrc	r25, 7
    4536:	a0 95       	com	r26
    4538:	ba 2f       	mov	r27, r26
    453a:	bc 01       	movw	r22, r24
    453c:	cd 01       	movw	r24, r26
    453e:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    4542:	9b 01       	movw	r18, r22
    4544:	ac 01       	movw	r20, r24
    4546:	c8 01       	movw	r24, r16
    4548:	b7 01       	movw	r22, r14
    454a:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    454e:	dc 01       	movw	r26, r24
    4550:	cb 01       	movw	r24, r22
    4552:	9c 01       	movw	r18, r24
    4554:	ad 01       	movw	r20, r26
    4556:	6b 81       	ldd	r22, Y+3	; 0x03
    4558:	7c 81       	ldd	r23, Y+4	; 0x04
    455a:	8d 81       	ldd	r24, Y+5	; 0x05
    455c:	9e 81       	ldd	r25, Y+6	; 0x06
    455e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    4562:	dc 01       	movw	r26, r24
    4564:	cb 01       	movw	r24, r22
    4566:	8b 83       	std	Y+3, r24	; 0x03
    4568:	9c 83       	std	Y+4, r25	; 0x04
    456a:	ad 83       	std	Y+5, r26	; 0x05
    456c:	be 83       	std	Y+6, r27	; 0x06
    }
    float rad = deg * PI / 180;
    float sin = 0;

    int i;
    for(i = 0; i < TERMS; i++) { // That's Taylor series!!
    456e:	89 81       	ldd	r24, Y+1	; 0x01
    4570:	9a 81       	ldd	r25, Y+2	; 0x02
    4572:	01 96       	adiw	r24, 0x01	; 1
    4574:	9a 83       	std	Y+2, r25	; 0x02
    4576:	89 83       	std	Y+1, r24	; 0x01
    4578:	89 81       	ldd	r24, Y+1	; 0x01
    457a:	9a 81       	ldd	r25, Y+2	; 0x02
    457c:	87 30       	cpi	r24, 0x07	; 7
    457e:	91 05       	cpc	r25, r1
    4580:	0c f4       	brge	.+2      	; 0x4584 <sine+0x18c>
    4582:	ab cf       	rjmp	.-170    	; 0x44da <sine+0xe2>
        sin += power(-1, i) * power(rad, 2 * i + 1) / fact(2 * i + 1);
    }
    return sin;
    4584:	8b 81       	ldd	r24, Y+3	; 0x03
    4586:	9c 81       	ldd	r25, Y+4	; 0x04
    4588:	ad 81       	ldd	r26, Y+5	; 0x05
    458a:	be 81       	ldd	r27, Y+6	; 0x06
}
    458c:	bc 01       	movw	r22, r24
    458e:	cd 01       	movw	r24, r26
    4590:	2e 96       	adiw	r28, 0x0e	; 14
    4592:	0f b6       	in	r0, 0x3f	; 63
    4594:	f8 94       	cli
    4596:	de bf       	out	0x3e, r29	; 62
    4598:	0f be       	out	0x3f, r0	; 63
    459a:	cd bf       	out	0x3d, r28	; 61
    459c:	cf 91       	pop	r28
    459e:	df 91       	pop	r29
    45a0:	1f 91       	pop	r17
    45a2:	0f 91       	pop	r16
    45a4:	ff 90       	pop	r15
    45a6:	ef 90       	pop	r14
    45a8:	08 95       	ret

000045aa <cosine>:

float cosine(f32 deg) {
    45aa:	ef 92       	push	r14
    45ac:	ff 92       	push	r15
    45ae:	0f 93       	push	r16
    45b0:	1f 93       	push	r17
    45b2:	df 93       	push	r29
    45b4:	cf 93       	push	r28
    45b6:	cd b7       	in	r28, 0x3d	; 61
    45b8:	de b7       	in	r29, 0x3e	; 62
    45ba:	2e 97       	sbiw	r28, 0x0e	; 14
    45bc:	0f b6       	in	r0, 0x3f	; 63
    45be:	f8 94       	cli
    45c0:	de bf       	out	0x3e, r29	; 62
    45c2:	0f be       	out	0x3f, r0	; 63
    45c4:	cd bf       	out	0x3d, r28	; 61
    45c6:	6b 87       	std	Y+11, r22	; 0x0b
    45c8:	7c 87       	std	Y+12, r23	; 0x0c
    45ca:	8d 87       	std	Y+13, r24	; 0x0d
    45cc:	9e 87       	std	Y+14, r25	; 0x0e
    45ce:	10 c0       	rjmp	.+32     	; 0x45f0 <cosine+0x46>
    while(deg>360)
    {
    	deg-=360;
    45d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    45d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    45d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    45d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    45d8:	20 e0       	ldi	r18, 0x00	; 0
    45da:	30 e0       	ldi	r19, 0x00	; 0
    45dc:	44 eb       	ldi	r20, 0xB4	; 180
    45de:	53 e4       	ldi	r21, 0x43	; 67
    45e0:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    45e4:	dc 01       	movw	r26, r24
    45e6:	cb 01       	movw	r24, r22
    45e8:	8b 87       	std	Y+11, r24	; 0x0b
    45ea:	9c 87       	std	Y+12, r25	; 0x0c
    45ec:	ad 87       	std	Y+13, r26	; 0x0d
    45ee:	be 87       	std	Y+14, r27	; 0x0e
    }
    return sin;
}

float cosine(f32 deg) {
    while(deg>360)
    45f0:	6b 85       	ldd	r22, Y+11	; 0x0b
    45f2:	7c 85       	ldd	r23, Y+12	; 0x0c
    45f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    45f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    45f8:	20 e0       	ldi	r18, 0x00	; 0
    45fa:	30 e0       	ldi	r19, 0x00	; 0
    45fc:	44 eb       	ldi	r20, 0xB4	; 180
    45fe:	53 e4       	ldi	r21, 0x43	; 67
    4600:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <__gesf2>
    4604:	18 16       	cp	r1, r24
    4606:	24 f3       	brlt	.-56     	; 0x45d0 <cosine+0x26>
    4608:	10 c0       	rjmp	.+32     	; 0x462a <cosine+0x80>
    {
    	deg-=360;
    }
    while(deg<-360)
    {
    	deg+=360;
    460a:	6b 85       	ldd	r22, Y+11	; 0x0b
    460c:	7c 85       	ldd	r23, Y+12	; 0x0c
    460e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4610:	9e 85       	ldd	r25, Y+14	; 0x0e
    4612:	20 e0       	ldi	r18, 0x00	; 0
    4614:	30 e0       	ldi	r19, 0x00	; 0
    4616:	44 eb       	ldi	r20, 0xB4	; 180
    4618:	53 e4       	ldi	r21, 0x43	; 67
    461a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    461e:	dc 01       	movw	r26, r24
    4620:	cb 01       	movw	r24, r22
    4622:	8b 87       	std	Y+11, r24	; 0x0b
    4624:	9c 87       	std	Y+12, r25	; 0x0c
    4626:	ad 87       	std	Y+13, r26	; 0x0d
    4628:	be 87       	std	Y+14, r27	; 0x0e
float cosine(f32 deg) {
    while(deg>360)
    {
    	deg-=360;
    }
    while(deg<-360)
    462a:	6b 85       	ldd	r22, Y+11	; 0x0b
    462c:	7c 85       	ldd	r23, Y+12	; 0x0c
    462e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4630:	9e 85       	ldd	r25, Y+14	; 0x0e
    4632:	20 e0       	ldi	r18, 0x00	; 0
    4634:	30 e0       	ldi	r19, 0x00	; 0
    4636:	44 eb       	ldi	r20, 0xB4	; 180
    4638:	53 ec       	ldi	r21, 0xC3	; 195
    463a:	0e 94 b4 2c 	call	0x5968	; 0x5968 <__cmpsf2>
    463e:	88 23       	and	r24, r24
    4640:	24 f3       	brlt	.-56     	; 0x460a <cosine+0x60>
    {
    	deg+=360;
    }
    float rad = deg * PI / 180;
    4642:	6b 85       	ldd	r22, Y+11	; 0x0b
    4644:	7c 85       	ldd	r23, Y+12	; 0x0c
    4646:	8d 85       	ldd	r24, Y+13	; 0x0d
    4648:	9e 85       	ldd	r25, Y+14	; 0x0e
    464a:	20 ed       	ldi	r18, 0xD0	; 208
    464c:	3f e0       	ldi	r19, 0x0F	; 15
    464e:	49 e4       	ldi	r20, 0x49	; 73
    4650:	50 e4       	ldi	r21, 0x40	; 64
    4652:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    4656:	dc 01       	movw	r26, r24
    4658:	cb 01       	movw	r24, r22
    465a:	bc 01       	movw	r22, r24
    465c:	cd 01       	movw	r24, r26
    465e:	20 e0       	ldi	r18, 0x00	; 0
    4660:	30 e0       	ldi	r19, 0x00	; 0
    4662:	44 e3       	ldi	r20, 0x34	; 52
    4664:	53 e4       	ldi	r21, 0x43	; 67
    4666:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    466a:	dc 01       	movw	r26, r24
    466c:	cb 01       	movw	r24, r22
    466e:	8f 83       	std	Y+7, r24	; 0x07
    4670:	98 87       	std	Y+8, r25	; 0x08
    4672:	a9 87       	std	Y+9, r26	; 0x09
    4674:	ba 87       	std	Y+10, r27	; 0x0a
    float cos = 0;
    4676:	80 e0       	ldi	r24, 0x00	; 0
    4678:	90 e0       	ldi	r25, 0x00	; 0
    467a:	a0 e0       	ldi	r26, 0x00	; 0
    467c:	b0 e0       	ldi	r27, 0x00	; 0
    467e:	8b 83       	std	Y+3, r24	; 0x03
    4680:	9c 83       	std	Y+4, r25	; 0x04
    4682:	ad 83       	std	Y+5, r26	; 0x05
    4684:	be 83       	std	Y+6, r27	; 0x06

    int i;
    for(i = 0; i < TERMS; i++) { // That's also Taylor series!!
    4686:	1a 82       	std	Y+2, r1	; 0x02
    4688:	19 82       	std	Y+1, r1	; 0x01
    468a:	4c c0       	rjmp	.+152    	; 0x4724 <cosine+0x17a>
        cos += power(-1, i) * power(rad, 2 * i) / fact(2 * i);
    468c:	29 81       	ldd	r18, Y+1	; 0x01
    468e:	3a 81       	ldd	r19, Y+2	; 0x02
    4690:	60 e0       	ldi	r22, 0x00	; 0
    4692:	70 e0       	ldi	r23, 0x00	; 0
    4694:	80 e8       	ldi	r24, 0x80	; 128
    4696:	9f eb       	ldi	r25, 0xBF	; 191
    4698:	a9 01       	movw	r20, r18
    469a:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    469e:	7b 01       	movw	r14, r22
    46a0:	8c 01       	movw	r16, r24
    46a2:	89 81       	ldd	r24, Y+1	; 0x01
    46a4:	9a 81       	ldd	r25, Y+2	; 0x02
    46a6:	9c 01       	movw	r18, r24
    46a8:	22 0f       	add	r18, r18
    46aa:	33 1f       	adc	r19, r19
    46ac:	8f 81       	ldd	r24, Y+7	; 0x07
    46ae:	98 85       	ldd	r25, Y+8	; 0x08
    46b0:	a9 85       	ldd	r26, Y+9	; 0x09
    46b2:	ba 85       	ldd	r27, Y+10	; 0x0a
    46b4:	bc 01       	movw	r22, r24
    46b6:	cd 01       	movw	r24, r26
    46b8:	a9 01       	movw	r20, r18
    46ba:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    46be:	9b 01       	movw	r18, r22
    46c0:	ac 01       	movw	r20, r24
    46c2:	c8 01       	movw	r24, r16
    46c4:	b7 01       	movw	r22, r14
    46c6:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    46ca:	dc 01       	movw	r26, r24
    46cc:	cb 01       	movw	r24, r22
    46ce:	7c 01       	movw	r14, r24
    46d0:	8d 01       	movw	r16, r26
    46d2:	89 81       	ldd	r24, Y+1	; 0x01
    46d4:	9a 81       	ldd	r25, Y+2	; 0x02
    46d6:	88 0f       	add	r24, r24
    46d8:	99 1f       	adc	r25, r25
    46da:	0e 94 d0 21 	call	0x43a0	; 0x43a0 <fact>
    46de:	aa 27       	eor	r26, r26
    46e0:	97 fd       	sbrc	r25, 7
    46e2:	a0 95       	com	r26
    46e4:	ba 2f       	mov	r27, r26
    46e6:	bc 01       	movw	r22, r24
    46e8:	cd 01       	movw	r24, r26
    46ea:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    46ee:	9b 01       	movw	r18, r22
    46f0:	ac 01       	movw	r20, r24
    46f2:	c8 01       	movw	r24, r16
    46f4:	b7 01       	movw	r22, r14
    46f6:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    46fa:	dc 01       	movw	r26, r24
    46fc:	cb 01       	movw	r24, r22
    46fe:	9c 01       	movw	r18, r24
    4700:	ad 01       	movw	r20, r26
    4702:	6b 81       	ldd	r22, Y+3	; 0x03
    4704:	7c 81       	ldd	r23, Y+4	; 0x04
    4706:	8d 81       	ldd	r24, Y+5	; 0x05
    4708:	9e 81       	ldd	r25, Y+6	; 0x06
    470a:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    470e:	dc 01       	movw	r26, r24
    4710:	cb 01       	movw	r24, r22
    4712:	8b 83       	std	Y+3, r24	; 0x03
    4714:	9c 83       	std	Y+4, r25	; 0x04
    4716:	ad 83       	std	Y+5, r26	; 0x05
    4718:	be 83       	std	Y+6, r27	; 0x06
    }
    float rad = deg * PI / 180;
    float cos = 0;

    int i;
    for(i = 0; i < TERMS; i++) { // That's also Taylor series!!
    471a:	89 81       	ldd	r24, Y+1	; 0x01
    471c:	9a 81       	ldd	r25, Y+2	; 0x02
    471e:	01 96       	adiw	r24, 0x01	; 1
    4720:	9a 83       	std	Y+2, r25	; 0x02
    4722:	89 83       	std	Y+1, r24	; 0x01
    4724:	89 81       	ldd	r24, Y+1	; 0x01
    4726:	9a 81       	ldd	r25, Y+2	; 0x02
    4728:	87 30       	cpi	r24, 0x07	; 7
    472a:	91 05       	cpc	r25, r1
    472c:	0c f4       	brge	.+2      	; 0x4730 <cosine+0x186>
    472e:	ae cf       	rjmp	.-164    	; 0x468c <cosine+0xe2>
        cos += power(-1, i) * power(rad, 2 * i) / fact(2 * i);
    }
    return cos;
    4730:	8b 81       	ldd	r24, Y+3	; 0x03
    4732:	9c 81       	ldd	r25, Y+4	; 0x04
    4734:	ad 81       	ldd	r26, Y+5	; 0x05
    4736:	be 81       	ldd	r27, Y+6	; 0x06
}
    4738:	bc 01       	movw	r22, r24
    473a:	cd 01       	movw	r24, r26
    473c:	2e 96       	adiw	r28, 0x0e	; 14
    473e:	0f b6       	in	r0, 0x3f	; 63
    4740:	f8 94       	cli
    4742:	de bf       	out	0x3e, r29	; 62
    4744:	0f be       	out	0x3f, r0	; 63
    4746:	cd bf       	out	0x3d, r28	; 61
    4748:	cf 91       	pop	r28
    474a:	df 91       	pop	r29
    474c:	1f 91       	pop	r17
    474e:	0f 91       	pop	r16
    4750:	ff 90       	pop	r15
    4752:	ef 90       	pop	r14
    4754:	08 95       	ret

00004756 <arctan>:
float arctan(f32 x)
{	u8 flipflag=0;
    4756:	ef 92       	push	r14
    4758:	ff 92       	push	r15
    475a:	0f 93       	push	r16
    475c:	1f 93       	push	r17
    475e:	df 93       	push	r29
    4760:	cf 93       	push	r28
    4762:	cd b7       	in	r28, 0x3d	; 61
    4764:	de b7       	in	r29, 0x3e	; 62
    4766:	2b 97       	sbiw	r28, 0x0b	; 11
    4768:	0f b6       	in	r0, 0x3f	; 63
    476a:	f8 94       	cli
    476c:	de bf       	out	0x3e, r29	; 62
    476e:	0f be       	out	0x3f, r0	; 63
    4770:	cd bf       	out	0x3d, r28	; 61
    4772:	68 87       	std	Y+8, r22	; 0x08
    4774:	79 87       	std	Y+9, r23	; 0x09
    4776:	8a 87       	std	Y+10, r24	; 0x0a
    4778:	9b 87       	std	Y+11, r25	; 0x0b
    477a:	1f 82       	std	Y+7, r1	; 0x07
	if(x>1)
    477c:	68 85       	ldd	r22, Y+8	; 0x08
    477e:	79 85       	ldd	r23, Y+9	; 0x09
    4780:	8a 85       	ldd	r24, Y+10	; 0x0a
    4782:	9b 85       	ldd	r25, Y+11	; 0x0b
    4784:	20 e0       	ldi	r18, 0x00	; 0
    4786:	30 e0       	ldi	r19, 0x00	; 0
    4788:	40 e8       	ldi	r20, 0x80	; 128
    478a:	5f e3       	ldi	r21, 0x3F	; 63
    478c:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <__gesf2>
    4790:	18 16       	cp	r1, r24
    4792:	94 f4       	brge	.+36     	; 0x47b8 <arctan+0x62>
		{x=1/x; flipflag=1;}
    4794:	60 e0       	ldi	r22, 0x00	; 0
    4796:	70 e0       	ldi	r23, 0x00	; 0
    4798:	80 e8       	ldi	r24, 0x80	; 128
    479a:	9f e3       	ldi	r25, 0x3F	; 63
    479c:	28 85       	ldd	r18, Y+8	; 0x08
    479e:	39 85       	ldd	r19, Y+9	; 0x09
    47a0:	4a 85       	ldd	r20, Y+10	; 0x0a
    47a2:	5b 85       	ldd	r21, Y+11	; 0x0b
    47a4:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    47a8:	dc 01       	movw	r26, r24
    47aa:	cb 01       	movw	r24, r22
    47ac:	88 87       	std	Y+8, r24	; 0x08
    47ae:	99 87       	std	Y+9, r25	; 0x09
    47b0:	aa 87       	std	Y+10, r26	; 0x0a
    47b2:	bb 87       	std	Y+11, r27	; 0x0b
    47b4:	81 e0       	ldi	r24, 0x01	; 1
    47b6:	8f 83       	std	Y+7, r24	; 0x07
	float atan=0;
    47b8:	80 e0       	ldi	r24, 0x00	; 0
    47ba:	90 e0       	ldi	r25, 0x00	; 0
    47bc:	a0 e0       	ldi	r26, 0x00	; 0
    47be:	b0 e0       	ldi	r27, 0x00	; 0
    47c0:	8b 83       	std	Y+3, r24	; 0x03
    47c2:	9c 83       	std	Y+4, r25	; 0x04
    47c4:	ad 83       	std	Y+5, r26	; 0x05
    47c6:	be 83       	std	Y+6, r27	; 0x06
	int i;
	for(i=0; i< TERMS; i++){
    47c8:	1a 82       	std	Y+2, r1	; 0x02
    47ca:	19 82       	std	Y+1, r1	; 0x01
    47cc:	4d c0       	rjmp	.+154    	; 0x4868 <arctan+0x112>
		atan+=power(-1,i) * power(x, (2 *i) + 1) / ((2 *i) + 1);
    47ce:	29 81       	ldd	r18, Y+1	; 0x01
    47d0:	3a 81       	ldd	r19, Y+2	; 0x02
    47d2:	60 e0       	ldi	r22, 0x00	; 0
    47d4:	70 e0       	ldi	r23, 0x00	; 0
    47d6:	80 e8       	ldi	r24, 0x80	; 128
    47d8:	9f eb       	ldi	r25, 0xBF	; 191
    47da:	a9 01       	movw	r20, r18
    47dc:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    47e0:	7b 01       	movw	r14, r22
    47e2:	8c 01       	movw	r16, r24
    47e4:	89 81       	ldd	r24, Y+1	; 0x01
    47e6:	9a 81       	ldd	r25, Y+2	; 0x02
    47e8:	88 0f       	add	r24, r24
    47ea:	99 1f       	adc	r25, r25
    47ec:	9c 01       	movw	r18, r24
    47ee:	2f 5f       	subi	r18, 0xFF	; 255
    47f0:	3f 4f       	sbci	r19, 0xFF	; 255
    47f2:	88 85       	ldd	r24, Y+8	; 0x08
    47f4:	99 85       	ldd	r25, Y+9	; 0x09
    47f6:	aa 85       	ldd	r26, Y+10	; 0x0a
    47f8:	bb 85       	ldd	r27, Y+11	; 0x0b
    47fa:	bc 01       	movw	r22, r24
    47fc:	cd 01       	movw	r24, r26
    47fe:	a9 01       	movw	r20, r18
    4800:	0e 94 35 21 	call	0x426a	; 0x426a <power>
    4804:	9b 01       	movw	r18, r22
    4806:	ac 01       	movw	r20, r24
    4808:	c8 01       	movw	r24, r16
    480a:	b7 01       	movw	r22, r14
    480c:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <__mulsf3>
    4810:	dc 01       	movw	r26, r24
    4812:	cb 01       	movw	r24, r22
    4814:	7c 01       	movw	r14, r24
    4816:	8d 01       	movw	r16, r26
    4818:	89 81       	ldd	r24, Y+1	; 0x01
    481a:	9a 81       	ldd	r25, Y+2	; 0x02
    481c:	88 0f       	add	r24, r24
    481e:	99 1f       	adc	r25, r25
    4820:	01 96       	adiw	r24, 0x01	; 1
    4822:	aa 27       	eor	r26, r26
    4824:	97 fd       	sbrc	r25, 7
    4826:	a0 95       	com	r26
    4828:	ba 2f       	mov	r27, r26
    482a:	bc 01       	movw	r22, r24
    482c:	cd 01       	movw	r24, r26
    482e:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    4832:	9b 01       	movw	r18, r22
    4834:	ac 01       	movw	r20, r24
    4836:	c8 01       	movw	r24, r16
    4838:	b7 01       	movw	r22, r14
    483a:	0e 94 b8 2c 	call	0x5970	; 0x5970 <__divsf3>
    483e:	dc 01       	movw	r26, r24
    4840:	cb 01       	movw	r24, r22
    4842:	9c 01       	movw	r18, r24
    4844:	ad 01       	movw	r20, r26
    4846:	6b 81       	ldd	r22, Y+3	; 0x03
    4848:	7c 81       	ldd	r23, Y+4	; 0x04
    484a:	8d 81       	ldd	r24, Y+5	; 0x05
    484c:	9e 81       	ldd	r25, Y+6	; 0x06
    484e:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    4852:	dc 01       	movw	r26, r24
    4854:	cb 01       	movw	r24, r22
    4856:	8b 83       	std	Y+3, r24	; 0x03
    4858:	9c 83       	std	Y+4, r25	; 0x04
    485a:	ad 83       	std	Y+5, r26	; 0x05
    485c:	be 83       	std	Y+6, r27	; 0x06
{	u8 flipflag=0;
	if(x>1)
		{x=1/x; flipflag=1;}
	float atan=0;
	int i;
	for(i=0; i< TERMS; i++){
    485e:	89 81       	ldd	r24, Y+1	; 0x01
    4860:	9a 81       	ldd	r25, Y+2	; 0x02
    4862:	01 96       	adiw	r24, 0x01	; 1
    4864:	9a 83       	std	Y+2, r25	; 0x02
    4866:	89 83       	std	Y+1, r24	; 0x01
    4868:	89 81       	ldd	r24, Y+1	; 0x01
    486a:	9a 81       	ldd	r25, Y+2	; 0x02
    486c:	87 30       	cpi	r24, 0x07	; 7
    486e:	91 05       	cpc	r25, r1
    4870:	0c f4       	brge	.+2      	; 0x4874 <arctan+0x11e>
    4872:	ad cf       	rjmp	.-166    	; 0x47ce <arctan+0x78>
		atan+=power(-1,i) * power(x, (2 *i) + 1) / ((2 *i) + 1);
	}
	if(flipflag==1)
    4874:	8f 81       	ldd	r24, Y+7	; 0x07
    4876:	81 30       	cpi	r24, 0x01	; 1
    4878:	81 f4       	brne	.+32     	; 0x489a <arctan+0x144>
		atan=(PI/2)-atan;
    487a:	60 ed       	ldi	r22, 0xD0	; 208
    487c:	7f e0       	ldi	r23, 0x0F	; 15
    487e:	89 ec       	ldi	r24, 0xC9	; 201
    4880:	9f e3       	ldi	r25, 0x3F	; 63
    4882:	2b 81       	ldd	r18, Y+3	; 0x03
    4884:	3c 81       	ldd	r19, Y+4	; 0x04
    4886:	4d 81       	ldd	r20, Y+5	; 0x05
    4888:	5e 81       	ldd	r21, Y+6	; 0x06
    488a:	0e 94 4f 2c 	call	0x589e	; 0x589e <__subsf3>
    488e:	dc 01       	movw	r26, r24
    4890:	cb 01       	movw	r24, r22
    4892:	8b 83       	std	Y+3, r24	; 0x03
    4894:	9c 83       	std	Y+4, r25	; 0x04
    4896:	ad 83       	std	Y+5, r26	; 0x05
    4898:	be 83       	std	Y+6, r27	; 0x06
	return atan;
    489a:	8b 81       	ldd	r24, Y+3	; 0x03
    489c:	9c 81       	ldd	r25, Y+4	; 0x04
    489e:	ad 81       	ldd	r26, Y+5	; 0x05
    48a0:	be 81       	ldd	r27, Y+6	; 0x06
}
    48a2:	bc 01       	movw	r22, r24
    48a4:	cd 01       	movw	r24, r26
    48a6:	2b 96       	adiw	r28, 0x0b	; 11
    48a8:	0f b6       	in	r0, 0x3f	; 63
    48aa:	f8 94       	cli
    48ac:	de bf       	out	0x3e, r29	; 62
    48ae:	0f be       	out	0x3f, r0	; 63
    48b0:	cd bf       	out	0x3d, r28	; 61
    48b2:	cf 91       	pop	r28
    48b4:	df 91       	pop	r29
    48b6:	1f 91       	pop	r17
    48b8:	0f 91       	pop	r16
    48ba:	ff 90       	pop	r15
    48bc:	ef 90       	pop	r14
    48be:	08 95       	ret

000048c0 <pow>:
 */

#include "strTof.h"

u8 pow(u8 base, u8 exponent)
{
    48c0:	df 93       	push	r29
    48c2:	cf 93       	push	r28
    48c4:	00 d0       	rcall	.+0      	; 0x48c6 <pow+0x6>
    48c6:	0f 92       	push	r0
    48c8:	cd b7       	in	r28, 0x3d	; 61
    48ca:	de b7       	in	r29, 0x3e	; 62
    48cc:	8a 83       	std	Y+2, r24	; 0x02
    48ce:	6b 83       	std	Y+3, r22	; 0x03
u8 result=1;
    48d0:	81 e0       	ldi	r24, 0x01	; 1
    48d2:	89 83       	std	Y+1, r24	; 0x01
    48d4:	09 c0       	rjmp	.+18     	; 0x48e8 <pow+0x28>
for (exponent; exponent>0; exponent--)
{
result = result * base;
    48d6:	99 81       	ldd	r25, Y+1	; 0x01
    48d8:	8a 81       	ldd	r24, Y+2	; 0x02
    48da:	98 9f       	mul	r25, r24
    48dc:	80 2d       	mov	r24, r0
    48de:	11 24       	eor	r1, r1
    48e0:	89 83       	std	Y+1, r24	; 0x01
#include "strTof.h"

u8 pow(u8 base, u8 exponent)
{
u8 result=1;
for (exponent; exponent>0; exponent--)
    48e2:	8b 81       	ldd	r24, Y+3	; 0x03
    48e4:	81 50       	subi	r24, 0x01	; 1
    48e6:	8b 83       	std	Y+3, r24	; 0x03
    48e8:	8b 81       	ldd	r24, Y+3	; 0x03
    48ea:	88 23       	and	r24, r24
    48ec:	a1 f7       	brne	.-24     	; 0x48d6 <pow+0x16>
{
result = result * base;
}
return result;
    48ee:	89 81       	ldd	r24, Y+1	; 0x01
}
    48f0:	0f 90       	pop	r0
    48f2:	0f 90       	pop	r0
    48f4:	0f 90       	pop	r0
    48f6:	cf 91       	pop	r28
    48f8:	df 91       	pop	r29
    48fa:	08 95       	ret

000048fc <strTof>:

f32  strTof(u8 x[20] )
{
    48fc:	0f 93       	push	r16
    48fe:	1f 93       	push	r17
    4900:	df 93       	push	r29
    4902:	cf 93       	push	r28
    4904:	cd b7       	in	r28, 0x3d	; 61
    4906:	de b7       	in	r29, 0x3e	; 62
    4908:	2f 97       	sbiw	r28, 0x0f	; 15
    490a:	0f b6       	in	r0, 0x3f	; 63
    490c:	f8 94       	cli
    490e:	de bf       	out	0x3e, r29	; 62
    4910:	0f be       	out	0x3f, r0	; 63
    4912:	cd bf       	out	0x3d, r28	; 61
    4914:	9f 87       	std	Y+15, r25	; 0x0f
    4916:	8e 87       	std	Y+14, r24	; 0x0e
    f32 y=0;
    4918:	80 e0       	ldi	r24, 0x00	; 0
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	a0 e0       	ldi	r26, 0x00	; 0
    491e:	b0 e0       	ldi	r27, 0x00	; 0
    4920:	8a 87       	std	Y+10, r24	; 0x0a
    4922:	9b 87       	std	Y+11, r25	; 0x0b
    4924:	ac 87       	std	Y+12, r26	; 0x0c
    4926:	bd 87       	std	Y+13, r27	; 0x0d
    u8 i;
    u8 pointIndex; // the index of the po u8 in the number
    // 1st for loop to get index of the po u8 in the number
    for(i=0 ;i<strlen(x);i++ )
    4928:	19 86       	std	Y+9, r1	; 0x09
    492a:	11 c0       	rjmp	.+34     	; 0x494e <strTof+0x52>
    {
        // once we get the pou8 break the loop
        if(x[i]=='.')
    492c:	89 85       	ldd	r24, Y+9	; 0x09
    492e:	28 2f       	mov	r18, r24
    4930:	30 e0       	ldi	r19, 0x00	; 0
    4932:	8e 85       	ldd	r24, Y+14	; 0x0e
    4934:	9f 85       	ldd	r25, Y+15	; 0x0f
    4936:	fc 01       	movw	r30, r24
    4938:	e2 0f       	add	r30, r18
    493a:	f3 1f       	adc	r31, r19
    493c:	80 81       	ld	r24, Z
    493e:	8e 32       	cpi	r24, 0x2E	; 46
    4940:	19 f4       	brne	.+6      	; 0x4948 <strTof+0x4c>
        {
            pointIndex=i;
    4942:	89 85       	ldd	r24, Y+9	; 0x09
    4944:	88 87       	std	Y+8, r24	; 0x08
    4946:	0d c0       	rjmp	.+26     	; 0x4962 <strTof+0x66>
{
    f32 y=0;
    u8 i;
    u8 pointIndex; // the index of the po u8 in the number
    // 1st for loop to get index of the po u8 in the number
    for(i=0 ;i<strlen(x);i++ )
    4948:	89 85       	ldd	r24, Y+9	; 0x09
    494a:	8f 5f       	subi	r24, 0xFF	; 255
    494c:	89 87       	std	Y+9, r24	; 0x09
    494e:	89 85       	ldd	r24, Y+9	; 0x09
    4950:	08 2f       	mov	r16, r24
    4952:	10 e0       	ldi	r17, 0x00	; 0
    4954:	8e 85       	ldd	r24, Y+14	; 0x0e
    4956:	9f 85       	ldd	r25, Y+15	; 0x0f
    4958:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <strlen>
    495c:	08 17       	cp	r16, r24
    495e:	19 07       	cpc	r17, r25
    4960:	28 f3       	brcs	.-54     	; 0x492c <strTof+0x30>

    }



    u8 k=pointIndex;
    4962:	88 85       	ldd	r24, Y+8	; 0x08
    4964:	8f 83       	std	Y+7, r24	; 0x07
    k=k-1;
    4966:	8f 81       	ldd	r24, Y+7	; 0x07
    4968:	81 50       	subi	r24, 0x01	; 1
    496a:	8f 83       	std	Y+7, r24	; 0x07

    // 2nd for loop to get numbers before the pou8 by multiplying each number by its weight
    for(i =0;i<pointIndex;i++)
    496c:	19 86       	std	Y+9, r1	; 0x09
    496e:	38 c0       	rjmp	.+112    	; 0x49e0 <strTof+0xe4>
    {
        y+=(x[i]-48)*pow(10,k);
    4970:	89 85       	ldd	r24, Y+9	; 0x09
    4972:	28 2f       	mov	r18, r24
    4974:	30 e0       	ldi	r19, 0x00	; 0
    4976:	8e 85       	ldd	r24, Y+14	; 0x0e
    4978:	9f 85       	ldd	r25, Y+15	; 0x0f
    497a:	fc 01       	movw	r30, r24
    497c:	e2 0f       	add	r30, r18
    497e:	f3 1f       	adc	r31, r19
    4980:	80 81       	ld	r24, Z
    4982:	88 2f       	mov	r24, r24
    4984:	90 e0       	ldi	r25, 0x00	; 0
    4986:	8c 01       	movw	r16, r24
    4988:	00 53       	subi	r16, 0x30	; 48
    498a:	10 40       	sbci	r17, 0x00	; 0
    498c:	8a e0       	ldi	r24, 0x0A	; 10
    498e:	6f 81       	ldd	r22, Y+7	; 0x07
    4990:	0e 94 60 24 	call	0x48c0	; 0x48c0 <pow>
    4994:	88 2f       	mov	r24, r24
    4996:	90 e0       	ldi	r25, 0x00	; 0
    4998:	9c 01       	movw	r18, r24
    499a:	02 9f       	mul	r16, r18
    499c:	c0 01       	movw	r24, r0
    499e:	03 9f       	mul	r16, r19
    49a0:	90 0d       	add	r25, r0
    49a2:	12 9f       	mul	r17, r18
    49a4:	90 0d       	add	r25, r0
    49a6:	11 24       	eor	r1, r1
    49a8:	aa 27       	eor	r26, r26
    49aa:	97 fd       	sbrc	r25, 7
    49ac:	a0 95       	com	r26
    49ae:	ba 2f       	mov	r27, r26
    49b0:	bc 01       	movw	r22, r24
    49b2:	cd 01       	movw	r24, r26
    49b4:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    49b8:	9b 01       	movw	r18, r22
    49ba:	ac 01       	movw	r20, r24
    49bc:	6a 85       	ldd	r22, Y+10	; 0x0a
    49be:	7b 85       	ldd	r23, Y+11	; 0x0b
    49c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    49c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    49c4:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    49c8:	dc 01       	movw	r26, r24
    49ca:	cb 01       	movw	r24, r22
    49cc:	8a 87       	std	Y+10, r24	; 0x0a
    49ce:	9b 87       	std	Y+11, r25	; 0x0b
    49d0:	ac 87       	std	Y+12, r26	; 0x0c
    49d2:	bd 87       	std	Y+13, r27	; 0x0d
        k--;
    49d4:	8f 81       	ldd	r24, Y+7	; 0x07
    49d6:	81 50       	subi	r24, 0x01	; 1
    49d8:	8f 83       	std	Y+7, r24	; 0x07

    u8 k=pointIndex;
    k=k-1;

    // 2nd for loop to get numbers before the pou8 by multiplying each number by its weight
    for(i =0;i<pointIndex;i++)
    49da:	89 85       	ldd	r24, Y+9	; 0x09
    49dc:	8f 5f       	subi	r24, 0xFF	; 255
    49de:	89 87       	std	Y+9, r24	; 0x09
    49e0:	99 85       	ldd	r25, Y+9	; 0x09
    49e2:	88 85       	ldd	r24, Y+8	; 0x08
    49e4:	98 17       	cp	r25, r24
    49e6:	20 f2       	brcs	.-120    	; 0x4970 <strTof+0x74>
    {
        y+=(x[i]-48)*pow(10,k);
        k--;
    }

    k=pointIndex;
    49e8:	88 85       	ldd	r24, Y+8	; 0x08
    49ea:	8f 83       	std	Y+7, r24	; 0x07
    u8 h =1;
    49ec:	81 e0       	ldi	r24, 0x01	; 1
    49ee:	8e 83       	std	Y+6, r24	; 0x06
    u8 j;
    f32 z=0;
    49f0:	80 e0       	ldi	r24, 0x00	; 0
    49f2:	90 e0       	ldi	r25, 0x00	; 0
    49f4:	a0 e0       	ldi	r26, 0x00	; 0
    49f6:	b0 e0       	ldi	r27, 0x00	; 0
    49f8:	89 83       	std	Y+1, r24	; 0x01
    49fa:	9a 83       	std	Y+2, r25	; 0x02
    49fc:	ab 83       	std	Y+3, r26	; 0x03
    49fe:	bc 83       	std	Y+4, r27	; 0x04

    // 3rd loop to get numbers after the pou8 also by multiplying each number by its weight
    for (j =k+1  ;j<strlen(x); j++ )
    4a00:	8f 81       	ldd	r24, Y+7	; 0x07
    4a02:	8f 5f       	subi	r24, 0xFF	; 255
    4a04:	8d 83       	std	Y+5, r24	; 0x05
    4a06:	35 c0       	rjmp	.+106    	; 0x4a72 <strTof+0x176>
    {
        z+=(x[j]-48)/pow(10,h);
    4a08:	8d 81       	ldd	r24, Y+5	; 0x05
    4a0a:	28 2f       	mov	r18, r24
    4a0c:	30 e0       	ldi	r19, 0x00	; 0
    4a0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4a10:	9f 85       	ldd	r25, Y+15	; 0x0f
    4a12:	fc 01       	movw	r30, r24
    4a14:	e2 0f       	add	r30, r18
    4a16:	f3 1f       	adc	r31, r19
    4a18:	80 81       	ld	r24, Z
    4a1a:	88 2f       	mov	r24, r24
    4a1c:	90 e0       	ldi	r25, 0x00	; 0
    4a1e:	8c 01       	movw	r16, r24
    4a20:	00 53       	subi	r16, 0x30	; 48
    4a22:	10 40       	sbci	r17, 0x00	; 0
    4a24:	8a e0       	ldi	r24, 0x0A	; 10
    4a26:	6e 81       	ldd	r22, Y+6	; 0x06
    4a28:	0e 94 60 24 	call	0x48c0	; 0x48c0 <pow>
    4a2c:	28 2f       	mov	r18, r24
    4a2e:	30 e0       	ldi	r19, 0x00	; 0
    4a30:	c8 01       	movw	r24, r16
    4a32:	b9 01       	movw	r22, r18
    4a34:	0e 94 71 2e 	call	0x5ce2	; 0x5ce2 <__divmodhi4>
    4a38:	cb 01       	movw	r24, r22
    4a3a:	aa 27       	eor	r26, r26
    4a3c:	97 fd       	sbrc	r25, 7
    4a3e:	a0 95       	com	r26
    4a40:	ba 2f       	mov	r27, r26
    4a42:	bc 01       	movw	r22, r24
    4a44:	cd 01       	movw	r24, r26
    4a46:	0e 94 4e 2d 	call	0x5a9c	; 0x5a9c <__floatsisf>
    4a4a:	9b 01       	movw	r18, r22
    4a4c:	ac 01       	movw	r20, r24
    4a4e:	69 81       	ldd	r22, Y+1	; 0x01
    4a50:	7a 81       	ldd	r23, Y+2	; 0x02
    4a52:	8b 81       	ldd	r24, Y+3	; 0x03
    4a54:	9c 81       	ldd	r25, Y+4	; 0x04
    4a56:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    4a5a:	dc 01       	movw	r26, r24
    4a5c:	cb 01       	movw	r24, r22
    4a5e:	89 83       	std	Y+1, r24	; 0x01
    4a60:	9a 83       	std	Y+2, r25	; 0x02
    4a62:	ab 83       	std	Y+3, r26	; 0x03
    4a64:	bc 83       	std	Y+4, r27	; 0x04
        h++;
    4a66:	8e 81       	ldd	r24, Y+6	; 0x06
    4a68:	8f 5f       	subi	r24, 0xFF	; 255
    4a6a:	8e 83       	std	Y+6, r24	; 0x06
    u8 h =1;
    u8 j;
    f32 z=0;

    // 3rd loop to get numbers after the pou8 also by multiplying each number by its weight
    for (j =k+1  ;j<strlen(x); j++ )
    4a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a6e:	8f 5f       	subi	r24, 0xFF	; 255
    4a70:	8d 83       	std	Y+5, r24	; 0x05
    4a72:	8d 81       	ldd	r24, Y+5	; 0x05
    4a74:	08 2f       	mov	r16, r24
    4a76:	10 e0       	ldi	r17, 0x00	; 0
    4a78:	8e 85       	ldd	r24, Y+14	; 0x0e
    4a7a:	9f 85       	ldd	r25, Y+15	; 0x0f
    4a7c:	0e 94 a8 2e 	call	0x5d50	; 0x5d50 <strlen>
    4a80:	08 17       	cp	r16, r24
    4a82:	19 07       	cpc	r17, r25
    4a84:	08 f2       	brcs	.-126    	; 0x4a08 <strTof+0x10c>
    {
        z+=(x[j]-48)/pow(10,h);
        h++;
    }
    y+=z;
    4a86:	6a 85       	ldd	r22, Y+10	; 0x0a
    4a88:	7b 85       	ldd	r23, Y+11	; 0x0b
    4a8a:	8c 85       	ldd	r24, Y+12	; 0x0c
    4a8c:	9d 85       	ldd	r25, Y+13	; 0x0d
    4a8e:	29 81       	ldd	r18, Y+1	; 0x01
    4a90:	3a 81       	ldd	r19, Y+2	; 0x02
    4a92:	4b 81       	ldd	r20, Y+3	; 0x03
    4a94:	5c 81       	ldd	r21, Y+4	; 0x04
    4a96:	0e 94 50 2c 	call	0x58a0	; 0x58a0 <__addsf3>
    4a9a:	dc 01       	movw	r26, r24
    4a9c:	cb 01       	movw	r24, r22
    4a9e:	8a 87       	std	Y+10, r24	; 0x0a
    4aa0:	9b 87       	std	Y+11, r25	; 0x0b
    4aa2:	ac 87       	std	Y+12, r26	; 0x0c
    4aa4:	bd 87       	std	Y+13, r27	; 0x0d
     //return by the f32 number
    return y ;
    4aa6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4aa8:	9b 85       	ldd	r25, Y+11	; 0x0b
    4aaa:	ac 85       	ldd	r26, Y+12	; 0x0c
    4aac:	bd 85       	ldd	r27, Y+13	; 0x0d
}
    4aae:	bc 01       	movw	r22, r24
    4ab0:	cd 01       	movw	r24, r26
    4ab2:	2f 96       	adiw	r28, 0x0f	; 15
    4ab4:	0f b6       	in	r0, 0x3f	; 63
    4ab6:	f8 94       	cli
    4ab8:	de bf       	out	0x3e, r29	; 62
    4aba:	0f be       	out	0x3f, r0	; 63
    4abc:	cd bf       	out	0x3d, r28	; 61
    4abe:	cf 91       	pop	r28
    4ac0:	df 91       	pop	r29
    4ac2:	1f 91       	pop	r17
    4ac4:	0f 91       	pop	r16
    4ac6:	08 95       	ret

00004ac8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    4ac8:	af 92       	push	r10
    4aca:	bf 92       	push	r11
    4acc:	cf 92       	push	r12
    4ace:	df 92       	push	r13
    4ad0:	ef 92       	push	r14
    4ad2:	ff 92       	push	r15
    4ad4:	0f 93       	push	r16
    4ad6:	1f 93       	push	r17
    4ad8:	df 93       	push	r29
    4ada:	cf 93       	push	r28
    4adc:	cd b7       	in	r28, 0x3d	; 61
    4ade:	de b7       	in	r29, 0x3e	; 62
    4ae0:	64 97       	sbiw	r28, 0x14	; 20
    4ae2:	0f b6       	in	r0, 0x3f	; 63
    4ae4:	f8 94       	cli
    4ae6:	de bf       	out	0x3e, r29	; 62
    4ae8:	0f be       	out	0x3f, r0	; 63
    4aea:	cd bf       	out	0x3d, r28	; 61
    4aec:	9f 83       	std	Y+7, r25	; 0x07
    4aee:	8e 83       	std	Y+6, r24	; 0x06
    4af0:	79 87       	std	Y+9, r23	; 0x09
    4af2:	68 87       	std	Y+8, r22	; 0x08
    4af4:	5b 87       	std	Y+11, r21	; 0x0b
    4af6:	4a 87       	std	Y+10, r20	; 0x0a
    4af8:	3d 87       	std	Y+13, r19	; 0x0d
    4afa:	2c 87       	std	Y+12, r18	; 0x0c
    4afc:	0e 87       	std	Y+14, r16	; 0x0e
    4afe:	f8 8a       	std	Y+16, r15	; 0x10
    4b00:	ef 86       	std	Y+15, r14	; 0x0f
    4b02:	da 8a       	std	Y+18, r13	; 0x12
    4b04:	c9 8a       	std	Y+17, r12	; 0x11
    4b06:	bc 8a       	std	Y+20, r11	; 0x14
    4b08:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4b0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b0e:	29 89       	ldd	r18, Y+17	; 0x11
    4b10:	3a 89       	ldd	r19, Y+18	; 0x12
    4b12:	b9 01       	movw	r22, r18
    4b14:	0e 94 e9 2b 	call	0x57d2	; 0x57d2 <prvAllocateTCBAndStack>
    4b18:	9c 83       	std	Y+4, r25	; 0x04
    4b1a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b20:	00 97       	sbiw	r24, 0x00	; 0
    4b22:	09 f4       	brne	.+2      	; 0x4b26 <xTaskGenericCreate+0x5e>
    4b24:	99 c0       	rjmp	.+306    	; 0x4c58 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    4b26:	eb 81       	ldd	r30, Y+3	; 0x03
    4b28:	fc 81       	ldd	r31, Y+4	; 0x04
    4b2a:	27 89       	ldd	r18, Z+23	; 0x17
    4b2c:	30 8d       	ldd	r19, Z+24	; 0x18
    4b2e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b30:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b32:	01 97       	sbiw	r24, 0x01	; 1
    4b34:	82 0f       	add	r24, r18
    4b36:	93 1f       	adc	r25, r19
    4b38:	9a 83       	std	Y+2, r25	; 0x02
    4b3a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    4b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b40:	28 85       	ldd	r18, Y+8	; 0x08
    4b42:	39 85       	ldd	r19, Y+9	; 0x09
    4b44:	eb 89       	ldd	r30, Y+19	; 0x13
    4b46:	fc 89       	ldd	r31, Y+20	; 0x14
    4b48:	aa 85       	ldd	r26, Y+10	; 0x0a
    4b4a:	bb 85       	ldd	r27, Y+11	; 0x0b
    4b4c:	b9 01       	movw	r22, r18
    4b4e:	4e 85       	ldd	r20, Y+14	; 0x0e
    4b50:	9f 01       	movw	r18, r30
    4b52:	8d 01       	movw	r16, r26
    4b54:	0e 94 ce 2a 	call	0x559c	; 0x559c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4b58:	89 81       	ldd	r24, Y+1	; 0x01
    4b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b5c:	2e 81       	ldd	r18, Y+6	; 0x06
    4b5e:	3f 81       	ldd	r19, Y+7	; 0x07
    4b60:	4c 85       	ldd	r20, Y+12	; 0x0c
    4b62:	5d 85       	ldd	r21, Y+13	; 0x0d
    4b64:	b9 01       	movw	r22, r18
    4b66:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <pxPortInitialiseStack>
    4b6a:	eb 81       	ldd	r30, Y+3	; 0x03
    4b6c:	fc 81       	ldd	r31, Y+4	; 0x04
    4b6e:	91 83       	std	Z+1, r25	; 0x01
    4b70:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    4b72:	8f 85       	ldd	r24, Y+15	; 0x0f
    4b74:	98 89       	ldd	r25, Y+16	; 0x10
    4b76:	00 97       	sbiw	r24, 0x00	; 0
    4b78:	31 f0       	breq	.+12     	; 0x4b86 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    4b7a:	ef 85       	ldd	r30, Y+15	; 0x0f
    4b7c:	f8 89       	ldd	r31, Y+16	; 0x10
    4b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b80:	9c 81       	ldd	r25, Y+4	; 0x04
    4b82:	91 83       	std	Z+1, r25	; 0x01
    4b84:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4b86:	0f b6       	in	r0, 0x3f	; 63
    4b88:	f8 94       	cli
    4b8a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4b8c:	80 91 a7 03 	lds	r24, 0x03A7
    4b90:	8f 5f       	subi	r24, 0xFF	; 255
    4b92:	80 93 a7 03 	sts	0x03A7, r24
			if( pxCurrentTCB == NULL )
    4b96:	80 91 a4 03 	lds	r24, 0x03A4
    4b9a:	90 91 a5 03 	lds	r25, 0x03A5
    4b9e:	00 97       	sbiw	r24, 0x00	; 0
    4ba0:	69 f4       	brne	.+26     	; 0x4bbc <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ba6:	90 93 a5 03 	sts	0x03A5, r25
    4baa:	80 93 a4 03 	sts	0x03A4, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4bae:	80 91 a7 03 	lds	r24, 0x03A7
    4bb2:	81 30       	cpi	r24, 0x01	; 1
    4bb4:	a9 f4       	brne	.+42     	; 0x4be0 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4bb6:	0e 94 25 2b 	call	0x564a	; 0x564a <prvInitialiseTaskLists>
    4bba:	12 c0       	rjmp	.+36     	; 0x4be0 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4bbc:	80 91 ac 03 	lds	r24, 0x03AC
    4bc0:	88 23       	and	r24, r24
    4bc2:	71 f4       	brne	.+28     	; 0x4be0 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4bc4:	e0 91 a4 03 	lds	r30, 0x03A4
    4bc8:	f0 91 a5 03 	lds	r31, 0x03A5
    4bcc:	96 89       	ldd	r25, Z+22	; 0x16
    4bce:	8e 85       	ldd	r24, Y+14	; 0x0e
    4bd0:	89 17       	cp	r24, r25
    4bd2:	30 f0       	brcs	.+12     	; 0x4be0 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    4bd6:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd8:	90 93 a5 03 	sts	0x03A5, r25
    4bdc:	80 93 a4 03 	sts	0x03A4, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4be0:	eb 81       	ldd	r30, Y+3	; 0x03
    4be2:	fc 81       	ldd	r31, Y+4	; 0x04
    4be4:	96 89       	ldd	r25, Z+22	; 0x16
    4be6:	80 91 aa 03 	lds	r24, 0x03AA
    4bea:	89 17       	cp	r24, r25
    4bec:	28 f4       	brcc	.+10     	; 0x4bf8 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4bee:	eb 81       	ldd	r30, Y+3	; 0x03
    4bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    4bf2:	86 89       	ldd	r24, Z+22	; 0x16
    4bf4:	80 93 aa 03 	sts	0x03AA, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    4bf8:	80 91 b1 03 	lds	r24, 0x03B1
    4bfc:	8f 5f       	subi	r24, 0xFF	; 255
    4bfe:	80 93 b1 03 	sts	0x03B1, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4c02:	eb 81       	ldd	r30, Y+3	; 0x03
    4c04:	fc 81       	ldd	r31, Y+4	; 0x04
    4c06:	96 89       	ldd	r25, Z+22	; 0x16
    4c08:	80 91 ab 03 	lds	r24, 0x03AB
    4c0c:	89 17       	cp	r24, r25
    4c0e:	28 f4       	brcc	.+10     	; 0x4c1a <xTaskGenericCreate+0x152>
    4c10:	eb 81       	ldd	r30, Y+3	; 0x03
    4c12:	fc 81       	ldd	r31, Y+4	; 0x04
    4c14:	86 89       	ldd	r24, Z+22	; 0x16
    4c16:	80 93 ab 03 	sts	0x03AB, r24
    4c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    4c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    4c1e:	86 89       	ldd	r24, Z+22	; 0x16
    4c20:	28 2f       	mov	r18, r24
    4c22:	30 e0       	ldi	r19, 0x00	; 0
    4c24:	c9 01       	movw	r24, r18
    4c26:	88 0f       	add	r24, r24
    4c28:	99 1f       	adc	r25, r25
    4c2a:	88 0f       	add	r24, r24
    4c2c:	99 1f       	adc	r25, r25
    4c2e:	88 0f       	add	r24, r24
    4c30:	99 1f       	adc	r25, r25
    4c32:	82 0f       	add	r24, r18
    4c34:	93 1f       	adc	r25, r19
    4c36:	ac 01       	movw	r20, r24
    4c38:	4e 54       	subi	r20, 0x4E	; 78
    4c3a:	5c 4f       	sbci	r21, 0xFC	; 252
    4c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c40:	9c 01       	movw	r18, r24
    4c42:	2e 5f       	subi	r18, 0xFE	; 254
    4c44:	3f 4f       	sbci	r19, 0xFF	; 255
    4c46:	ca 01       	movw	r24, r20
    4c48:	b9 01       	movw	r22, r18
    4c4a:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>

			xReturn = pdPASS;
    4c4e:	81 e0       	ldi	r24, 0x01	; 1
    4c50:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4c52:	0f 90       	pop	r0
    4c54:	0f be       	out	0x3f, r0	; 63
    4c56:	02 c0       	rjmp	.+4      	; 0x4c5c <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c58:	8f ef       	ldi	r24, 0xFF	; 255
    4c5a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c5e:	81 30       	cpi	r24, 0x01	; 1
    4c60:	71 f4       	brne	.+28     	; 0x4c7e <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    4c62:	80 91 ac 03 	lds	r24, 0x03AC
    4c66:	88 23       	and	r24, r24
    4c68:	51 f0       	breq	.+20     	; 0x4c7e <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4c6a:	e0 91 a4 03 	lds	r30, 0x03A4
    4c6e:	f0 91 a5 03 	lds	r31, 0x03A5
    4c72:	96 89       	ldd	r25, Z+22	; 0x16
    4c74:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c76:	98 17       	cp	r25, r24
    4c78:	10 f4       	brcc	.+4      	; 0x4c7e <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    4c7a:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
			}
		}
	}

	return xReturn;
    4c7e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4c80:	64 96       	adiw	r28, 0x14	; 20
    4c82:	0f b6       	in	r0, 0x3f	; 63
    4c84:	f8 94       	cli
    4c86:	de bf       	out	0x3e, r29	; 62
    4c88:	0f be       	out	0x3f, r0	; 63
    4c8a:	cd bf       	out	0x3d, r28	; 61
    4c8c:	cf 91       	pop	r28
    4c8e:	df 91       	pop	r29
    4c90:	1f 91       	pop	r17
    4c92:	0f 91       	pop	r16
    4c94:	ff 90       	pop	r15
    4c96:	ef 90       	pop	r14
    4c98:	df 90       	pop	r13
    4c9a:	cf 90       	pop	r12
    4c9c:	bf 90       	pop	r11
    4c9e:	af 90       	pop	r10
    4ca0:	08 95       	ret

00004ca2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4ca2:	df 93       	push	r29
    4ca4:	cf 93       	push	r28
    4ca6:	00 d0       	rcall	.+0      	; 0x4ca8 <vTaskDelete+0x6>
    4ca8:	00 d0       	rcall	.+0      	; 0x4caa <vTaskDelete+0x8>
    4caa:	00 d0       	rcall	.+0      	; 0x4cac <vTaskDelete+0xa>
    4cac:	cd b7       	in	r28, 0x3d	; 61
    4cae:	de b7       	in	r29, 0x3e	; 62
    4cb0:	9c 83       	std	Y+4, r25	; 0x04
    4cb2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4cb4:	0f b6       	in	r0, 0x3f	; 63
    4cb6:	f8 94       	cli
    4cb8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4cba:	20 91 a4 03 	lds	r18, 0x03A4
    4cbe:	30 91 a5 03 	lds	r19, 0x03A5
    4cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    4cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    4cc6:	82 17       	cp	r24, r18
    4cc8:	93 07       	cpc	r25, r19
    4cca:	11 f4       	brne	.+4      	; 0x4cd0 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4ccc:	1c 82       	std	Y+4, r1	; 0x04
    4cce:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4cd0:	8b 81       	ldd	r24, Y+3	; 0x03
    4cd2:	9c 81       	ldd	r25, Y+4	; 0x04
    4cd4:	00 97       	sbiw	r24, 0x00	; 0
    4cd6:	39 f4       	brne	.+14     	; 0x4ce6 <vTaskDelete+0x44>
    4cd8:	80 91 a4 03 	lds	r24, 0x03A4
    4cdc:	90 91 a5 03 	lds	r25, 0x03A5
    4ce0:	9e 83       	std	Y+6, r25	; 0x06
    4ce2:	8d 83       	std	Y+5, r24	; 0x05
    4ce4:	04 c0       	rjmp	.+8      	; 0x4cee <vTaskDelete+0x4c>
    4ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    4cea:	9e 83       	std	Y+6, r25	; 0x06
    4cec:	8d 83       	std	Y+5, r24	; 0x05
    4cee:	8d 81       	ldd	r24, Y+5	; 0x05
    4cf0:	9e 81       	ldd	r25, Y+6	; 0x06
    4cf2:	9a 83       	std	Y+2, r25	; 0x02
    4cf4:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4cf6:	89 81       	ldd	r24, Y+1	; 0x01
    4cf8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cfa:	02 96       	adiw	r24, 0x02	; 2
    4cfc:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4d00:	e9 81       	ldd	r30, Y+1	; 0x01
    4d02:	fa 81       	ldd	r31, Y+2	; 0x02
    4d04:	84 89       	ldd	r24, Z+20	; 0x14
    4d06:	95 89       	ldd	r25, Z+21	; 0x15
    4d08:	00 97       	sbiw	r24, 0x00	; 0
    4d0a:	29 f0       	breq	.+10     	; 0x4d16 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    4d0c:	89 81       	ldd	r24, Y+1	; 0x01
    4d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d10:	0c 96       	adiw	r24, 0x0c	; 12
    4d12:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4d16:	89 81       	ldd	r24, Y+1	; 0x01
    4d18:	9a 81       	ldd	r25, Y+2	; 0x02
    4d1a:	9c 01       	movw	r18, r24
    4d1c:	2e 5f       	subi	r18, 0xFE	; 254
    4d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d20:	8c ee       	ldi	r24, 0xEC	; 236
    4d22:	93 e0       	ldi	r25, 0x03	; 3
    4d24:	b9 01       	movw	r22, r18
    4d26:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4d2a:	80 91 a6 03 	lds	r24, 0x03A6
    4d2e:	8f 5f       	subi	r24, 0xFF	; 255
    4d30:	80 93 a6 03 	sts	0x03A6, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4d34:	80 91 b1 03 	lds	r24, 0x03B1
    4d38:	8f 5f       	subi	r24, 0xFF	; 255
    4d3a:	80 93 b1 03 	sts	0x03B1, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4d3e:	0f 90       	pop	r0
    4d40:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4d42:	80 91 ac 03 	lds	r24, 0x03AC
    4d46:	88 23       	and	r24, r24
    4d48:	31 f0       	breq	.+12     	; 0x4d56 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4d4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4d4e:	00 97       	sbiw	r24, 0x00	; 0
    4d50:	11 f4       	brne	.+4      	; 0x4d56 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4d52:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
			}
		}
	}
    4d56:	26 96       	adiw	r28, 0x06	; 6
    4d58:	0f b6       	in	r0, 0x3f	; 63
    4d5a:	f8 94       	cli
    4d5c:	de bf       	out	0x3e, r29	; 62
    4d5e:	0f be       	out	0x3f, r0	; 63
    4d60:	cd bf       	out	0x3d, r28	; 61
    4d62:	cf 91       	pop	r28
    4d64:	df 91       	pop	r29
    4d66:	08 95       	ret

00004d68 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4d68:	df 93       	push	r29
    4d6a:	cf 93       	push	r28
    4d6c:	cd b7       	in	r28, 0x3d	; 61
    4d6e:	de b7       	in	r29, 0x3e	; 62
    4d70:	28 97       	sbiw	r28, 0x08	; 8
    4d72:	0f b6       	in	r0, 0x3f	; 63
    4d74:	f8 94       	cli
    4d76:	de bf       	out	0x3e, r29	; 62
    4d78:	0f be       	out	0x3f, r0	; 63
    4d7a:	cd bf       	out	0x3d, r28	; 61
    4d7c:	9e 83       	std	Y+6, r25	; 0x06
    4d7e:	8d 83       	std	Y+5, r24	; 0x05
    4d80:	78 87       	std	Y+8, r23	; 0x08
    4d82:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4d84:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4d86:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    4d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    4d8e:	20 81       	ld	r18, Z
    4d90:	31 81       	ldd	r19, Z+1	; 0x01
    4d92:	8f 81       	ldd	r24, Y+7	; 0x07
    4d94:	98 85       	ldd	r25, Y+8	; 0x08
    4d96:	82 0f       	add	r24, r18
    4d98:	93 1f       	adc	r25, r19
    4d9a:	9c 83       	std	Y+4, r25	; 0x04
    4d9c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4d9e:	ed 81       	ldd	r30, Y+5	; 0x05
    4da0:	fe 81       	ldd	r31, Y+6	; 0x06
    4da2:	20 81       	ld	r18, Z
    4da4:	31 81       	ldd	r19, Z+1	; 0x01
    4da6:	80 91 a8 03 	lds	r24, 0x03A8
    4daa:	90 91 a9 03 	lds	r25, 0x03A9
    4dae:	82 17       	cp	r24, r18
    4db0:	93 07       	cpc	r25, r19
    4db2:	a8 f4       	brcc	.+42     	; 0x4dde <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4db4:	ed 81       	ldd	r30, Y+5	; 0x05
    4db6:	fe 81       	ldd	r31, Y+6	; 0x06
    4db8:	20 81       	ld	r18, Z
    4dba:	31 81       	ldd	r19, Z+1	; 0x01
    4dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    4dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    4dc0:	82 17       	cp	r24, r18
    4dc2:	93 07       	cpc	r25, r19
    4dc4:	00 f5       	brcc	.+64     	; 0x4e06 <vTaskDelayUntil+0x9e>
    4dc6:	20 91 a8 03 	lds	r18, 0x03A8
    4dca:	30 91 a9 03 	lds	r19, 0x03A9
    4dce:	8b 81       	ldd	r24, Y+3	; 0x03
    4dd0:	9c 81       	ldd	r25, Y+4	; 0x04
    4dd2:	28 17       	cp	r18, r24
    4dd4:	39 07       	cpc	r19, r25
    4dd6:	b8 f4       	brcc	.+46     	; 0x4e06 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4dd8:	81 e0       	ldi	r24, 0x01	; 1
    4dda:	89 83       	std	Y+1, r24	; 0x01
    4ddc:	14 c0       	rjmp	.+40     	; 0x4e06 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4dde:	ed 81       	ldd	r30, Y+5	; 0x05
    4de0:	fe 81       	ldd	r31, Y+6	; 0x06
    4de2:	20 81       	ld	r18, Z
    4de4:	31 81       	ldd	r19, Z+1	; 0x01
    4de6:	8b 81       	ldd	r24, Y+3	; 0x03
    4de8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dea:	82 17       	cp	r24, r18
    4dec:	93 07       	cpc	r25, r19
    4dee:	48 f0       	brcs	.+18     	; 0x4e02 <vTaskDelayUntil+0x9a>
    4df0:	20 91 a8 03 	lds	r18, 0x03A8
    4df4:	30 91 a9 03 	lds	r19, 0x03A9
    4df8:	8b 81       	ldd	r24, Y+3	; 0x03
    4dfa:	9c 81       	ldd	r25, Y+4	; 0x04
    4dfc:	28 17       	cp	r18, r24
    4dfe:	39 07       	cpc	r19, r25
    4e00:	10 f4       	brcc	.+4      	; 0x4e06 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4e02:	81 e0       	ldi	r24, 0x01	; 1
    4e04:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4e06:	ed 81       	ldd	r30, Y+5	; 0x05
    4e08:	fe 81       	ldd	r31, Y+6	; 0x06
    4e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4e0e:	91 83       	std	Z+1, r25	; 0x01
    4e10:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4e12:	89 81       	ldd	r24, Y+1	; 0x01
    4e14:	88 23       	and	r24, r24
    4e16:	59 f0       	breq	.+22     	; 0x4e2e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e18:	80 91 a4 03 	lds	r24, 0x03A4
    4e1c:	90 91 a5 03 	lds	r25, 0x03A5
    4e20:	02 96       	adiw	r24, 0x02	; 2
    4e22:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4e26:	8b 81       	ldd	r24, Y+3	; 0x03
    4e28:	9c 81       	ldd	r25, Y+4	; 0x04
    4e2a:	0e 94 a0 2b 	call	0x5740	; 0x5740 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4e2e:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    4e32:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4e34:	8a 81       	ldd	r24, Y+2	; 0x02
    4e36:	88 23       	and	r24, r24
    4e38:	11 f4       	brne	.+4      	; 0x4e3e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4e3a:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
		}
	}
    4e3e:	28 96       	adiw	r28, 0x08	; 8
    4e40:	0f b6       	in	r0, 0x3f	; 63
    4e42:	f8 94       	cli
    4e44:	de bf       	out	0x3e, r29	; 62
    4e46:	0f be       	out	0x3f, r0	; 63
    4e48:	cd bf       	out	0x3d, r28	; 61
    4e4a:	cf 91       	pop	r28
    4e4c:	df 91       	pop	r29
    4e4e:	08 95       	ret

00004e50 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4e50:	df 93       	push	r29
    4e52:	cf 93       	push	r28
    4e54:	00 d0       	rcall	.+0      	; 0x4e56 <vTaskDelay+0x6>
    4e56:	00 d0       	rcall	.+0      	; 0x4e58 <vTaskDelay+0x8>
    4e58:	0f 92       	push	r0
    4e5a:	cd b7       	in	r28, 0x3d	; 61
    4e5c:	de b7       	in	r29, 0x3e	; 62
    4e5e:	9d 83       	std	Y+5, r25	; 0x05
    4e60:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4e62:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4e64:	8c 81       	ldd	r24, Y+4	; 0x04
    4e66:	9d 81       	ldd	r25, Y+5	; 0x05
    4e68:	00 97       	sbiw	r24, 0x00	; 0
    4e6a:	d1 f0       	breq	.+52     	; 0x4ea0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4e6c:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4e70:	20 91 a8 03 	lds	r18, 0x03A8
    4e74:	30 91 a9 03 	lds	r19, 0x03A9
    4e78:	8c 81       	ldd	r24, Y+4	; 0x04
    4e7a:	9d 81       	ldd	r25, Y+5	; 0x05
    4e7c:	82 0f       	add	r24, r18
    4e7e:	93 1f       	adc	r25, r19
    4e80:	9b 83       	std	Y+3, r25	; 0x03
    4e82:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e84:	80 91 a4 03 	lds	r24, 0x03A4
    4e88:	90 91 a5 03 	lds	r25, 0x03A5
    4e8c:	02 96       	adiw	r24, 0x02	; 2
    4e8e:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4e92:	8a 81       	ldd	r24, Y+2	; 0x02
    4e94:	9b 81       	ldd	r25, Y+3	; 0x03
    4e96:	0e 94 a0 2b 	call	0x5740	; 0x5740 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4e9a:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>
    4e9e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4ea0:	89 81       	ldd	r24, Y+1	; 0x01
    4ea2:	88 23       	and	r24, r24
    4ea4:	11 f4       	brne	.+4      	; 0x4eaa <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4ea6:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
		}
	}
    4eaa:	0f 90       	pop	r0
    4eac:	0f 90       	pop	r0
    4eae:	0f 90       	pop	r0
    4eb0:	0f 90       	pop	r0
    4eb2:	0f 90       	pop	r0
    4eb4:	cf 91       	pop	r28
    4eb6:	df 91       	pop	r29
    4eb8:	08 95       	ret

00004eba <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4eba:	af 92       	push	r10
    4ebc:	bf 92       	push	r11
    4ebe:	cf 92       	push	r12
    4ec0:	df 92       	push	r13
    4ec2:	ef 92       	push	r14
    4ec4:	ff 92       	push	r15
    4ec6:	0f 93       	push	r16
    4ec8:	df 93       	push	r29
    4eca:	cf 93       	push	r28
    4ecc:	0f 92       	push	r0
    4ece:	cd b7       	in	r28, 0x3d	; 61
    4ed0:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4ed2:	20 e0       	ldi	r18, 0x00	; 0
    4ed4:	31 e0       	ldi	r19, 0x01	; 1
    4ed6:	84 ec       	ldi	r24, 0xC4	; 196
    4ed8:	9a e2       	ldi	r25, 0x2A	; 42
    4eda:	b9 01       	movw	r22, r18
    4edc:	45 e5       	ldi	r20, 0x55	; 85
    4ede:	50 e0       	ldi	r21, 0x00	; 0
    4ee0:	20 e0       	ldi	r18, 0x00	; 0
    4ee2:	30 e0       	ldi	r19, 0x00	; 0
    4ee4:	00 e0       	ldi	r16, 0x00	; 0
    4ee6:	ee 24       	eor	r14, r14
    4ee8:	ff 24       	eor	r15, r15
    4eea:	cc 24       	eor	r12, r12
    4eec:	dd 24       	eor	r13, r13
    4eee:	aa 24       	eor	r10, r10
    4ef0:	bb 24       	eor	r11, r11
    4ef2:	0e 94 64 25 	call	0x4ac8	; 0x4ac8 <xTaskGenericCreate>
    4ef6:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4ef8:	89 81       	ldd	r24, Y+1	; 0x01
    4efa:	81 30       	cpi	r24, 0x01	; 1
    4efc:	51 f4       	brne	.+20     	; 0x4f12 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4efe:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4f00:	81 e0       	ldi	r24, 0x01	; 1
    4f02:	80 93 ac 03 	sts	0x03AC, r24
		xTickCount = ( portTickType ) 0U;
    4f06:	10 92 a9 03 	sts	0x03A9, r1
    4f0a:	10 92 a8 03 	sts	0x03A8, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4f0e:	0e 94 65 1b 	call	0x36ca	; 0x36ca <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4f12:	0f 90       	pop	r0
    4f14:	cf 91       	pop	r28
    4f16:	df 91       	pop	r29
    4f18:	0f 91       	pop	r16
    4f1a:	ff 90       	pop	r15
    4f1c:	ef 90       	pop	r14
    4f1e:	df 90       	pop	r13
    4f20:	cf 90       	pop	r12
    4f22:	bf 90       	pop	r11
    4f24:	af 90       	pop	r10
    4f26:	08 95       	ret

00004f28 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4f28:	df 93       	push	r29
    4f2a:	cf 93       	push	r28
    4f2c:	cd b7       	in	r28, 0x3d	; 61
    4f2e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4f30:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4f32:	10 92 ac 03 	sts	0x03AC, r1
	vPortEndScheduler();
    4f36:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortEndScheduler>
}
    4f3a:	cf 91       	pop	r28
    4f3c:	df 91       	pop	r29
    4f3e:	08 95       	ret

00004f40 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4f40:	df 93       	push	r29
    4f42:	cf 93       	push	r28
    4f44:	cd b7       	in	r28, 0x3d	; 61
    4f46:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4f48:	80 91 ad 03 	lds	r24, 0x03AD
    4f4c:	8f 5f       	subi	r24, 0xFF	; 255
    4f4e:	80 93 ad 03 	sts	0x03AD, r24
}
    4f52:	cf 91       	pop	r28
    4f54:	df 91       	pop	r29
    4f56:	08 95       	ret

00004f58 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4f58:	df 93       	push	r29
    4f5a:	cf 93       	push	r28
    4f5c:	00 d0       	rcall	.+0      	; 0x4f5e <xTaskResumeAll+0x6>
    4f5e:	00 d0       	rcall	.+0      	; 0x4f60 <xTaskResumeAll+0x8>
    4f60:	cd b7       	in	r28, 0x3d	; 61
    4f62:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4f64:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4f66:	0f b6       	in	r0, 0x3f	; 63
    4f68:	f8 94       	cli
    4f6a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4f6c:	80 91 ad 03 	lds	r24, 0x03AD
    4f70:	81 50       	subi	r24, 0x01	; 1
    4f72:	80 93 ad 03 	sts	0x03AD, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4f76:	80 91 ad 03 	lds	r24, 0x03AD
    4f7a:	88 23       	and	r24, r24
    4f7c:	09 f0       	breq	.+2      	; 0x4f80 <xTaskResumeAll+0x28>
    4f7e:	6c c0       	rjmp	.+216    	; 0x5058 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4f80:	80 91 a7 03 	lds	r24, 0x03A7
    4f84:	88 23       	and	r24, r24
    4f86:	09 f4       	brne	.+2      	; 0x4f8a <xTaskResumeAll+0x32>
    4f88:	67 c0       	rjmp	.+206    	; 0x5058 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4f8a:	19 82       	std	Y+1, r1	; 0x01
    4f8c:	41 c0       	rjmp	.+130    	; 0x5010 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4f8e:	e0 91 e8 03 	lds	r30, 0x03E8
    4f92:	f0 91 e9 03 	lds	r31, 0x03E9
    4f96:	86 81       	ldd	r24, Z+6	; 0x06
    4f98:	97 81       	ldd	r25, Z+7	; 0x07
    4f9a:	9c 83       	std	Y+4, r25	; 0x04
    4f9c:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4f9e:	8b 81       	ldd	r24, Y+3	; 0x03
    4fa0:	9c 81       	ldd	r25, Y+4	; 0x04
    4fa2:	0c 96       	adiw	r24, 0x0c	; 12
    4fa4:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4fa8:	8b 81       	ldd	r24, Y+3	; 0x03
    4faa:	9c 81       	ldd	r25, Y+4	; 0x04
    4fac:	02 96       	adiw	r24, 0x02	; 2
    4fae:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fb6:	96 89       	ldd	r25, Z+22	; 0x16
    4fb8:	80 91 ab 03 	lds	r24, 0x03AB
    4fbc:	89 17       	cp	r24, r25
    4fbe:	28 f4       	brcc	.+10     	; 0x4fca <xTaskResumeAll+0x72>
    4fc0:	eb 81       	ldd	r30, Y+3	; 0x03
    4fc2:	fc 81       	ldd	r31, Y+4	; 0x04
    4fc4:	86 89       	ldd	r24, Z+22	; 0x16
    4fc6:	80 93 ab 03 	sts	0x03AB, r24
    4fca:	eb 81       	ldd	r30, Y+3	; 0x03
    4fcc:	fc 81       	ldd	r31, Y+4	; 0x04
    4fce:	86 89       	ldd	r24, Z+22	; 0x16
    4fd0:	28 2f       	mov	r18, r24
    4fd2:	30 e0       	ldi	r19, 0x00	; 0
    4fd4:	c9 01       	movw	r24, r18
    4fd6:	88 0f       	add	r24, r24
    4fd8:	99 1f       	adc	r25, r25
    4fda:	88 0f       	add	r24, r24
    4fdc:	99 1f       	adc	r25, r25
    4fde:	88 0f       	add	r24, r24
    4fe0:	99 1f       	adc	r25, r25
    4fe2:	82 0f       	add	r24, r18
    4fe4:	93 1f       	adc	r25, r19
    4fe6:	8e 54       	subi	r24, 0x4E	; 78
    4fe8:	9c 4f       	sbci	r25, 0xFC	; 252
    4fea:	2b 81       	ldd	r18, Y+3	; 0x03
    4fec:	3c 81       	ldd	r19, Y+4	; 0x04
    4fee:	2e 5f       	subi	r18, 0xFE	; 254
    4ff0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ff2:	b9 01       	movw	r22, r18
    4ff4:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    4ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    4ffc:	96 89       	ldd	r25, Z+22	; 0x16
    4ffe:	e0 91 a4 03 	lds	r30, 0x03A4
    5002:	f0 91 a5 03 	lds	r31, 0x03A5
    5006:	86 89       	ldd	r24, Z+22	; 0x16
    5008:	98 17       	cp	r25, r24
    500a:	10 f0       	brcs	.+4      	; 0x5010 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    500c:	81 e0       	ldi	r24, 0x01	; 1
    500e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    5010:	80 91 e3 03 	lds	r24, 0x03E3
    5014:	88 23       	and	r24, r24
    5016:	09 f0       	breq	.+2      	; 0x501a <xTaskResumeAll+0xc2>
    5018:	ba cf       	rjmp	.-140    	; 0x4f8e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    501a:	80 91 ae 03 	lds	r24, 0x03AE
    501e:	88 23       	and	r24, r24
    5020:	71 f0       	breq	.+28     	; 0x503e <xTaskResumeAll+0xe6>
    5022:	07 c0       	rjmp	.+14     	; 0x5032 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    5024:	0e 94 6b 28 	call	0x50d6	; 0x50d6 <vTaskIncrementTick>
						--uxMissedTicks;
    5028:	80 91 ae 03 	lds	r24, 0x03AE
    502c:	81 50       	subi	r24, 0x01	; 1
    502e:	80 93 ae 03 	sts	0x03AE, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    5032:	80 91 ae 03 	lds	r24, 0x03AE
    5036:	88 23       	and	r24, r24
    5038:	a9 f7       	brne	.-22     	; 0x5024 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    503a:	81 e0       	ldi	r24, 0x01	; 1
    503c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    503e:	89 81       	ldd	r24, Y+1	; 0x01
    5040:	81 30       	cpi	r24, 0x01	; 1
    5042:	21 f0       	breq	.+8      	; 0x504c <xTaskResumeAll+0xf4>
    5044:	80 91 af 03 	lds	r24, 0x03AF
    5048:	81 30       	cpi	r24, 0x01	; 1
    504a:	31 f4       	brne	.+12     	; 0x5058 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    504c:	81 e0       	ldi	r24, 0x01	; 1
    504e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    5050:	10 92 af 03 	sts	0x03AF, r1
					portYIELD_WITHIN_API();
    5054:	0e 94 a1 1b 	call	0x3742	; 0x3742 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    5058:	0f 90       	pop	r0
    505a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    505c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    505e:	0f 90       	pop	r0
    5060:	0f 90       	pop	r0
    5062:	0f 90       	pop	r0
    5064:	0f 90       	pop	r0
    5066:	cf 91       	pop	r28
    5068:	df 91       	pop	r29
    506a:	08 95       	ret

0000506c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    506c:	df 93       	push	r29
    506e:	cf 93       	push	r28
    5070:	00 d0       	rcall	.+0      	; 0x5072 <xTaskGetTickCount+0x6>
    5072:	cd b7       	in	r28, 0x3d	; 61
    5074:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    5076:	0f b6       	in	r0, 0x3f	; 63
    5078:	f8 94       	cli
    507a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    507c:	80 91 a8 03 	lds	r24, 0x03A8
    5080:	90 91 a9 03 	lds	r25, 0x03A9
    5084:	9a 83       	std	Y+2, r25	; 0x02
    5086:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5088:	0f 90       	pop	r0
    508a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    508c:	89 81       	ldd	r24, Y+1	; 0x01
    508e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5090:	0f 90       	pop	r0
    5092:	0f 90       	pop	r0
    5094:	cf 91       	pop	r28
    5096:	df 91       	pop	r29
    5098:	08 95       	ret

0000509a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    509a:	df 93       	push	r29
    509c:	cf 93       	push	r28
    509e:	00 d0       	rcall	.+0      	; 0x50a0 <xTaskGetTickCountFromISR+0x6>
    50a0:	0f 92       	push	r0
    50a2:	cd b7       	in	r28, 0x3d	; 61
    50a4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    50a6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    50a8:	80 91 a8 03 	lds	r24, 0x03A8
    50ac:	90 91 a9 03 	lds	r25, 0x03A9
    50b0:	9b 83       	std	Y+3, r25	; 0x03
    50b2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    50b4:	8a 81       	ldd	r24, Y+2	; 0x02
    50b6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    50b8:	0f 90       	pop	r0
    50ba:	0f 90       	pop	r0
    50bc:	0f 90       	pop	r0
    50be:	cf 91       	pop	r28
    50c0:	df 91       	pop	r29
    50c2:	08 95       	ret

000050c4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    50c4:	df 93       	push	r29
    50c6:	cf 93       	push	r28
    50c8:	cd b7       	in	r28, 0x3d	; 61
    50ca:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    50cc:	80 91 a7 03 	lds	r24, 0x03A7
}
    50d0:	cf 91       	pop	r28
    50d2:	df 91       	pop	r29
    50d4:	08 95       	ret

000050d6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    50d6:	df 93       	push	r29
    50d8:	cf 93       	push	r28
    50da:	00 d0       	rcall	.+0      	; 0x50dc <vTaskIncrementTick+0x6>
    50dc:	00 d0       	rcall	.+0      	; 0x50de <vTaskIncrementTick+0x8>
    50de:	00 d0       	rcall	.+0      	; 0x50e0 <vTaskIncrementTick+0xa>
    50e0:	cd b7       	in	r28, 0x3d	; 61
    50e2:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    50e4:	80 91 ad 03 	lds	r24, 0x03AD
    50e8:	88 23       	and	r24, r24
    50ea:	09 f0       	breq	.+2      	; 0x50ee <vTaskIncrementTick+0x18>
    50ec:	bb c0       	rjmp	.+374    	; 0x5264 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    50ee:	80 91 a8 03 	lds	r24, 0x03A8
    50f2:	90 91 a9 03 	lds	r25, 0x03A9
    50f6:	01 96       	adiw	r24, 0x01	; 1
    50f8:	90 93 a9 03 	sts	0x03A9, r25
    50fc:	80 93 a8 03 	sts	0x03A8, r24
		if( xTickCount == ( portTickType ) 0U )
    5100:	80 91 a8 03 	lds	r24, 0x03A8
    5104:	90 91 a9 03 	lds	r25, 0x03A9
    5108:	00 97       	sbiw	r24, 0x00	; 0
    510a:	d1 f5       	brne	.+116    	; 0x5180 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    510c:	80 91 df 03 	lds	r24, 0x03DF
    5110:	90 91 e0 03 	lds	r25, 0x03E0
    5114:	9c 83       	std	Y+4, r25	; 0x04
    5116:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    5118:	80 91 e1 03 	lds	r24, 0x03E1
    511c:	90 91 e2 03 	lds	r25, 0x03E2
    5120:	90 93 e0 03 	sts	0x03E0, r25
    5124:	80 93 df 03 	sts	0x03DF, r24
			pxOverflowDelayedTaskList = pxTemp;
    5128:	8b 81       	ldd	r24, Y+3	; 0x03
    512a:	9c 81       	ldd	r25, Y+4	; 0x04
    512c:	90 93 e2 03 	sts	0x03E2, r25
    5130:	80 93 e1 03 	sts	0x03E1, r24
			xNumOfOverflows++;
    5134:	80 91 b0 03 	lds	r24, 0x03B0
    5138:	8f 5f       	subi	r24, 0xFF	; 255
    513a:	80 93 b0 03 	sts	0x03B0, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    513e:	e0 91 df 03 	lds	r30, 0x03DF
    5142:	f0 91 e0 03 	lds	r31, 0x03E0
    5146:	80 81       	ld	r24, Z
    5148:	88 23       	and	r24, r24
    514a:	39 f4       	brne	.+14     	; 0x515a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    514c:	8f ef       	ldi	r24, 0xFF	; 255
    514e:	9f ef       	ldi	r25, 0xFF	; 255
    5150:	90 93 0e 01 	sts	0x010E, r25
    5154:	80 93 0d 01 	sts	0x010D, r24
    5158:	13 c0       	rjmp	.+38     	; 0x5180 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    515a:	e0 91 df 03 	lds	r30, 0x03DF
    515e:	f0 91 e0 03 	lds	r31, 0x03E0
    5162:	05 80       	ldd	r0, Z+5	; 0x05
    5164:	f6 81       	ldd	r31, Z+6	; 0x06
    5166:	e0 2d       	mov	r30, r0
    5168:	86 81       	ldd	r24, Z+6	; 0x06
    516a:	97 81       	ldd	r25, Z+7	; 0x07
    516c:	9e 83       	std	Y+6, r25	; 0x06
    516e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    5170:	ed 81       	ldd	r30, Y+5	; 0x05
    5172:	fe 81       	ldd	r31, Y+6	; 0x06
    5174:	82 81       	ldd	r24, Z+2	; 0x02
    5176:	93 81       	ldd	r25, Z+3	; 0x03
    5178:	90 93 0e 01 	sts	0x010E, r25
    517c:	80 93 0d 01 	sts	0x010D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    5180:	20 91 a8 03 	lds	r18, 0x03A8
    5184:	30 91 a9 03 	lds	r19, 0x03A9
    5188:	80 91 0d 01 	lds	r24, 0x010D
    518c:	90 91 0e 01 	lds	r25, 0x010E
    5190:	28 17       	cp	r18, r24
    5192:	39 07       	cpc	r19, r25
    5194:	08 f4       	brcc	.+2      	; 0x5198 <vTaskIncrementTick+0xc2>
    5196:	6b c0       	rjmp	.+214    	; 0x526e <vTaskIncrementTick+0x198>
    5198:	e0 91 df 03 	lds	r30, 0x03DF
    519c:	f0 91 e0 03 	lds	r31, 0x03E0
    51a0:	80 81       	ld	r24, Z
    51a2:	88 23       	and	r24, r24
    51a4:	39 f4       	brne	.+14     	; 0x51b4 <vTaskIncrementTick+0xde>
    51a6:	8f ef       	ldi	r24, 0xFF	; 255
    51a8:	9f ef       	ldi	r25, 0xFF	; 255
    51aa:	90 93 0e 01 	sts	0x010E, r25
    51ae:	80 93 0d 01 	sts	0x010D, r24
    51b2:	5d c0       	rjmp	.+186    	; 0x526e <vTaskIncrementTick+0x198>
    51b4:	e0 91 df 03 	lds	r30, 0x03DF
    51b8:	f0 91 e0 03 	lds	r31, 0x03E0
    51bc:	05 80       	ldd	r0, Z+5	; 0x05
    51be:	f6 81       	ldd	r31, Z+6	; 0x06
    51c0:	e0 2d       	mov	r30, r0
    51c2:	86 81       	ldd	r24, Z+6	; 0x06
    51c4:	97 81       	ldd	r25, Z+7	; 0x07
    51c6:	9e 83       	std	Y+6, r25	; 0x06
    51c8:	8d 83       	std	Y+5, r24	; 0x05
    51ca:	ed 81       	ldd	r30, Y+5	; 0x05
    51cc:	fe 81       	ldd	r31, Y+6	; 0x06
    51ce:	82 81       	ldd	r24, Z+2	; 0x02
    51d0:	93 81       	ldd	r25, Z+3	; 0x03
    51d2:	9a 83       	std	Y+2, r25	; 0x02
    51d4:	89 83       	std	Y+1, r24	; 0x01
    51d6:	20 91 a8 03 	lds	r18, 0x03A8
    51da:	30 91 a9 03 	lds	r19, 0x03A9
    51de:	89 81       	ldd	r24, Y+1	; 0x01
    51e0:	9a 81       	ldd	r25, Y+2	; 0x02
    51e2:	28 17       	cp	r18, r24
    51e4:	39 07       	cpc	r19, r25
    51e6:	38 f4       	brcc	.+14     	; 0x51f6 <vTaskIncrementTick+0x120>
    51e8:	89 81       	ldd	r24, Y+1	; 0x01
    51ea:	9a 81       	ldd	r25, Y+2	; 0x02
    51ec:	90 93 0e 01 	sts	0x010E, r25
    51f0:	80 93 0d 01 	sts	0x010D, r24
    51f4:	3c c0       	rjmp	.+120    	; 0x526e <vTaskIncrementTick+0x198>
    51f6:	8d 81       	ldd	r24, Y+5	; 0x05
    51f8:	9e 81       	ldd	r25, Y+6	; 0x06
    51fa:	02 96       	adiw	r24, 0x02	; 2
    51fc:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
    5200:	ed 81       	ldd	r30, Y+5	; 0x05
    5202:	fe 81       	ldd	r31, Y+6	; 0x06
    5204:	84 89       	ldd	r24, Z+20	; 0x14
    5206:	95 89       	ldd	r25, Z+21	; 0x15
    5208:	00 97       	sbiw	r24, 0x00	; 0
    520a:	29 f0       	breq	.+10     	; 0x5216 <vTaskIncrementTick+0x140>
    520c:	8d 81       	ldd	r24, Y+5	; 0x05
    520e:	9e 81       	ldd	r25, Y+6	; 0x06
    5210:	0c 96       	adiw	r24, 0x0c	; 12
    5212:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
    5216:	ed 81       	ldd	r30, Y+5	; 0x05
    5218:	fe 81       	ldd	r31, Y+6	; 0x06
    521a:	96 89       	ldd	r25, Z+22	; 0x16
    521c:	80 91 ab 03 	lds	r24, 0x03AB
    5220:	89 17       	cp	r24, r25
    5222:	28 f4       	brcc	.+10     	; 0x522e <vTaskIncrementTick+0x158>
    5224:	ed 81       	ldd	r30, Y+5	; 0x05
    5226:	fe 81       	ldd	r31, Y+6	; 0x06
    5228:	86 89       	ldd	r24, Z+22	; 0x16
    522a:	80 93 ab 03 	sts	0x03AB, r24
    522e:	ed 81       	ldd	r30, Y+5	; 0x05
    5230:	fe 81       	ldd	r31, Y+6	; 0x06
    5232:	86 89       	ldd	r24, Z+22	; 0x16
    5234:	28 2f       	mov	r18, r24
    5236:	30 e0       	ldi	r19, 0x00	; 0
    5238:	c9 01       	movw	r24, r18
    523a:	88 0f       	add	r24, r24
    523c:	99 1f       	adc	r25, r25
    523e:	88 0f       	add	r24, r24
    5240:	99 1f       	adc	r25, r25
    5242:	88 0f       	add	r24, r24
    5244:	99 1f       	adc	r25, r25
    5246:	82 0f       	add	r24, r18
    5248:	93 1f       	adc	r25, r19
    524a:	ac 01       	movw	r20, r24
    524c:	4e 54       	subi	r20, 0x4E	; 78
    524e:	5c 4f       	sbci	r21, 0xFC	; 252
    5250:	8d 81       	ldd	r24, Y+5	; 0x05
    5252:	9e 81       	ldd	r25, Y+6	; 0x06
    5254:	9c 01       	movw	r18, r24
    5256:	2e 5f       	subi	r18, 0xFE	; 254
    5258:	3f 4f       	sbci	r19, 0xFF	; 255
    525a:	ca 01       	movw	r24, r20
    525c:	b9 01       	movw	r22, r18
    525e:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>
    5262:	9a cf       	rjmp	.-204    	; 0x5198 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    5264:	80 91 ae 03 	lds	r24, 0x03AE
    5268:	8f 5f       	subi	r24, 0xFF	; 255
    526a:	80 93 ae 03 	sts	0x03AE, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    526e:	26 96       	adiw	r28, 0x06	; 6
    5270:	0f b6       	in	r0, 0x3f	; 63
    5272:	f8 94       	cli
    5274:	de bf       	out	0x3e, r29	; 62
    5276:	0f be       	out	0x3f, r0	; 63
    5278:	cd bf       	out	0x3d, r28	; 61
    527a:	cf 91       	pop	r28
    527c:	df 91       	pop	r29
    527e:	08 95       	ret

00005280 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5280:	df 93       	push	r29
    5282:	cf 93       	push	r28
    5284:	00 d0       	rcall	.+0      	; 0x5286 <vTaskSwitchContext+0x6>
    5286:	cd b7       	in	r28, 0x3d	; 61
    5288:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    528a:	80 91 ad 03 	lds	r24, 0x03AD
    528e:	88 23       	and	r24, r24
    5290:	49 f0       	breq	.+18     	; 0x52a4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    5292:	81 e0       	ldi	r24, 0x01	; 1
    5294:	80 93 af 03 	sts	0x03AF, r24
    5298:	54 c0       	rjmp	.+168    	; 0x5342 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    529a:	80 91 ab 03 	lds	r24, 0x03AB
    529e:	81 50       	subi	r24, 0x01	; 1
    52a0:	80 93 ab 03 	sts	0x03AB, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    52a4:	80 91 ab 03 	lds	r24, 0x03AB
    52a8:	28 2f       	mov	r18, r24
    52aa:	30 e0       	ldi	r19, 0x00	; 0
    52ac:	c9 01       	movw	r24, r18
    52ae:	88 0f       	add	r24, r24
    52b0:	99 1f       	adc	r25, r25
    52b2:	88 0f       	add	r24, r24
    52b4:	99 1f       	adc	r25, r25
    52b6:	88 0f       	add	r24, r24
    52b8:	99 1f       	adc	r25, r25
    52ba:	82 0f       	add	r24, r18
    52bc:	93 1f       	adc	r25, r19
    52be:	fc 01       	movw	r30, r24
    52c0:	ee 54       	subi	r30, 0x4E	; 78
    52c2:	fc 4f       	sbci	r31, 0xFC	; 252
    52c4:	80 81       	ld	r24, Z
    52c6:	88 23       	and	r24, r24
    52c8:	41 f3       	breq	.-48     	; 0x529a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    52ca:	80 91 ab 03 	lds	r24, 0x03AB
    52ce:	28 2f       	mov	r18, r24
    52d0:	30 e0       	ldi	r19, 0x00	; 0
    52d2:	c9 01       	movw	r24, r18
    52d4:	88 0f       	add	r24, r24
    52d6:	99 1f       	adc	r25, r25
    52d8:	88 0f       	add	r24, r24
    52da:	99 1f       	adc	r25, r25
    52dc:	88 0f       	add	r24, r24
    52de:	99 1f       	adc	r25, r25
    52e0:	82 0f       	add	r24, r18
    52e2:	93 1f       	adc	r25, r19
    52e4:	8e 54       	subi	r24, 0x4E	; 78
    52e6:	9c 4f       	sbci	r25, 0xFC	; 252
    52e8:	9a 83       	std	Y+2, r25	; 0x02
    52ea:	89 83       	std	Y+1, r24	; 0x01
    52ec:	e9 81       	ldd	r30, Y+1	; 0x01
    52ee:	fa 81       	ldd	r31, Y+2	; 0x02
    52f0:	01 80       	ldd	r0, Z+1	; 0x01
    52f2:	f2 81       	ldd	r31, Z+2	; 0x02
    52f4:	e0 2d       	mov	r30, r0
    52f6:	82 81       	ldd	r24, Z+2	; 0x02
    52f8:	93 81       	ldd	r25, Z+3	; 0x03
    52fa:	e9 81       	ldd	r30, Y+1	; 0x01
    52fc:	fa 81       	ldd	r31, Y+2	; 0x02
    52fe:	92 83       	std	Z+2, r25	; 0x02
    5300:	81 83       	std	Z+1, r24	; 0x01
    5302:	e9 81       	ldd	r30, Y+1	; 0x01
    5304:	fa 81       	ldd	r31, Y+2	; 0x02
    5306:	21 81       	ldd	r18, Z+1	; 0x01
    5308:	32 81       	ldd	r19, Z+2	; 0x02
    530a:	89 81       	ldd	r24, Y+1	; 0x01
    530c:	9a 81       	ldd	r25, Y+2	; 0x02
    530e:	03 96       	adiw	r24, 0x03	; 3
    5310:	28 17       	cp	r18, r24
    5312:	39 07       	cpc	r19, r25
    5314:	59 f4       	brne	.+22     	; 0x532c <vTaskSwitchContext+0xac>
    5316:	e9 81       	ldd	r30, Y+1	; 0x01
    5318:	fa 81       	ldd	r31, Y+2	; 0x02
    531a:	01 80       	ldd	r0, Z+1	; 0x01
    531c:	f2 81       	ldd	r31, Z+2	; 0x02
    531e:	e0 2d       	mov	r30, r0
    5320:	82 81       	ldd	r24, Z+2	; 0x02
    5322:	93 81       	ldd	r25, Z+3	; 0x03
    5324:	e9 81       	ldd	r30, Y+1	; 0x01
    5326:	fa 81       	ldd	r31, Y+2	; 0x02
    5328:	92 83       	std	Z+2, r25	; 0x02
    532a:	81 83       	std	Z+1, r24	; 0x01
    532c:	e9 81       	ldd	r30, Y+1	; 0x01
    532e:	fa 81       	ldd	r31, Y+2	; 0x02
    5330:	01 80       	ldd	r0, Z+1	; 0x01
    5332:	f2 81       	ldd	r31, Z+2	; 0x02
    5334:	e0 2d       	mov	r30, r0
    5336:	86 81       	ldd	r24, Z+6	; 0x06
    5338:	97 81       	ldd	r25, Z+7	; 0x07
    533a:	90 93 a5 03 	sts	0x03A5, r25
    533e:	80 93 a4 03 	sts	0x03A4, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    5342:	0f 90       	pop	r0
    5344:	0f 90       	pop	r0
    5346:	cf 91       	pop	r28
    5348:	df 91       	pop	r29
    534a:	08 95       	ret

0000534c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    534c:	df 93       	push	r29
    534e:	cf 93       	push	r28
    5350:	00 d0       	rcall	.+0      	; 0x5352 <vTaskPlaceOnEventList+0x6>
    5352:	00 d0       	rcall	.+0      	; 0x5354 <vTaskPlaceOnEventList+0x8>
    5354:	00 d0       	rcall	.+0      	; 0x5356 <vTaskPlaceOnEventList+0xa>
    5356:	cd b7       	in	r28, 0x3d	; 61
    5358:	de b7       	in	r29, 0x3e	; 62
    535a:	9c 83       	std	Y+4, r25	; 0x04
    535c:	8b 83       	std	Y+3, r24	; 0x03
    535e:	7e 83       	std	Y+6, r23	; 0x06
    5360:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    5362:	4b 81       	ldd	r20, Y+3	; 0x03
    5364:	5c 81       	ldd	r21, Y+4	; 0x04
    5366:	80 91 a4 03 	lds	r24, 0x03A4
    536a:	90 91 a5 03 	lds	r25, 0x03A5
    536e:	9c 01       	movw	r18, r24
    5370:	24 5f       	subi	r18, 0xF4	; 244
    5372:	3f 4f       	sbci	r19, 0xFF	; 255
    5374:	ca 01       	movw	r24, r20
    5376:	b9 01       	movw	r22, r18
    5378:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    537c:	80 91 a4 03 	lds	r24, 0x03A4
    5380:	90 91 a5 03 	lds	r25, 0x03A5
    5384:	02 96       	adiw	r24, 0x02	; 2
    5386:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    538a:	20 91 a8 03 	lds	r18, 0x03A8
    538e:	30 91 a9 03 	lds	r19, 0x03A9
    5392:	8d 81       	ldd	r24, Y+5	; 0x05
    5394:	9e 81       	ldd	r25, Y+6	; 0x06
    5396:	82 0f       	add	r24, r18
    5398:	93 1f       	adc	r25, r19
    539a:	9a 83       	std	Y+2, r25	; 0x02
    539c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    539e:	89 81       	ldd	r24, Y+1	; 0x01
    53a0:	9a 81       	ldd	r25, Y+2	; 0x02
    53a2:	0e 94 a0 2b 	call	0x5740	; 0x5740 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    53a6:	26 96       	adiw	r28, 0x06	; 6
    53a8:	0f b6       	in	r0, 0x3f	; 63
    53aa:	f8 94       	cli
    53ac:	de bf       	out	0x3e, r29	; 62
    53ae:	0f be       	out	0x3f, r0	; 63
    53b0:	cd bf       	out	0x3d, r28	; 61
    53b2:	cf 91       	pop	r28
    53b4:	df 91       	pop	r29
    53b6:	08 95       	ret

000053b8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    53b8:	df 93       	push	r29
    53ba:	cf 93       	push	r28
    53bc:	00 d0       	rcall	.+0      	; 0x53be <xTaskRemoveFromEventList+0x6>
    53be:	00 d0       	rcall	.+0      	; 0x53c0 <xTaskRemoveFromEventList+0x8>
    53c0:	0f 92       	push	r0
    53c2:	cd b7       	in	r28, 0x3d	; 61
    53c4:	de b7       	in	r29, 0x3e	; 62
    53c6:	9d 83       	std	Y+5, r25	; 0x05
    53c8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    53ca:	ec 81       	ldd	r30, Y+4	; 0x04
    53cc:	fd 81       	ldd	r31, Y+5	; 0x05
    53ce:	05 80       	ldd	r0, Z+5	; 0x05
    53d0:	f6 81       	ldd	r31, Z+6	; 0x06
    53d2:	e0 2d       	mov	r30, r0
    53d4:	86 81       	ldd	r24, Z+6	; 0x06
    53d6:	97 81       	ldd	r25, Z+7	; 0x07
    53d8:	9b 83       	std	Y+3, r25	; 0x03
    53da:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    53dc:	8a 81       	ldd	r24, Y+2	; 0x02
    53de:	9b 81       	ldd	r25, Y+3	; 0x03
    53e0:	0c 96       	adiw	r24, 0x0c	; 12
    53e2:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    53e6:	80 91 ad 03 	lds	r24, 0x03AD
    53ea:	88 23       	and	r24, r24
    53ec:	61 f5       	brne	.+88     	; 0x5446 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    53ee:	8a 81       	ldd	r24, Y+2	; 0x02
    53f0:	9b 81       	ldd	r25, Y+3	; 0x03
    53f2:	02 96       	adiw	r24, 0x02	; 2
    53f4:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    53f8:	ea 81       	ldd	r30, Y+2	; 0x02
    53fa:	fb 81       	ldd	r31, Y+3	; 0x03
    53fc:	96 89       	ldd	r25, Z+22	; 0x16
    53fe:	80 91 ab 03 	lds	r24, 0x03AB
    5402:	89 17       	cp	r24, r25
    5404:	28 f4       	brcc	.+10     	; 0x5410 <xTaskRemoveFromEventList+0x58>
    5406:	ea 81       	ldd	r30, Y+2	; 0x02
    5408:	fb 81       	ldd	r31, Y+3	; 0x03
    540a:	86 89       	ldd	r24, Z+22	; 0x16
    540c:	80 93 ab 03 	sts	0x03AB, r24
    5410:	ea 81       	ldd	r30, Y+2	; 0x02
    5412:	fb 81       	ldd	r31, Y+3	; 0x03
    5414:	86 89       	ldd	r24, Z+22	; 0x16
    5416:	28 2f       	mov	r18, r24
    5418:	30 e0       	ldi	r19, 0x00	; 0
    541a:	c9 01       	movw	r24, r18
    541c:	88 0f       	add	r24, r24
    541e:	99 1f       	adc	r25, r25
    5420:	88 0f       	add	r24, r24
    5422:	99 1f       	adc	r25, r25
    5424:	88 0f       	add	r24, r24
    5426:	99 1f       	adc	r25, r25
    5428:	82 0f       	add	r24, r18
    542a:	93 1f       	adc	r25, r19
    542c:	ac 01       	movw	r20, r24
    542e:	4e 54       	subi	r20, 0x4E	; 78
    5430:	5c 4f       	sbci	r21, 0xFC	; 252
    5432:	8a 81       	ldd	r24, Y+2	; 0x02
    5434:	9b 81       	ldd	r25, Y+3	; 0x03
    5436:	9c 01       	movw	r18, r24
    5438:	2e 5f       	subi	r18, 0xFE	; 254
    543a:	3f 4f       	sbci	r19, 0xFF	; 255
    543c:	ca 01       	movw	r24, r20
    543e:	b9 01       	movw	r22, r18
    5440:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>
    5444:	0a c0       	rjmp	.+20     	; 0x545a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5446:	8a 81       	ldd	r24, Y+2	; 0x02
    5448:	9b 81       	ldd	r25, Y+3	; 0x03
    544a:	9c 01       	movw	r18, r24
    544c:	24 5f       	subi	r18, 0xF4	; 244
    544e:	3f 4f       	sbci	r19, 0xFF	; 255
    5450:	83 ee       	ldi	r24, 0xE3	; 227
    5452:	93 e0       	ldi	r25, 0x03	; 3
    5454:	b9 01       	movw	r22, r18
    5456:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    545a:	ea 81       	ldd	r30, Y+2	; 0x02
    545c:	fb 81       	ldd	r31, Y+3	; 0x03
    545e:	96 89       	ldd	r25, Z+22	; 0x16
    5460:	e0 91 a4 03 	lds	r30, 0x03A4
    5464:	f0 91 a5 03 	lds	r31, 0x03A5
    5468:	86 89       	ldd	r24, Z+22	; 0x16
    546a:	98 17       	cp	r25, r24
    546c:	18 f0       	brcs	.+6      	; 0x5474 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    546e:	81 e0       	ldi	r24, 0x01	; 1
    5470:	89 83       	std	Y+1, r24	; 0x01
    5472:	01 c0       	rjmp	.+2      	; 0x5476 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    5474:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5476:	89 81       	ldd	r24, Y+1	; 0x01
}
    5478:	0f 90       	pop	r0
    547a:	0f 90       	pop	r0
    547c:	0f 90       	pop	r0
    547e:	0f 90       	pop	r0
    5480:	0f 90       	pop	r0
    5482:	cf 91       	pop	r28
    5484:	df 91       	pop	r29
    5486:	08 95       	ret

00005488 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    5488:	df 93       	push	r29
    548a:	cf 93       	push	r28
    548c:	00 d0       	rcall	.+0      	; 0x548e <vTaskSetTimeOutState+0x6>
    548e:	cd b7       	in	r28, 0x3d	; 61
    5490:	de b7       	in	r29, 0x3e	; 62
    5492:	9a 83       	std	Y+2, r25	; 0x02
    5494:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5496:	80 91 b0 03 	lds	r24, 0x03B0
    549a:	e9 81       	ldd	r30, Y+1	; 0x01
    549c:	fa 81       	ldd	r31, Y+2	; 0x02
    549e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    54a0:	80 91 a8 03 	lds	r24, 0x03A8
    54a4:	90 91 a9 03 	lds	r25, 0x03A9
    54a8:	e9 81       	ldd	r30, Y+1	; 0x01
    54aa:	fa 81       	ldd	r31, Y+2	; 0x02
    54ac:	92 83       	std	Z+2, r25	; 0x02
    54ae:	81 83       	std	Z+1, r24	; 0x01
}
    54b0:	0f 90       	pop	r0
    54b2:	0f 90       	pop	r0
    54b4:	cf 91       	pop	r28
    54b6:	df 91       	pop	r29
    54b8:	08 95       	ret

000054ba <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <xTaskCheckForTimeOut+0x6>
    54c0:	00 d0       	rcall	.+0      	; 0x54c2 <xTaskCheckForTimeOut+0x8>
    54c2:	0f 92       	push	r0
    54c4:	cd b7       	in	r28, 0x3d	; 61
    54c6:	de b7       	in	r29, 0x3e	; 62
    54c8:	9b 83       	std	Y+3, r25	; 0x03
    54ca:	8a 83       	std	Y+2, r24	; 0x02
    54cc:	7d 83       	std	Y+5, r23	; 0x05
    54ce:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    54d0:	0f b6       	in	r0, 0x3f	; 63
    54d2:	f8 94       	cli
    54d4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    54d6:	ea 81       	ldd	r30, Y+2	; 0x02
    54d8:	fb 81       	ldd	r31, Y+3	; 0x03
    54da:	90 81       	ld	r25, Z
    54dc:	80 91 b0 03 	lds	r24, 0x03B0
    54e0:	98 17       	cp	r25, r24
    54e2:	71 f0       	breq	.+28     	; 0x5500 <xTaskCheckForTimeOut+0x46>
    54e4:	ea 81       	ldd	r30, Y+2	; 0x02
    54e6:	fb 81       	ldd	r31, Y+3	; 0x03
    54e8:	21 81       	ldd	r18, Z+1	; 0x01
    54ea:	32 81       	ldd	r19, Z+2	; 0x02
    54ec:	80 91 a8 03 	lds	r24, 0x03A8
    54f0:	90 91 a9 03 	lds	r25, 0x03A9
    54f4:	82 17       	cp	r24, r18
    54f6:	93 07       	cpc	r25, r19
    54f8:	18 f0       	brcs	.+6      	; 0x5500 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    54fa:	81 e0       	ldi	r24, 0x01	; 1
    54fc:	89 83       	std	Y+1, r24	; 0x01
    54fe:	2f c0       	rjmp	.+94     	; 0x555e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5500:	20 91 a8 03 	lds	r18, 0x03A8
    5504:	30 91 a9 03 	lds	r19, 0x03A9
    5508:	ea 81       	ldd	r30, Y+2	; 0x02
    550a:	fb 81       	ldd	r31, Y+3	; 0x03
    550c:	81 81       	ldd	r24, Z+1	; 0x01
    550e:	92 81       	ldd	r25, Z+2	; 0x02
    5510:	28 1b       	sub	r18, r24
    5512:	39 0b       	sbc	r19, r25
    5514:	ec 81       	ldd	r30, Y+4	; 0x04
    5516:	fd 81       	ldd	r31, Y+5	; 0x05
    5518:	80 81       	ld	r24, Z
    551a:	91 81       	ldd	r25, Z+1	; 0x01
    551c:	28 17       	cp	r18, r24
    551e:	39 07       	cpc	r19, r25
    5520:	e0 f4       	brcc	.+56     	; 0x555a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5522:	ec 81       	ldd	r30, Y+4	; 0x04
    5524:	fd 81       	ldd	r31, Y+5	; 0x05
    5526:	40 81       	ld	r20, Z
    5528:	51 81       	ldd	r21, Z+1	; 0x01
    552a:	ea 81       	ldd	r30, Y+2	; 0x02
    552c:	fb 81       	ldd	r31, Y+3	; 0x03
    552e:	21 81       	ldd	r18, Z+1	; 0x01
    5530:	32 81       	ldd	r19, Z+2	; 0x02
    5532:	80 91 a8 03 	lds	r24, 0x03A8
    5536:	90 91 a9 03 	lds	r25, 0x03A9
    553a:	b9 01       	movw	r22, r18
    553c:	68 1b       	sub	r22, r24
    553e:	79 0b       	sbc	r23, r25
    5540:	cb 01       	movw	r24, r22
    5542:	84 0f       	add	r24, r20
    5544:	95 1f       	adc	r25, r21
    5546:	ec 81       	ldd	r30, Y+4	; 0x04
    5548:	fd 81       	ldd	r31, Y+5	; 0x05
    554a:	91 83       	std	Z+1, r25	; 0x01
    554c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    554e:	8a 81       	ldd	r24, Y+2	; 0x02
    5550:	9b 81       	ldd	r25, Y+3	; 0x03
    5552:	0e 94 44 2a 	call	0x5488	; 0x5488 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5556:	19 82       	std	Y+1, r1	; 0x01
    5558:	02 c0       	rjmp	.+4      	; 0x555e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    555a:	81 e0       	ldi	r24, 0x01	; 1
    555c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    555e:	0f 90       	pop	r0
    5560:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5562:	89 81       	ldd	r24, Y+1	; 0x01
}
    5564:	0f 90       	pop	r0
    5566:	0f 90       	pop	r0
    5568:	0f 90       	pop	r0
    556a:	0f 90       	pop	r0
    556c:	0f 90       	pop	r0
    556e:	cf 91       	pop	r28
    5570:	df 91       	pop	r29
    5572:	08 95       	ret

00005574 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5574:	df 93       	push	r29
    5576:	cf 93       	push	r28
    5578:	cd b7       	in	r28, 0x3d	; 61
    557a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    557c:	81 e0       	ldi	r24, 0x01	; 1
    557e:	80 93 af 03 	sts	0x03AF, r24
}
    5582:	cf 91       	pop	r28
    5584:	df 91       	pop	r29
    5586:	08 95       	ret

00005588 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5588:	df 93       	push	r29
    558a:	cf 93       	push	r28
    558c:	00 d0       	rcall	.+0      	; 0x558e <prvIdleTask+0x6>
    558e:	cd b7       	in	r28, 0x3d	; 61
    5590:	de b7       	in	r29, 0x3e	; 62
    5592:	9a 83       	std	Y+2, r25	; 0x02
    5594:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5596:	0e 94 62 2b 	call	0x56c4	; 0x56c4 <prvCheckTasksWaitingTermination>
    559a:	fd cf       	rjmp	.-6      	; 0x5596 <prvIdleTask+0xe>

0000559c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    559c:	0f 93       	push	r16
    559e:	1f 93       	push	r17
    55a0:	df 93       	push	r29
    55a2:	cf 93       	push	r28
    55a4:	cd b7       	in	r28, 0x3d	; 61
    55a6:	de b7       	in	r29, 0x3e	; 62
    55a8:	29 97       	sbiw	r28, 0x09	; 9
    55aa:	0f b6       	in	r0, 0x3f	; 63
    55ac:	f8 94       	cli
    55ae:	de bf       	out	0x3e, r29	; 62
    55b0:	0f be       	out	0x3f, r0	; 63
    55b2:	cd bf       	out	0x3d, r28	; 61
    55b4:	9a 83       	std	Y+2, r25	; 0x02
    55b6:	89 83       	std	Y+1, r24	; 0x01
    55b8:	7c 83       	std	Y+4, r23	; 0x04
    55ba:	6b 83       	std	Y+3, r22	; 0x03
    55bc:	4d 83       	std	Y+5, r20	; 0x05
    55be:	3f 83       	std	Y+7, r19	; 0x07
    55c0:	2e 83       	std	Y+6, r18	; 0x06
    55c2:	19 87       	std	Y+9, r17	; 0x09
    55c4:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    55c6:	89 81       	ldd	r24, Y+1	; 0x01
    55c8:	9a 81       	ldd	r25, Y+2	; 0x02
    55ca:	49 96       	adiw	r24, 0x19	; 25
    55cc:	2b 81       	ldd	r18, Y+3	; 0x03
    55ce:	3c 81       	ldd	r19, Y+4	; 0x04
    55d0:	b9 01       	movw	r22, r18
    55d2:	44 e1       	ldi	r20, 0x14	; 20
    55d4:	50 e0       	ldi	r21, 0x00	; 0
    55d6:	0e 94 b1 2e 	call	0x5d62	; 0x5d62 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    55da:	e9 81       	ldd	r30, Y+1	; 0x01
    55dc:	fa 81       	ldd	r31, Y+2	; 0x02
    55de:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    55e0:	8d 81       	ldd	r24, Y+5	; 0x05
    55e2:	83 30       	cpi	r24, 0x03	; 3
    55e4:	10 f0       	brcs	.+4      	; 0x55ea <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    55e6:	82 e0       	ldi	r24, 0x02	; 2
    55e8:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    55ea:	e9 81       	ldd	r30, Y+1	; 0x01
    55ec:	fa 81       	ldd	r31, Y+2	; 0x02
    55ee:	8d 81       	ldd	r24, Y+5	; 0x05
    55f0:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    55f2:	89 81       	ldd	r24, Y+1	; 0x01
    55f4:	9a 81       	ldd	r25, Y+2	; 0x02
    55f6:	02 96       	adiw	r24, 0x02	; 2
    55f8:	0e 94 c3 18 	call	0x3186	; 0x3186 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    55fc:	89 81       	ldd	r24, Y+1	; 0x01
    55fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5600:	0c 96       	adiw	r24, 0x0c	; 12
    5602:	0e 94 c3 18 	call	0x3186	; 0x3186 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    5606:	e9 81       	ldd	r30, Y+1	; 0x01
    5608:	fa 81       	ldd	r31, Y+2	; 0x02
    560a:	89 81       	ldd	r24, Y+1	; 0x01
    560c:	9a 81       	ldd	r25, Y+2	; 0x02
    560e:	91 87       	std	Z+9, r25	; 0x09
    5610:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    5612:	8d 81       	ldd	r24, Y+5	; 0x05
    5614:	28 2f       	mov	r18, r24
    5616:	30 e0       	ldi	r19, 0x00	; 0
    5618:	83 e0       	ldi	r24, 0x03	; 3
    561a:	90 e0       	ldi	r25, 0x00	; 0
    561c:	82 1b       	sub	r24, r18
    561e:	93 0b       	sbc	r25, r19
    5620:	e9 81       	ldd	r30, Y+1	; 0x01
    5622:	fa 81       	ldd	r31, Y+2	; 0x02
    5624:	95 87       	std	Z+13, r25	; 0x0d
    5626:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    5628:	e9 81       	ldd	r30, Y+1	; 0x01
    562a:	fa 81       	ldd	r31, Y+2	; 0x02
    562c:	89 81       	ldd	r24, Y+1	; 0x01
    562e:	9a 81       	ldd	r25, Y+2	; 0x02
    5630:	93 8b       	std	Z+19, r25	; 0x13
    5632:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    5634:	29 96       	adiw	r28, 0x09	; 9
    5636:	0f b6       	in	r0, 0x3f	; 63
    5638:	f8 94       	cli
    563a:	de bf       	out	0x3e, r29	; 62
    563c:	0f be       	out	0x3f, r0	; 63
    563e:	cd bf       	out	0x3d, r28	; 61
    5640:	cf 91       	pop	r28
    5642:	df 91       	pop	r29
    5644:	1f 91       	pop	r17
    5646:	0f 91       	pop	r16
    5648:	08 95       	ret

0000564a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    564a:	df 93       	push	r29
    564c:	cf 93       	push	r28
    564e:	0f 92       	push	r0
    5650:	cd b7       	in	r28, 0x3d	; 61
    5652:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5654:	19 82       	std	Y+1, r1	; 0x01
    5656:	13 c0       	rjmp	.+38     	; 0x567e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5658:	89 81       	ldd	r24, Y+1	; 0x01
    565a:	28 2f       	mov	r18, r24
    565c:	30 e0       	ldi	r19, 0x00	; 0
    565e:	c9 01       	movw	r24, r18
    5660:	88 0f       	add	r24, r24
    5662:	99 1f       	adc	r25, r25
    5664:	88 0f       	add	r24, r24
    5666:	99 1f       	adc	r25, r25
    5668:	88 0f       	add	r24, r24
    566a:	99 1f       	adc	r25, r25
    566c:	82 0f       	add	r24, r18
    566e:	93 1f       	adc	r25, r19
    5670:	8e 54       	subi	r24, 0x4E	; 78
    5672:	9c 4f       	sbci	r25, 0xFC	; 252
    5674:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5678:	89 81       	ldd	r24, Y+1	; 0x01
    567a:	8f 5f       	subi	r24, 0xFF	; 255
    567c:	89 83       	std	Y+1, r24	; 0x01
    567e:	89 81       	ldd	r24, Y+1	; 0x01
    5680:	83 30       	cpi	r24, 0x03	; 3
    5682:	50 f3       	brcs	.-44     	; 0x5658 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    5684:	8d ec       	ldi	r24, 0xCD	; 205
    5686:	93 e0       	ldi	r25, 0x03	; 3
    5688:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    568c:	86 ed       	ldi	r24, 0xD6	; 214
    568e:	93 e0       	ldi	r25, 0x03	; 3
    5690:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    5694:	83 ee       	ldi	r24, 0xE3	; 227
    5696:	93 e0       	ldi	r25, 0x03	; 3
    5698:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    569c:	8c ee       	ldi	r24, 0xEC	; 236
    569e:	93 e0       	ldi	r25, 0x03	; 3
    56a0:	0e 94 99 18 	call	0x3132	; 0x3132 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    56a4:	8d ec       	ldi	r24, 0xCD	; 205
    56a6:	93 e0       	ldi	r25, 0x03	; 3
    56a8:	90 93 e0 03 	sts	0x03E0, r25
    56ac:	80 93 df 03 	sts	0x03DF, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    56b0:	86 ed       	ldi	r24, 0xD6	; 214
    56b2:	93 e0       	ldi	r25, 0x03	; 3
    56b4:	90 93 e2 03 	sts	0x03E2, r25
    56b8:	80 93 e1 03 	sts	0x03E1, r24
}
    56bc:	0f 90       	pop	r0
    56be:	cf 91       	pop	r28
    56c0:	df 91       	pop	r29
    56c2:	08 95       	ret

000056c4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    56c4:	df 93       	push	r29
    56c6:	cf 93       	push	r28
    56c8:	00 d0       	rcall	.+0      	; 0x56ca <prvCheckTasksWaitingTermination+0x6>
    56ca:	0f 92       	push	r0
    56cc:	cd b7       	in	r28, 0x3d	; 61
    56ce:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    56d0:	80 91 a6 03 	lds	r24, 0x03A6
    56d4:	88 23       	and	r24, r24
    56d6:	71 f1       	breq	.+92     	; 0x5734 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    56d8:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    56dc:	80 91 ec 03 	lds	r24, 0x03EC
    56e0:	1b 82       	std	Y+3, r1	; 0x03
    56e2:	88 23       	and	r24, r24
    56e4:	11 f4       	brne	.+4      	; 0x56ea <prvCheckTasksWaitingTermination+0x26>
    56e6:	81 e0       	ldi	r24, 0x01	; 1
    56e8:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    56ea:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    56ee:	8b 81       	ldd	r24, Y+3	; 0x03
    56f0:	88 23       	and	r24, r24
    56f2:	01 f5       	brne	.+64     	; 0x5734 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    56f4:	0f b6       	in	r0, 0x3f	; 63
    56f6:	f8 94       	cli
    56f8:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    56fa:	e0 91 f1 03 	lds	r30, 0x03F1
    56fe:	f0 91 f2 03 	lds	r31, 0x03F2
    5702:	86 81       	ldd	r24, Z+6	; 0x06
    5704:	97 81       	ldd	r25, Z+7	; 0x07
    5706:	9a 83       	std	Y+2, r25	; 0x02
    5708:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    570a:	89 81       	ldd	r24, Y+1	; 0x01
    570c:	9a 81       	ldd	r25, Y+2	; 0x02
    570e:	02 96       	adiw	r24, 0x02	; 2
    5710:	0e 94 8b 19 	call	0x3316	; 0x3316 <vListRemove>
					--uxCurrentNumberOfTasks;
    5714:	80 91 a7 03 	lds	r24, 0x03A7
    5718:	81 50       	subi	r24, 0x01	; 1
    571a:	80 93 a7 03 	sts	0x03A7, r24
					--uxTasksDeleted;
    571e:	80 91 a6 03 	lds	r24, 0x03A6
    5722:	81 50       	subi	r24, 0x01	; 1
    5724:	80 93 a6 03 	sts	0x03A6, r24
				}
				taskEXIT_CRITICAL();
    5728:	0f 90       	pop	r0
    572a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    572c:	89 81       	ldd	r24, Y+1	; 0x01
    572e:	9a 81       	ldd	r25, Y+2	; 0x02
    5730:	0e 94 39 2c 	call	0x5872	; 0x5872 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    5734:	0f 90       	pop	r0
    5736:	0f 90       	pop	r0
    5738:	0f 90       	pop	r0
    573a:	cf 91       	pop	r28
    573c:	df 91       	pop	r29
    573e:	08 95       	ret

00005740 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    5740:	df 93       	push	r29
    5742:	cf 93       	push	r28
    5744:	00 d0       	rcall	.+0      	; 0x5746 <prvAddCurrentTaskToDelayedList+0x6>
    5746:	cd b7       	in	r28, 0x3d	; 61
    5748:	de b7       	in	r29, 0x3e	; 62
    574a:	9a 83       	std	Y+2, r25	; 0x02
    574c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    574e:	e0 91 a4 03 	lds	r30, 0x03A4
    5752:	f0 91 a5 03 	lds	r31, 0x03A5
    5756:	89 81       	ldd	r24, Y+1	; 0x01
    5758:	9a 81       	ldd	r25, Y+2	; 0x02
    575a:	93 83       	std	Z+3, r25	; 0x03
    575c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    575e:	20 91 a8 03 	lds	r18, 0x03A8
    5762:	30 91 a9 03 	lds	r19, 0x03A9
    5766:	89 81       	ldd	r24, Y+1	; 0x01
    5768:	9a 81       	ldd	r25, Y+2	; 0x02
    576a:	82 17       	cp	r24, r18
    576c:	93 07       	cpc	r25, r19
    576e:	70 f4       	brcc	.+28     	; 0x578c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5770:	80 91 e1 03 	lds	r24, 0x03E1
    5774:	90 91 e2 03 	lds	r25, 0x03E2
    5778:	20 91 a4 03 	lds	r18, 0x03A4
    577c:	30 91 a5 03 	lds	r19, 0x03A5
    5780:	2e 5f       	subi	r18, 0xFE	; 254
    5782:	3f 4f       	sbci	r19, 0xFF	; 255
    5784:	b9 01       	movw	r22, r18
    5786:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>
    578a:	1e c0       	rjmp	.+60     	; 0x57c8 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    578c:	40 91 df 03 	lds	r20, 0x03DF
    5790:	50 91 e0 03 	lds	r21, 0x03E0
    5794:	80 91 a4 03 	lds	r24, 0x03A4
    5798:	90 91 a5 03 	lds	r25, 0x03A5
    579c:	9c 01       	movw	r18, r24
    579e:	2e 5f       	subi	r18, 0xFE	; 254
    57a0:	3f 4f       	sbci	r19, 0xFF	; 255
    57a2:	ca 01       	movw	r24, r20
    57a4:	b9 01       	movw	r22, r18
    57a6:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    57aa:	20 91 0d 01 	lds	r18, 0x010D
    57ae:	30 91 0e 01 	lds	r19, 0x010E
    57b2:	89 81       	ldd	r24, Y+1	; 0x01
    57b4:	9a 81       	ldd	r25, Y+2	; 0x02
    57b6:	82 17       	cp	r24, r18
    57b8:	93 07       	cpc	r25, r19
    57ba:	30 f4       	brcc	.+12     	; 0x57c8 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    57bc:	89 81       	ldd	r24, Y+1	; 0x01
    57be:	9a 81       	ldd	r25, Y+2	; 0x02
    57c0:	90 93 0e 01 	sts	0x010E, r25
    57c4:	80 93 0d 01 	sts	0x010D, r24
		}
	}
}
    57c8:	0f 90       	pop	r0
    57ca:	0f 90       	pop	r0
    57cc:	cf 91       	pop	r28
    57ce:	df 91       	pop	r29
    57d0:	08 95       	ret

000057d2 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    57d2:	df 93       	push	r29
    57d4:	cf 93       	push	r28
    57d6:	cd b7       	in	r28, 0x3d	; 61
    57d8:	de b7       	in	r29, 0x3e	; 62
    57da:	28 97       	sbiw	r28, 0x08	; 8
    57dc:	0f b6       	in	r0, 0x3f	; 63
    57de:	f8 94       	cli
    57e0:	de bf       	out	0x3e, r29	; 62
    57e2:	0f be       	out	0x3f, r0	; 63
    57e4:	cd bf       	out	0x3d, r28	; 61
    57e6:	9c 83       	std	Y+4, r25	; 0x04
    57e8:	8b 83       	std	Y+3, r24	; 0x03
    57ea:	7e 83       	std	Y+6, r23	; 0x06
    57ec:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    57ee:	8d e2       	ldi	r24, 0x2D	; 45
    57f0:	90 e0       	ldi	r25, 0x00	; 0
    57f2:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <pvPortMalloc>
    57f6:	9a 83       	std	Y+2, r25	; 0x02
    57f8:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    57fa:	89 81       	ldd	r24, Y+1	; 0x01
    57fc:	9a 81       	ldd	r25, Y+2	; 0x02
    57fe:	00 97       	sbiw	r24, 0x00	; 0
    5800:	69 f1       	breq	.+90     	; 0x585c <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    5802:	8d 81       	ldd	r24, Y+5	; 0x05
    5804:	9e 81       	ldd	r25, Y+6	; 0x06
    5806:	00 97       	sbiw	r24, 0x00	; 0
    5808:	39 f4       	brne	.+14     	; 0x5818 <prvAllocateTCBAndStack+0x46>
    580a:	8b 81       	ldd	r24, Y+3	; 0x03
    580c:	9c 81       	ldd	r25, Y+4	; 0x04
    580e:	0e 94 7a 17 	call	0x2ef4	; 0x2ef4 <pvPortMalloc>
    5812:	98 87       	std	Y+8, r25	; 0x08
    5814:	8f 83       	std	Y+7, r24	; 0x07
    5816:	04 c0       	rjmp	.+8      	; 0x5820 <prvAllocateTCBAndStack+0x4e>
    5818:	8d 81       	ldd	r24, Y+5	; 0x05
    581a:	9e 81       	ldd	r25, Y+6	; 0x06
    581c:	98 87       	std	Y+8, r25	; 0x08
    581e:	8f 83       	std	Y+7, r24	; 0x07
    5820:	e9 81       	ldd	r30, Y+1	; 0x01
    5822:	fa 81       	ldd	r31, Y+2	; 0x02
    5824:	8f 81       	ldd	r24, Y+7	; 0x07
    5826:	98 85       	ldd	r25, Y+8	; 0x08
    5828:	90 8f       	std	Z+24, r25	; 0x18
    582a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    582c:	e9 81       	ldd	r30, Y+1	; 0x01
    582e:	fa 81       	ldd	r31, Y+2	; 0x02
    5830:	87 89       	ldd	r24, Z+23	; 0x17
    5832:	90 8d       	ldd	r25, Z+24	; 0x18
    5834:	00 97       	sbiw	r24, 0x00	; 0
    5836:	39 f4       	brne	.+14     	; 0x5846 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    5838:	89 81       	ldd	r24, Y+1	; 0x01
    583a:	9a 81       	ldd	r25, Y+2	; 0x02
    583c:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
			pxNewTCB = NULL;
    5840:	1a 82       	std	Y+2, r1	; 0x02
    5842:	19 82       	std	Y+1, r1	; 0x01
    5844:	0b c0       	rjmp	.+22     	; 0x585c <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5846:	e9 81       	ldd	r30, Y+1	; 0x01
    5848:	fa 81       	ldd	r31, Y+2	; 0x02
    584a:	87 89       	ldd	r24, Z+23	; 0x17
    584c:	90 8d       	ldd	r25, Z+24	; 0x18
    584e:	2b 81       	ldd	r18, Y+3	; 0x03
    5850:	3c 81       	ldd	r19, Y+4	; 0x04
    5852:	65 ea       	ldi	r22, 0xA5	; 165
    5854:	70 e0       	ldi	r23, 0x00	; 0
    5856:	a9 01       	movw	r20, r18
    5858:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <memset>
		}
	}

	return pxNewTCB;
    585c:	89 81       	ldd	r24, Y+1	; 0x01
    585e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5860:	28 96       	adiw	r28, 0x08	; 8
    5862:	0f b6       	in	r0, 0x3f	; 63
    5864:	f8 94       	cli
    5866:	de bf       	out	0x3e, r29	; 62
    5868:	0f be       	out	0x3f, r0	; 63
    586a:	cd bf       	out	0x3d, r28	; 61
    586c:	cf 91       	pop	r28
    586e:	df 91       	pop	r29
    5870:	08 95       	ret

00005872 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    5872:	df 93       	push	r29
    5874:	cf 93       	push	r28
    5876:	00 d0       	rcall	.+0      	; 0x5878 <prvDeleteTCB+0x6>
    5878:	cd b7       	in	r28, 0x3d	; 61
    587a:	de b7       	in	r29, 0x3e	; 62
    587c:	9a 83       	std	Y+2, r25	; 0x02
    587e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    5880:	e9 81       	ldd	r30, Y+1	; 0x01
    5882:	fa 81       	ldd	r31, Y+2	; 0x02
    5884:	87 89       	ldd	r24, Z+23	; 0x17
    5886:	90 8d       	ldd	r25, Z+24	; 0x18
    5888:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
		vPortFree( pxTCB );
    588c:	89 81       	ldd	r24, Y+1	; 0x01
    588e:	9a 81       	ldd	r25, Y+2	; 0x02
    5890:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vPortFree>
	}
    5894:	0f 90       	pop	r0
    5896:	0f 90       	pop	r0
    5898:	cf 91       	pop	r28
    589a:	df 91       	pop	r29
    589c:	08 95       	ret

0000589e <__subsf3>:
    589e:	50 58       	subi	r21, 0x80	; 128

000058a0 <__addsf3>:
    58a0:	bb 27       	eor	r27, r27
    58a2:	aa 27       	eor	r26, r26
    58a4:	0e d0       	rcall	.+28     	; 0x58c2 <__addsf3x>
    58a6:	70 c1       	rjmp	.+736    	; 0x5b88 <__fp_round>
    58a8:	61 d1       	rcall	.+706    	; 0x5b6c <__fp_pscA>
    58aa:	30 f0       	brcs	.+12     	; 0x58b8 <__addsf3+0x18>
    58ac:	66 d1       	rcall	.+716    	; 0x5b7a <__fp_pscB>
    58ae:	20 f0       	brcs	.+8      	; 0x58b8 <__addsf3+0x18>
    58b0:	31 f4       	brne	.+12     	; 0x58be <__addsf3+0x1e>
    58b2:	9f 3f       	cpi	r25, 0xFF	; 255
    58b4:	11 f4       	brne	.+4      	; 0x58ba <__addsf3+0x1a>
    58b6:	1e f4       	brtc	.+6      	; 0x58be <__addsf3+0x1e>
    58b8:	56 c1       	rjmp	.+684    	; 0x5b66 <__fp_nan>
    58ba:	0e f4       	brtc	.+2      	; 0x58be <__addsf3+0x1e>
    58bc:	e0 95       	com	r30
    58be:	e7 fb       	bst	r30, 7
    58c0:	4c c1       	rjmp	.+664    	; 0x5b5a <__fp_inf>

000058c2 <__addsf3x>:
    58c2:	e9 2f       	mov	r30, r25
    58c4:	72 d1       	rcall	.+740    	; 0x5baa <__fp_split3>
    58c6:	80 f3       	brcs	.-32     	; 0x58a8 <__addsf3+0x8>
    58c8:	ba 17       	cp	r27, r26
    58ca:	62 07       	cpc	r22, r18
    58cc:	73 07       	cpc	r23, r19
    58ce:	84 07       	cpc	r24, r20
    58d0:	95 07       	cpc	r25, r21
    58d2:	18 f0       	brcs	.+6      	; 0x58da <__addsf3x+0x18>
    58d4:	71 f4       	brne	.+28     	; 0x58f2 <__addsf3x+0x30>
    58d6:	9e f5       	brtc	.+102    	; 0x593e <__addsf3x+0x7c>
    58d8:	8a c1       	rjmp	.+788    	; 0x5bee <__fp_zero>
    58da:	0e f4       	brtc	.+2      	; 0x58de <__addsf3x+0x1c>
    58dc:	e0 95       	com	r30
    58de:	0b 2e       	mov	r0, r27
    58e0:	ba 2f       	mov	r27, r26
    58e2:	a0 2d       	mov	r26, r0
    58e4:	0b 01       	movw	r0, r22
    58e6:	b9 01       	movw	r22, r18
    58e8:	90 01       	movw	r18, r0
    58ea:	0c 01       	movw	r0, r24
    58ec:	ca 01       	movw	r24, r20
    58ee:	a0 01       	movw	r20, r0
    58f0:	11 24       	eor	r1, r1
    58f2:	ff 27       	eor	r31, r31
    58f4:	59 1b       	sub	r21, r25
    58f6:	99 f0       	breq	.+38     	; 0x591e <__addsf3x+0x5c>
    58f8:	59 3f       	cpi	r21, 0xF9	; 249
    58fa:	50 f4       	brcc	.+20     	; 0x5910 <__addsf3x+0x4e>
    58fc:	50 3e       	cpi	r21, 0xE0	; 224
    58fe:	68 f1       	brcs	.+90     	; 0x595a <__addsf3x+0x98>
    5900:	1a 16       	cp	r1, r26
    5902:	f0 40       	sbci	r31, 0x00	; 0
    5904:	a2 2f       	mov	r26, r18
    5906:	23 2f       	mov	r18, r19
    5908:	34 2f       	mov	r19, r20
    590a:	44 27       	eor	r20, r20
    590c:	58 5f       	subi	r21, 0xF8	; 248
    590e:	f3 cf       	rjmp	.-26     	; 0x58f6 <__addsf3x+0x34>
    5910:	46 95       	lsr	r20
    5912:	37 95       	ror	r19
    5914:	27 95       	ror	r18
    5916:	a7 95       	ror	r26
    5918:	f0 40       	sbci	r31, 0x00	; 0
    591a:	53 95       	inc	r21
    591c:	c9 f7       	brne	.-14     	; 0x5910 <__addsf3x+0x4e>
    591e:	7e f4       	brtc	.+30     	; 0x593e <__addsf3x+0x7c>
    5920:	1f 16       	cp	r1, r31
    5922:	ba 0b       	sbc	r27, r26
    5924:	62 0b       	sbc	r22, r18
    5926:	73 0b       	sbc	r23, r19
    5928:	84 0b       	sbc	r24, r20
    592a:	ba f0       	brmi	.+46     	; 0x595a <__addsf3x+0x98>
    592c:	91 50       	subi	r25, 0x01	; 1
    592e:	a1 f0       	breq	.+40     	; 0x5958 <__addsf3x+0x96>
    5930:	ff 0f       	add	r31, r31
    5932:	bb 1f       	adc	r27, r27
    5934:	66 1f       	adc	r22, r22
    5936:	77 1f       	adc	r23, r23
    5938:	88 1f       	adc	r24, r24
    593a:	c2 f7       	brpl	.-16     	; 0x592c <__addsf3x+0x6a>
    593c:	0e c0       	rjmp	.+28     	; 0x595a <__addsf3x+0x98>
    593e:	ba 0f       	add	r27, r26
    5940:	62 1f       	adc	r22, r18
    5942:	73 1f       	adc	r23, r19
    5944:	84 1f       	adc	r24, r20
    5946:	48 f4       	brcc	.+18     	; 0x595a <__addsf3x+0x98>
    5948:	87 95       	ror	r24
    594a:	77 95       	ror	r23
    594c:	67 95       	ror	r22
    594e:	b7 95       	ror	r27
    5950:	f7 95       	ror	r31
    5952:	9e 3f       	cpi	r25, 0xFE	; 254
    5954:	08 f0       	brcs	.+2      	; 0x5958 <__addsf3x+0x96>
    5956:	b3 cf       	rjmp	.-154    	; 0x58be <__addsf3+0x1e>
    5958:	93 95       	inc	r25
    595a:	88 0f       	add	r24, r24
    595c:	08 f0       	brcs	.+2      	; 0x5960 <__addsf3x+0x9e>
    595e:	99 27       	eor	r25, r25
    5960:	ee 0f       	add	r30, r30
    5962:	97 95       	ror	r25
    5964:	87 95       	ror	r24
    5966:	08 95       	ret

00005968 <__cmpsf2>:
    5968:	d4 d0       	rcall	.+424    	; 0x5b12 <__fp_cmp>
    596a:	08 f4       	brcc	.+2      	; 0x596e <__cmpsf2+0x6>
    596c:	81 e0       	ldi	r24, 0x01	; 1
    596e:	08 95       	ret

00005970 <__divsf3>:
    5970:	0c d0       	rcall	.+24     	; 0x598a <__divsf3x>
    5972:	0a c1       	rjmp	.+532    	; 0x5b88 <__fp_round>
    5974:	02 d1       	rcall	.+516    	; 0x5b7a <__fp_pscB>
    5976:	40 f0       	brcs	.+16     	; 0x5988 <__divsf3+0x18>
    5978:	f9 d0       	rcall	.+498    	; 0x5b6c <__fp_pscA>
    597a:	30 f0       	brcs	.+12     	; 0x5988 <__divsf3+0x18>
    597c:	21 f4       	brne	.+8      	; 0x5986 <__divsf3+0x16>
    597e:	5f 3f       	cpi	r21, 0xFF	; 255
    5980:	19 f0       	breq	.+6      	; 0x5988 <__divsf3+0x18>
    5982:	eb c0       	rjmp	.+470    	; 0x5b5a <__fp_inf>
    5984:	51 11       	cpse	r21, r1
    5986:	34 c1       	rjmp	.+616    	; 0x5bf0 <__fp_szero>
    5988:	ee c0       	rjmp	.+476    	; 0x5b66 <__fp_nan>

0000598a <__divsf3x>:
    598a:	0f d1       	rcall	.+542    	; 0x5baa <__fp_split3>
    598c:	98 f3       	brcs	.-26     	; 0x5974 <__divsf3+0x4>

0000598e <__divsf3_pse>:
    598e:	99 23       	and	r25, r25
    5990:	c9 f3       	breq	.-14     	; 0x5984 <__divsf3+0x14>
    5992:	55 23       	and	r21, r21
    5994:	b1 f3       	breq	.-20     	; 0x5982 <__divsf3+0x12>
    5996:	95 1b       	sub	r25, r21
    5998:	55 0b       	sbc	r21, r21
    599a:	bb 27       	eor	r27, r27
    599c:	aa 27       	eor	r26, r26
    599e:	62 17       	cp	r22, r18
    59a0:	73 07       	cpc	r23, r19
    59a2:	84 07       	cpc	r24, r20
    59a4:	38 f0       	brcs	.+14     	; 0x59b4 <__divsf3_pse+0x26>
    59a6:	9f 5f       	subi	r25, 0xFF	; 255
    59a8:	5f 4f       	sbci	r21, 0xFF	; 255
    59aa:	22 0f       	add	r18, r18
    59ac:	33 1f       	adc	r19, r19
    59ae:	44 1f       	adc	r20, r20
    59b0:	aa 1f       	adc	r26, r26
    59b2:	a9 f3       	breq	.-22     	; 0x599e <__divsf3_pse+0x10>
    59b4:	33 d0       	rcall	.+102    	; 0x5a1c <__divsf3_pse+0x8e>
    59b6:	0e 2e       	mov	r0, r30
    59b8:	3a f0       	brmi	.+14     	; 0x59c8 <__divsf3_pse+0x3a>
    59ba:	e0 e8       	ldi	r30, 0x80	; 128
    59bc:	30 d0       	rcall	.+96     	; 0x5a1e <__divsf3_pse+0x90>
    59be:	91 50       	subi	r25, 0x01	; 1
    59c0:	50 40       	sbci	r21, 0x00	; 0
    59c2:	e6 95       	lsr	r30
    59c4:	00 1c       	adc	r0, r0
    59c6:	ca f7       	brpl	.-14     	; 0x59ba <__divsf3_pse+0x2c>
    59c8:	29 d0       	rcall	.+82     	; 0x5a1c <__divsf3_pse+0x8e>
    59ca:	fe 2f       	mov	r31, r30
    59cc:	27 d0       	rcall	.+78     	; 0x5a1c <__divsf3_pse+0x8e>
    59ce:	66 0f       	add	r22, r22
    59d0:	77 1f       	adc	r23, r23
    59d2:	88 1f       	adc	r24, r24
    59d4:	bb 1f       	adc	r27, r27
    59d6:	26 17       	cp	r18, r22
    59d8:	37 07       	cpc	r19, r23
    59da:	48 07       	cpc	r20, r24
    59dc:	ab 07       	cpc	r26, r27
    59de:	b0 e8       	ldi	r27, 0x80	; 128
    59e0:	09 f0       	breq	.+2      	; 0x59e4 <__divsf3_pse+0x56>
    59e2:	bb 0b       	sbc	r27, r27
    59e4:	80 2d       	mov	r24, r0
    59e6:	bf 01       	movw	r22, r30
    59e8:	ff 27       	eor	r31, r31
    59ea:	93 58       	subi	r25, 0x83	; 131
    59ec:	5f 4f       	sbci	r21, 0xFF	; 255
    59ee:	2a f0       	brmi	.+10     	; 0x59fa <__divsf3_pse+0x6c>
    59f0:	9e 3f       	cpi	r25, 0xFE	; 254
    59f2:	51 05       	cpc	r21, r1
    59f4:	68 f0       	brcs	.+26     	; 0x5a10 <__divsf3_pse+0x82>
    59f6:	b1 c0       	rjmp	.+354    	; 0x5b5a <__fp_inf>
    59f8:	fb c0       	rjmp	.+502    	; 0x5bf0 <__fp_szero>
    59fa:	5f 3f       	cpi	r21, 0xFF	; 255
    59fc:	ec f3       	brlt	.-6      	; 0x59f8 <__divsf3_pse+0x6a>
    59fe:	98 3e       	cpi	r25, 0xE8	; 232
    5a00:	dc f3       	brlt	.-10     	; 0x59f8 <__divsf3_pse+0x6a>
    5a02:	86 95       	lsr	r24
    5a04:	77 95       	ror	r23
    5a06:	67 95       	ror	r22
    5a08:	b7 95       	ror	r27
    5a0a:	f7 95       	ror	r31
    5a0c:	9f 5f       	subi	r25, 0xFF	; 255
    5a0e:	c9 f7       	brne	.-14     	; 0x5a02 <__divsf3_pse+0x74>
    5a10:	88 0f       	add	r24, r24
    5a12:	91 1d       	adc	r25, r1
    5a14:	96 95       	lsr	r25
    5a16:	87 95       	ror	r24
    5a18:	97 f9       	bld	r25, 7
    5a1a:	08 95       	ret
    5a1c:	e1 e0       	ldi	r30, 0x01	; 1
    5a1e:	66 0f       	add	r22, r22
    5a20:	77 1f       	adc	r23, r23
    5a22:	88 1f       	adc	r24, r24
    5a24:	bb 1f       	adc	r27, r27
    5a26:	62 17       	cp	r22, r18
    5a28:	73 07       	cpc	r23, r19
    5a2a:	84 07       	cpc	r24, r20
    5a2c:	ba 07       	cpc	r27, r26
    5a2e:	20 f0       	brcs	.+8      	; 0x5a38 <__divsf3_pse+0xaa>
    5a30:	62 1b       	sub	r22, r18
    5a32:	73 0b       	sbc	r23, r19
    5a34:	84 0b       	sbc	r24, r20
    5a36:	ba 0b       	sbc	r27, r26
    5a38:	ee 1f       	adc	r30, r30
    5a3a:	88 f7       	brcc	.-30     	; 0x5a1e <__divsf3_pse+0x90>
    5a3c:	e0 95       	com	r30
    5a3e:	08 95       	ret

00005a40 <__fixunssfsi>:
    5a40:	bc d0       	rcall	.+376    	; 0x5bba <__fp_splitA>
    5a42:	88 f0       	brcs	.+34     	; 0x5a66 <__fixunssfsi+0x26>
    5a44:	9f 57       	subi	r25, 0x7F	; 127
    5a46:	90 f0       	brcs	.+36     	; 0x5a6c <__fixunssfsi+0x2c>
    5a48:	b9 2f       	mov	r27, r25
    5a4a:	99 27       	eor	r25, r25
    5a4c:	b7 51       	subi	r27, 0x17	; 23
    5a4e:	a0 f0       	brcs	.+40     	; 0x5a78 <__fixunssfsi+0x38>
    5a50:	d1 f0       	breq	.+52     	; 0x5a86 <__fixunssfsi+0x46>
    5a52:	66 0f       	add	r22, r22
    5a54:	77 1f       	adc	r23, r23
    5a56:	88 1f       	adc	r24, r24
    5a58:	99 1f       	adc	r25, r25
    5a5a:	1a f0       	brmi	.+6      	; 0x5a62 <__fixunssfsi+0x22>
    5a5c:	ba 95       	dec	r27
    5a5e:	c9 f7       	brne	.-14     	; 0x5a52 <__fixunssfsi+0x12>
    5a60:	12 c0       	rjmp	.+36     	; 0x5a86 <__fixunssfsi+0x46>
    5a62:	b1 30       	cpi	r27, 0x01	; 1
    5a64:	81 f0       	breq	.+32     	; 0x5a86 <__fixunssfsi+0x46>
    5a66:	c3 d0       	rcall	.+390    	; 0x5bee <__fp_zero>
    5a68:	b1 e0       	ldi	r27, 0x01	; 1
    5a6a:	08 95       	ret
    5a6c:	c0 c0       	rjmp	.+384    	; 0x5bee <__fp_zero>
    5a6e:	67 2f       	mov	r22, r23
    5a70:	78 2f       	mov	r23, r24
    5a72:	88 27       	eor	r24, r24
    5a74:	b8 5f       	subi	r27, 0xF8	; 248
    5a76:	39 f0       	breq	.+14     	; 0x5a86 <__fixunssfsi+0x46>
    5a78:	b9 3f       	cpi	r27, 0xF9	; 249
    5a7a:	cc f3       	brlt	.-14     	; 0x5a6e <__fixunssfsi+0x2e>
    5a7c:	86 95       	lsr	r24
    5a7e:	77 95       	ror	r23
    5a80:	67 95       	ror	r22
    5a82:	b3 95       	inc	r27
    5a84:	d9 f7       	brne	.-10     	; 0x5a7c <__fixunssfsi+0x3c>
    5a86:	3e f4       	brtc	.+14     	; 0x5a96 <__fixunssfsi+0x56>
    5a88:	90 95       	com	r25
    5a8a:	80 95       	com	r24
    5a8c:	70 95       	com	r23
    5a8e:	61 95       	neg	r22
    5a90:	7f 4f       	sbci	r23, 0xFF	; 255
    5a92:	8f 4f       	sbci	r24, 0xFF	; 255
    5a94:	9f 4f       	sbci	r25, 0xFF	; 255
    5a96:	08 95       	ret

00005a98 <__floatunsisf>:
    5a98:	e8 94       	clt
    5a9a:	09 c0       	rjmp	.+18     	; 0x5aae <__floatsisf+0x12>

00005a9c <__floatsisf>:
    5a9c:	97 fb       	bst	r25, 7
    5a9e:	3e f4       	brtc	.+14     	; 0x5aae <__floatsisf+0x12>
    5aa0:	90 95       	com	r25
    5aa2:	80 95       	com	r24
    5aa4:	70 95       	com	r23
    5aa6:	61 95       	neg	r22
    5aa8:	7f 4f       	sbci	r23, 0xFF	; 255
    5aaa:	8f 4f       	sbci	r24, 0xFF	; 255
    5aac:	9f 4f       	sbci	r25, 0xFF	; 255
    5aae:	99 23       	and	r25, r25
    5ab0:	a9 f0       	breq	.+42     	; 0x5adc <__floatsisf+0x40>
    5ab2:	f9 2f       	mov	r31, r25
    5ab4:	96 e9       	ldi	r25, 0x96	; 150
    5ab6:	bb 27       	eor	r27, r27
    5ab8:	93 95       	inc	r25
    5aba:	f6 95       	lsr	r31
    5abc:	87 95       	ror	r24
    5abe:	77 95       	ror	r23
    5ac0:	67 95       	ror	r22
    5ac2:	b7 95       	ror	r27
    5ac4:	f1 11       	cpse	r31, r1
    5ac6:	f8 cf       	rjmp	.-16     	; 0x5ab8 <__floatsisf+0x1c>
    5ac8:	fa f4       	brpl	.+62     	; 0x5b08 <__floatsisf+0x6c>
    5aca:	bb 0f       	add	r27, r27
    5acc:	11 f4       	brne	.+4      	; 0x5ad2 <__floatsisf+0x36>
    5ace:	60 ff       	sbrs	r22, 0
    5ad0:	1b c0       	rjmp	.+54     	; 0x5b08 <__floatsisf+0x6c>
    5ad2:	6f 5f       	subi	r22, 0xFF	; 255
    5ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    5ad6:	8f 4f       	sbci	r24, 0xFF	; 255
    5ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    5ada:	16 c0       	rjmp	.+44     	; 0x5b08 <__floatsisf+0x6c>
    5adc:	88 23       	and	r24, r24
    5ade:	11 f0       	breq	.+4      	; 0x5ae4 <__floatsisf+0x48>
    5ae0:	96 e9       	ldi	r25, 0x96	; 150
    5ae2:	11 c0       	rjmp	.+34     	; 0x5b06 <__floatsisf+0x6a>
    5ae4:	77 23       	and	r23, r23
    5ae6:	21 f0       	breq	.+8      	; 0x5af0 <__floatsisf+0x54>
    5ae8:	9e e8       	ldi	r25, 0x8E	; 142
    5aea:	87 2f       	mov	r24, r23
    5aec:	76 2f       	mov	r23, r22
    5aee:	05 c0       	rjmp	.+10     	; 0x5afa <__floatsisf+0x5e>
    5af0:	66 23       	and	r22, r22
    5af2:	71 f0       	breq	.+28     	; 0x5b10 <__floatsisf+0x74>
    5af4:	96 e8       	ldi	r25, 0x86	; 134
    5af6:	86 2f       	mov	r24, r22
    5af8:	70 e0       	ldi	r23, 0x00	; 0
    5afa:	60 e0       	ldi	r22, 0x00	; 0
    5afc:	2a f0       	brmi	.+10     	; 0x5b08 <__floatsisf+0x6c>
    5afe:	9a 95       	dec	r25
    5b00:	66 0f       	add	r22, r22
    5b02:	77 1f       	adc	r23, r23
    5b04:	88 1f       	adc	r24, r24
    5b06:	da f7       	brpl	.-10     	; 0x5afe <__floatsisf+0x62>
    5b08:	88 0f       	add	r24, r24
    5b0a:	96 95       	lsr	r25
    5b0c:	87 95       	ror	r24
    5b0e:	97 f9       	bld	r25, 7
    5b10:	08 95       	ret

00005b12 <__fp_cmp>:
    5b12:	99 0f       	add	r25, r25
    5b14:	00 08       	sbc	r0, r0
    5b16:	55 0f       	add	r21, r21
    5b18:	aa 0b       	sbc	r26, r26
    5b1a:	e0 e8       	ldi	r30, 0x80	; 128
    5b1c:	fe ef       	ldi	r31, 0xFE	; 254
    5b1e:	16 16       	cp	r1, r22
    5b20:	17 06       	cpc	r1, r23
    5b22:	e8 07       	cpc	r30, r24
    5b24:	f9 07       	cpc	r31, r25
    5b26:	c0 f0       	brcs	.+48     	; 0x5b58 <__fp_cmp+0x46>
    5b28:	12 16       	cp	r1, r18
    5b2a:	13 06       	cpc	r1, r19
    5b2c:	e4 07       	cpc	r30, r20
    5b2e:	f5 07       	cpc	r31, r21
    5b30:	98 f0       	brcs	.+38     	; 0x5b58 <__fp_cmp+0x46>
    5b32:	62 1b       	sub	r22, r18
    5b34:	73 0b       	sbc	r23, r19
    5b36:	84 0b       	sbc	r24, r20
    5b38:	95 0b       	sbc	r25, r21
    5b3a:	39 f4       	brne	.+14     	; 0x5b4a <__fp_cmp+0x38>
    5b3c:	0a 26       	eor	r0, r26
    5b3e:	61 f0       	breq	.+24     	; 0x5b58 <__fp_cmp+0x46>
    5b40:	23 2b       	or	r18, r19
    5b42:	24 2b       	or	r18, r20
    5b44:	25 2b       	or	r18, r21
    5b46:	21 f4       	brne	.+8      	; 0x5b50 <__fp_cmp+0x3e>
    5b48:	08 95       	ret
    5b4a:	0a 26       	eor	r0, r26
    5b4c:	09 f4       	brne	.+2      	; 0x5b50 <__fp_cmp+0x3e>
    5b4e:	a1 40       	sbci	r26, 0x01	; 1
    5b50:	a6 95       	lsr	r26
    5b52:	8f ef       	ldi	r24, 0xFF	; 255
    5b54:	81 1d       	adc	r24, r1
    5b56:	81 1d       	adc	r24, r1
    5b58:	08 95       	ret

00005b5a <__fp_inf>:
    5b5a:	97 f9       	bld	r25, 7
    5b5c:	9f 67       	ori	r25, 0x7F	; 127
    5b5e:	80 e8       	ldi	r24, 0x80	; 128
    5b60:	70 e0       	ldi	r23, 0x00	; 0
    5b62:	60 e0       	ldi	r22, 0x00	; 0
    5b64:	08 95       	ret

00005b66 <__fp_nan>:
    5b66:	9f ef       	ldi	r25, 0xFF	; 255
    5b68:	80 ec       	ldi	r24, 0xC0	; 192
    5b6a:	08 95       	ret

00005b6c <__fp_pscA>:
    5b6c:	00 24       	eor	r0, r0
    5b6e:	0a 94       	dec	r0
    5b70:	16 16       	cp	r1, r22
    5b72:	17 06       	cpc	r1, r23
    5b74:	18 06       	cpc	r1, r24
    5b76:	09 06       	cpc	r0, r25
    5b78:	08 95       	ret

00005b7a <__fp_pscB>:
    5b7a:	00 24       	eor	r0, r0
    5b7c:	0a 94       	dec	r0
    5b7e:	12 16       	cp	r1, r18
    5b80:	13 06       	cpc	r1, r19
    5b82:	14 06       	cpc	r1, r20
    5b84:	05 06       	cpc	r0, r21
    5b86:	08 95       	ret

00005b88 <__fp_round>:
    5b88:	09 2e       	mov	r0, r25
    5b8a:	03 94       	inc	r0
    5b8c:	00 0c       	add	r0, r0
    5b8e:	11 f4       	brne	.+4      	; 0x5b94 <__fp_round+0xc>
    5b90:	88 23       	and	r24, r24
    5b92:	52 f0       	brmi	.+20     	; 0x5ba8 <__fp_round+0x20>
    5b94:	bb 0f       	add	r27, r27
    5b96:	40 f4       	brcc	.+16     	; 0x5ba8 <__fp_round+0x20>
    5b98:	bf 2b       	or	r27, r31
    5b9a:	11 f4       	brne	.+4      	; 0x5ba0 <__fp_round+0x18>
    5b9c:	60 ff       	sbrs	r22, 0
    5b9e:	04 c0       	rjmp	.+8      	; 0x5ba8 <__fp_round+0x20>
    5ba0:	6f 5f       	subi	r22, 0xFF	; 255
    5ba2:	7f 4f       	sbci	r23, 0xFF	; 255
    5ba4:	8f 4f       	sbci	r24, 0xFF	; 255
    5ba6:	9f 4f       	sbci	r25, 0xFF	; 255
    5ba8:	08 95       	ret

00005baa <__fp_split3>:
    5baa:	57 fd       	sbrc	r21, 7
    5bac:	90 58       	subi	r25, 0x80	; 128
    5bae:	44 0f       	add	r20, r20
    5bb0:	55 1f       	adc	r21, r21
    5bb2:	59 f0       	breq	.+22     	; 0x5bca <__fp_splitA+0x10>
    5bb4:	5f 3f       	cpi	r21, 0xFF	; 255
    5bb6:	71 f0       	breq	.+28     	; 0x5bd4 <__fp_splitA+0x1a>
    5bb8:	47 95       	ror	r20

00005bba <__fp_splitA>:
    5bba:	88 0f       	add	r24, r24
    5bbc:	97 fb       	bst	r25, 7
    5bbe:	99 1f       	adc	r25, r25
    5bc0:	61 f0       	breq	.+24     	; 0x5bda <__fp_splitA+0x20>
    5bc2:	9f 3f       	cpi	r25, 0xFF	; 255
    5bc4:	79 f0       	breq	.+30     	; 0x5be4 <__fp_splitA+0x2a>
    5bc6:	87 95       	ror	r24
    5bc8:	08 95       	ret
    5bca:	12 16       	cp	r1, r18
    5bcc:	13 06       	cpc	r1, r19
    5bce:	14 06       	cpc	r1, r20
    5bd0:	55 1f       	adc	r21, r21
    5bd2:	f2 cf       	rjmp	.-28     	; 0x5bb8 <__fp_split3+0xe>
    5bd4:	46 95       	lsr	r20
    5bd6:	f1 df       	rcall	.-30     	; 0x5bba <__fp_splitA>
    5bd8:	08 c0       	rjmp	.+16     	; 0x5bea <__fp_splitA+0x30>
    5bda:	16 16       	cp	r1, r22
    5bdc:	17 06       	cpc	r1, r23
    5bde:	18 06       	cpc	r1, r24
    5be0:	99 1f       	adc	r25, r25
    5be2:	f1 cf       	rjmp	.-30     	; 0x5bc6 <__fp_splitA+0xc>
    5be4:	86 95       	lsr	r24
    5be6:	71 05       	cpc	r23, r1
    5be8:	61 05       	cpc	r22, r1
    5bea:	08 94       	sec
    5bec:	08 95       	ret

00005bee <__fp_zero>:
    5bee:	e8 94       	clt

00005bf0 <__fp_szero>:
    5bf0:	bb 27       	eor	r27, r27
    5bf2:	66 27       	eor	r22, r22
    5bf4:	77 27       	eor	r23, r23
    5bf6:	cb 01       	movw	r24, r22
    5bf8:	97 f9       	bld	r25, 7
    5bfa:	08 95       	ret

00005bfc <__gesf2>:
    5bfc:	8a df       	rcall	.-236    	; 0x5b12 <__fp_cmp>
    5bfe:	08 f4       	brcc	.+2      	; 0x5c02 <__gesf2+0x6>
    5c00:	8f ef       	ldi	r24, 0xFF	; 255
    5c02:	08 95       	ret

00005c04 <__mulsf3>:
    5c04:	0b d0       	rcall	.+22     	; 0x5c1c <__mulsf3x>
    5c06:	c0 cf       	rjmp	.-128    	; 0x5b88 <__fp_round>
    5c08:	b1 df       	rcall	.-158    	; 0x5b6c <__fp_pscA>
    5c0a:	28 f0       	brcs	.+10     	; 0x5c16 <__mulsf3+0x12>
    5c0c:	b6 df       	rcall	.-148    	; 0x5b7a <__fp_pscB>
    5c0e:	18 f0       	brcs	.+6      	; 0x5c16 <__mulsf3+0x12>
    5c10:	95 23       	and	r25, r21
    5c12:	09 f0       	breq	.+2      	; 0x5c16 <__mulsf3+0x12>
    5c14:	a2 cf       	rjmp	.-188    	; 0x5b5a <__fp_inf>
    5c16:	a7 cf       	rjmp	.-178    	; 0x5b66 <__fp_nan>
    5c18:	11 24       	eor	r1, r1
    5c1a:	ea cf       	rjmp	.-44     	; 0x5bf0 <__fp_szero>

00005c1c <__mulsf3x>:
    5c1c:	c6 df       	rcall	.-116    	; 0x5baa <__fp_split3>
    5c1e:	a0 f3       	brcs	.-24     	; 0x5c08 <__mulsf3+0x4>

00005c20 <__mulsf3_pse>:
    5c20:	95 9f       	mul	r25, r21
    5c22:	d1 f3       	breq	.-12     	; 0x5c18 <__mulsf3+0x14>
    5c24:	95 0f       	add	r25, r21
    5c26:	50 e0       	ldi	r21, 0x00	; 0
    5c28:	55 1f       	adc	r21, r21
    5c2a:	62 9f       	mul	r22, r18
    5c2c:	f0 01       	movw	r30, r0
    5c2e:	72 9f       	mul	r23, r18
    5c30:	bb 27       	eor	r27, r27
    5c32:	f0 0d       	add	r31, r0
    5c34:	b1 1d       	adc	r27, r1
    5c36:	63 9f       	mul	r22, r19
    5c38:	aa 27       	eor	r26, r26
    5c3a:	f0 0d       	add	r31, r0
    5c3c:	b1 1d       	adc	r27, r1
    5c3e:	aa 1f       	adc	r26, r26
    5c40:	64 9f       	mul	r22, r20
    5c42:	66 27       	eor	r22, r22
    5c44:	b0 0d       	add	r27, r0
    5c46:	a1 1d       	adc	r26, r1
    5c48:	66 1f       	adc	r22, r22
    5c4a:	82 9f       	mul	r24, r18
    5c4c:	22 27       	eor	r18, r18
    5c4e:	b0 0d       	add	r27, r0
    5c50:	a1 1d       	adc	r26, r1
    5c52:	62 1f       	adc	r22, r18
    5c54:	73 9f       	mul	r23, r19
    5c56:	b0 0d       	add	r27, r0
    5c58:	a1 1d       	adc	r26, r1
    5c5a:	62 1f       	adc	r22, r18
    5c5c:	83 9f       	mul	r24, r19
    5c5e:	a0 0d       	add	r26, r0
    5c60:	61 1d       	adc	r22, r1
    5c62:	22 1f       	adc	r18, r18
    5c64:	74 9f       	mul	r23, r20
    5c66:	33 27       	eor	r19, r19
    5c68:	a0 0d       	add	r26, r0
    5c6a:	61 1d       	adc	r22, r1
    5c6c:	23 1f       	adc	r18, r19
    5c6e:	84 9f       	mul	r24, r20
    5c70:	60 0d       	add	r22, r0
    5c72:	21 1d       	adc	r18, r1
    5c74:	82 2f       	mov	r24, r18
    5c76:	76 2f       	mov	r23, r22
    5c78:	6a 2f       	mov	r22, r26
    5c7a:	11 24       	eor	r1, r1
    5c7c:	9f 57       	subi	r25, 0x7F	; 127
    5c7e:	50 40       	sbci	r21, 0x00	; 0
    5c80:	8a f0       	brmi	.+34     	; 0x5ca4 <__mulsf3_pse+0x84>
    5c82:	e1 f0       	breq	.+56     	; 0x5cbc <__mulsf3_pse+0x9c>
    5c84:	88 23       	and	r24, r24
    5c86:	4a f0       	brmi	.+18     	; 0x5c9a <__mulsf3_pse+0x7a>
    5c88:	ee 0f       	add	r30, r30
    5c8a:	ff 1f       	adc	r31, r31
    5c8c:	bb 1f       	adc	r27, r27
    5c8e:	66 1f       	adc	r22, r22
    5c90:	77 1f       	adc	r23, r23
    5c92:	88 1f       	adc	r24, r24
    5c94:	91 50       	subi	r25, 0x01	; 1
    5c96:	50 40       	sbci	r21, 0x00	; 0
    5c98:	a9 f7       	brne	.-22     	; 0x5c84 <__mulsf3_pse+0x64>
    5c9a:	9e 3f       	cpi	r25, 0xFE	; 254
    5c9c:	51 05       	cpc	r21, r1
    5c9e:	70 f0       	brcs	.+28     	; 0x5cbc <__mulsf3_pse+0x9c>
    5ca0:	5c cf       	rjmp	.-328    	; 0x5b5a <__fp_inf>
    5ca2:	a6 cf       	rjmp	.-180    	; 0x5bf0 <__fp_szero>
    5ca4:	5f 3f       	cpi	r21, 0xFF	; 255
    5ca6:	ec f3       	brlt	.-6      	; 0x5ca2 <__mulsf3_pse+0x82>
    5ca8:	98 3e       	cpi	r25, 0xE8	; 232
    5caa:	dc f3       	brlt	.-10     	; 0x5ca2 <__mulsf3_pse+0x82>
    5cac:	86 95       	lsr	r24
    5cae:	77 95       	ror	r23
    5cb0:	67 95       	ror	r22
    5cb2:	b7 95       	ror	r27
    5cb4:	f7 95       	ror	r31
    5cb6:	e7 95       	ror	r30
    5cb8:	9f 5f       	subi	r25, 0xFF	; 255
    5cba:	c1 f7       	brne	.-16     	; 0x5cac <__mulsf3_pse+0x8c>
    5cbc:	fe 2b       	or	r31, r30
    5cbe:	88 0f       	add	r24, r24
    5cc0:	91 1d       	adc	r25, r1
    5cc2:	96 95       	lsr	r25
    5cc4:	87 95       	ror	r24
    5cc6:	97 f9       	bld	r25, 7
    5cc8:	08 95       	ret

00005cca <__udivmodqi4>:
    5cca:	99 1b       	sub	r25, r25
    5ccc:	79 e0       	ldi	r23, 0x09	; 9
    5cce:	04 c0       	rjmp	.+8      	; 0x5cd8 <__udivmodqi4_ep>

00005cd0 <__udivmodqi4_loop>:
    5cd0:	99 1f       	adc	r25, r25
    5cd2:	96 17       	cp	r25, r22
    5cd4:	08 f0       	brcs	.+2      	; 0x5cd8 <__udivmodqi4_ep>
    5cd6:	96 1b       	sub	r25, r22

00005cd8 <__udivmodqi4_ep>:
    5cd8:	88 1f       	adc	r24, r24
    5cda:	7a 95       	dec	r23
    5cdc:	c9 f7       	brne	.-14     	; 0x5cd0 <__udivmodqi4_loop>
    5cde:	80 95       	com	r24
    5ce0:	08 95       	ret

00005ce2 <__divmodhi4>:
    5ce2:	97 fb       	bst	r25, 7
    5ce4:	09 2e       	mov	r0, r25
    5ce6:	07 26       	eor	r0, r23
    5ce8:	0a d0       	rcall	.+20     	; 0x5cfe <__divmodhi4_neg1>
    5cea:	77 fd       	sbrc	r23, 7
    5cec:	04 d0       	rcall	.+8      	; 0x5cf6 <__divmodhi4_neg2>
    5cee:	0c d0       	rcall	.+24     	; 0x5d08 <__udivmodhi4>
    5cf0:	06 d0       	rcall	.+12     	; 0x5cfe <__divmodhi4_neg1>
    5cf2:	00 20       	and	r0, r0
    5cf4:	1a f4       	brpl	.+6      	; 0x5cfc <__divmodhi4_exit>

00005cf6 <__divmodhi4_neg2>:
    5cf6:	70 95       	com	r23
    5cf8:	61 95       	neg	r22
    5cfa:	7f 4f       	sbci	r23, 0xFF	; 255

00005cfc <__divmodhi4_exit>:
    5cfc:	08 95       	ret

00005cfe <__divmodhi4_neg1>:
    5cfe:	f6 f7       	brtc	.-4      	; 0x5cfc <__divmodhi4_exit>
    5d00:	90 95       	com	r25
    5d02:	81 95       	neg	r24
    5d04:	9f 4f       	sbci	r25, 0xFF	; 255
    5d06:	08 95       	ret

00005d08 <__udivmodhi4>:
    5d08:	aa 1b       	sub	r26, r26
    5d0a:	bb 1b       	sub	r27, r27
    5d0c:	51 e1       	ldi	r21, 0x11	; 17
    5d0e:	07 c0       	rjmp	.+14     	; 0x5d1e <__udivmodhi4_ep>

00005d10 <__udivmodhi4_loop>:
    5d10:	aa 1f       	adc	r26, r26
    5d12:	bb 1f       	adc	r27, r27
    5d14:	a6 17       	cp	r26, r22
    5d16:	b7 07       	cpc	r27, r23
    5d18:	10 f0       	brcs	.+4      	; 0x5d1e <__udivmodhi4_ep>
    5d1a:	a6 1b       	sub	r26, r22
    5d1c:	b7 0b       	sbc	r27, r23

00005d1e <__udivmodhi4_ep>:
    5d1e:	88 1f       	adc	r24, r24
    5d20:	99 1f       	adc	r25, r25
    5d22:	5a 95       	dec	r21
    5d24:	a9 f7       	brne	.-22     	; 0x5d10 <__udivmodhi4_loop>
    5d26:	80 95       	com	r24
    5d28:	90 95       	com	r25
    5d2a:	bc 01       	movw	r22, r24
    5d2c:	cd 01       	movw	r24, r26
    5d2e:	08 95       	ret

00005d30 <memcpy>:
    5d30:	fb 01       	movw	r30, r22
    5d32:	dc 01       	movw	r26, r24
    5d34:	02 c0       	rjmp	.+4      	; 0x5d3a <memcpy+0xa>
    5d36:	01 90       	ld	r0, Z+
    5d38:	0d 92       	st	X+, r0
    5d3a:	41 50       	subi	r20, 0x01	; 1
    5d3c:	50 40       	sbci	r21, 0x00	; 0
    5d3e:	d8 f7       	brcc	.-10     	; 0x5d36 <memcpy+0x6>
    5d40:	08 95       	ret

00005d42 <memset>:
    5d42:	dc 01       	movw	r26, r24
    5d44:	01 c0       	rjmp	.+2      	; 0x5d48 <memset+0x6>
    5d46:	6d 93       	st	X+, r22
    5d48:	41 50       	subi	r20, 0x01	; 1
    5d4a:	50 40       	sbci	r21, 0x00	; 0
    5d4c:	e0 f7       	brcc	.-8      	; 0x5d46 <memset+0x4>
    5d4e:	08 95       	ret

00005d50 <strlen>:
    5d50:	fc 01       	movw	r30, r24
    5d52:	01 90       	ld	r0, Z+
    5d54:	00 20       	and	r0, r0
    5d56:	e9 f7       	brne	.-6      	; 0x5d52 <strlen+0x2>
    5d58:	80 95       	com	r24
    5d5a:	90 95       	com	r25
    5d5c:	8e 0f       	add	r24, r30
    5d5e:	9f 1f       	adc	r25, r31
    5d60:	08 95       	ret

00005d62 <strncpy>:
    5d62:	fb 01       	movw	r30, r22
    5d64:	dc 01       	movw	r26, r24
    5d66:	41 50       	subi	r20, 0x01	; 1
    5d68:	50 40       	sbci	r21, 0x00	; 0
    5d6a:	48 f0       	brcs	.+18     	; 0x5d7e <strncpy+0x1c>
    5d6c:	01 90       	ld	r0, Z+
    5d6e:	0d 92       	st	X+, r0
    5d70:	00 20       	and	r0, r0
    5d72:	c9 f7       	brne	.-14     	; 0x5d66 <strncpy+0x4>
    5d74:	01 c0       	rjmp	.+2      	; 0x5d78 <strncpy+0x16>
    5d76:	1d 92       	st	X+, r1
    5d78:	41 50       	subi	r20, 0x01	; 1
    5d7a:	50 40       	sbci	r21, 0x00	; 0
    5d7c:	e0 f7       	brcc	.-8      	; 0x5d76 <strncpy+0x14>
    5d7e:	08 95       	ret

00005d80 <_exit>:
    5d80:	f8 94       	cli

00005d82 <__stop_program>:
    5d82:	ff cf       	rjmp	.-2      	; 0x5d82 <__stop_program>
