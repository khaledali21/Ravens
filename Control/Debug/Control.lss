
Control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00004894  00004928  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004894  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002e6  0080010e  0080010e  00004936  2**0
                  ALLOC
  3 .stab         0000585c  00000000  00000000  00004938  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000319e  00000000  00000000  0000a194  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 67 00 	jmp	0xce	; 0xce <__ctors_end>
       4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
       8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
       c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      10:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      14:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      18:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      1c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      20:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      24:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      28:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      2c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      30:	0c 94 1c 16 	jmp	0x2c38	; 0x2c38 <__vector_12>
      34:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      38:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      3c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      40:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      44:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      48:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      4c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      50:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      54:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      58:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      5c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      60:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      64:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      68:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      6c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      70:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      74:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      78:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      7c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      80:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      84:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      88:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
      8c:	05 a8       	ldd	r0, Z+53	; 0x35
      8e:	4c cd       	rjmp	.-1384   	; 0xfffffb28 <__eeprom_end+0xff7efb28>
      90:	b2 d4       	rcall	.+2404   	; 0x9f6 <roll_pitch+0x650>
      92:	4e b9       	out	0x0e, r20	; 14
      94:	38 36       	cpi	r19, 0x68	; 104
      96:	a9 02       	muls	r26, r25
      98:	0c 50       	subi	r16, 0x0C	; 12
      9a:	b9 91       	ld	r27, Y+
      9c:	86 88       	ldd	r8, Z+22	; 0x16
      9e:	08 3c       	cpi	r16, 0xC8	; 200
      a0:	a6 aa       	std	Z+54, r10	; 0x36
      a2:	aa 2a       	or	r10, r26
      a4:	be 00       	.word	0x00be	; ????
      a6:	00 00       	nop
      a8:	80 3f       	cpi	r24, 0xF0	; 240
      aa:	06 64       	ori	r16, 0x46	; 70
      ac:	ec 1b       	sub	r30, r28
      ae:	3c 04       	cpc	r3, r12
      b0:	bc 16       	cp	r11, r28
      b2:	3e 3b       	cpi	r19, 0xBE	; 190
      b4:	e5 b9       	out	0x05, r30	; 5
      b6:	3c c9       	rjmp	.-3464   	; 0xfffff330 <__eeprom_end+0xff7ef330>
      b8:	3c 37       	cpi	r19, 0x7C	; 124
      ba:	c2 9e       	mul	r12, r18
      bc:	5a 3d       	cpi	r21, 0xDA	; 218
      be:	66 04       	cpc	r6, r6
      c0:	98 08       	sbc	r9, r8
      c2:	3e ea       	ldi	r19, 0xAE	; 174
      c4:	69 aa       	std	Y+49, r6	; 0x31
      c6:	aa 3e       	cpi	r26, 0xEA	; 234
      c8:	00 00       	nop
      ca:	00 80       	ld	r0, Z
      cc:	3f 00       	.word	0x003f	; ????

000000ce <__ctors_end>:
      ce:	11 24       	eor	r1, r1
      d0:	1f be       	out	0x3f, r1	; 63
      d2:	cf ef       	ldi	r28, 0xFF	; 255
      d4:	d0 e1       	ldi	r29, 0x10	; 16
      d6:	de bf       	out	0x3e, r29	; 62
      d8:	cd bf       	out	0x3d, r28	; 61

000000da <__do_copy_data>:
      da:	11 e0       	ldi	r17, 0x01	; 1
      dc:	a0 e0       	ldi	r26, 0x00	; 0
      de:	b1 e0       	ldi	r27, 0x01	; 1
      e0:	e4 e9       	ldi	r30, 0x94	; 148
      e2:	f8 e4       	ldi	r31, 0x48	; 72
      e4:	00 e0       	ldi	r16, 0x00	; 0
      e6:	0b bf       	out	0x3b, r16	; 59
      e8:	02 c0       	rjmp	.+4      	; 0xee <__do_copy_data+0x14>
      ea:	07 90       	elpm	r0, Z+
      ec:	0d 92       	st	X+, r0
      ee:	ae 30       	cpi	r26, 0x0E	; 14
      f0:	b1 07       	cpc	r27, r17
      f2:	d9 f7       	brne	.-10     	; 0xea <__do_copy_data+0x10>

000000f4 <__do_clear_bss>:
      f4:	13 e0       	ldi	r17, 0x03	; 3
      f6:	ae e0       	ldi	r26, 0x0E	; 14
      f8:	b1 e0       	ldi	r27, 0x01	; 1
      fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
      fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
      fe:	a4 3f       	cpi	r26, 0xF4	; 244
     100:	b1 07       	cpc	r27, r17
     102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
     104:	0e 94 3f 13 	call	0x267e	; 0x267e <main>
     108:	0c 94 48 24 	jmp	0x4890	; 0x4890 <_exit>

0000010c <__bad_interrupt>:
     10c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000110 <body_rates>:
     110:	ef 92       	push	r14
     112:	ff 92       	push	r15
     114:	0f 93       	push	r16
     116:	1f 93       	push	r17
     118:	df 93       	push	r29
     11a:	cf 93       	push	r28
     11c:	cd b7       	in	r28, 0x3d	; 61
     11e:	de b7       	in	r29, 0x3e	; 62
     120:	60 97       	sbiw	r28, 0x10	; 16
     122:	0f b6       	in	r0, 0x3f	; 63
     124:	f8 94       	cli
     126:	de bf       	out	0x3e, r29	; 62
     128:	0f be       	out	0x3f, r0	; 63
     12a:	cd bf       	out	0x3d, r28	; 61
     12c:	98 8b       	std	Y+16, r25	; 0x10
     12e:	8f 87       	std	Y+15, r24	; 0x0f
     130:	8f 85       	ldd	r24, Y+15	; 0x0f
     132:	98 89       	ldd	r25, Y+16	; 0x10
     134:	9e 87       	std	Y+14, r25	; 0x0e
     136:	8d 87       	std	Y+13, r24	; 0x0d
     138:	8d 85       	ldd	r24, Y+13	; 0x0d
     13a:	9e 85       	ldd	r25, Y+14	; 0x0e
     13c:	fc 01       	movw	r30, r24
     13e:	e4 58       	subi	r30, 0x84	; 132
     140:	ff 4f       	sbci	r31, 0xFF	; 255
     142:	80 81       	ld	r24, Z
     144:	91 81       	ldd	r25, Z+1	; 0x01
     146:	a2 81       	ldd	r26, Z+2	; 0x02
     148:	b3 81       	ldd	r27, Z+3	; 0x03
     14a:	ed 85       	ldd	r30, Y+13	; 0x0d
     14c:	fe 85       	ldd	r31, Y+14	; 0x0e
     14e:	24 ad       	ldd	r18, Z+60	; 0x3c
     150:	35 ad       	ldd	r19, Z+61	; 0x3d
     152:	46 ad       	ldd	r20, Z+62	; 0x3e
     154:	57 ad       	ldd	r21, Z+63	; 0x3f
     156:	bc 01       	movw	r22, r24
     158:	cd 01       	movw	r24, r26
     15a:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     15e:	dc 01       	movw	r26, r24
     160:	cb 01       	movw	r24, r22
     162:	89 87       	std	Y+9, r24	; 0x09
     164:	9a 87       	std	Y+10, r25	; 0x0a
     166:	ab 87       	std	Y+11, r26	; 0x0b
     168:	bc 87       	std	Y+12, r27	; 0x0c
     16a:	8d 85       	ldd	r24, Y+13	; 0x0d
     16c:	9e 85       	ldd	r25, Y+14	; 0x0e
     16e:	fc 01       	movw	r30, r24
     170:	e0 58       	subi	r30, 0x80	; 128
     172:	ff 4f       	sbci	r31, 0xFF	; 255
     174:	e0 80       	ld	r14, Z
     176:	f1 80       	ldd	r15, Z+1	; 0x01
     178:	02 81       	ldd	r16, Z+2	; 0x02
     17a:	13 81       	ldd	r17, Z+3	; 0x03
     17c:	8d 85       	ldd	r24, Y+13	; 0x0d
     17e:	9e 85       	ldd	r25, Y+14	; 0x0e
     180:	fc 01       	movw	r30, r24
     182:	e0 5c       	subi	r30, 0xC0	; 192
     184:	ff 4f       	sbci	r31, 0xFF	; 255
     186:	20 81       	ld	r18, Z
     188:	31 81       	ldd	r19, Z+1	; 0x01
     18a:	42 81       	ldd	r20, Z+2	; 0x02
     18c:	53 81       	ldd	r21, Z+3	; 0x03
     18e:	c8 01       	movw	r24, r16
     190:	b7 01       	movw	r22, r14
     192:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     196:	dc 01       	movw	r26, r24
     198:	cb 01       	movw	r24, r22
     19a:	8d 83       	std	Y+5, r24	; 0x05
     19c:	9e 83       	std	Y+6, r25	; 0x06
     19e:	af 83       	std	Y+7, r26	; 0x07
     1a0:	b8 87       	std	Y+8, r27	; 0x08
     1a2:	8d 85       	ldd	r24, Y+13	; 0x0d
     1a4:	9e 85       	ldd	r25, Y+14	; 0x0e
     1a6:	fc 01       	movw	r30, r24
     1a8:	ec 57       	subi	r30, 0x7C	; 124
     1aa:	ff 4f       	sbci	r31, 0xFF	; 255
     1ac:	e0 80       	ld	r14, Z
     1ae:	f1 80       	ldd	r15, Z+1	; 0x01
     1b0:	02 81       	ldd	r16, Z+2	; 0x02
     1b2:	13 81       	ldd	r17, Z+3	; 0x03
     1b4:	8d 85       	ldd	r24, Y+13	; 0x0d
     1b6:	9e 85       	ldd	r25, Y+14	; 0x0e
     1b8:	fc 01       	movw	r30, r24
     1ba:	ec 5b       	subi	r30, 0xBC	; 188
     1bc:	ff 4f       	sbci	r31, 0xFF	; 255
     1be:	20 81       	ld	r18, Z
     1c0:	31 81       	ldd	r19, Z+1	; 0x01
     1c2:	42 81       	ldd	r20, Z+2	; 0x02
     1c4:	53 81       	ldd	r21, Z+3	; 0x03
     1c6:	c8 01       	movw	r24, r16
     1c8:	b7 01       	movw	r22, r14
     1ca:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     1ce:	dc 01       	movw	r26, r24
     1d0:	cb 01       	movw	r24, r22
     1d2:	89 83       	std	Y+1, r24	; 0x01
     1d4:	9a 83       	std	Y+2, r25	; 0x02
     1d6:	ab 83       	std	Y+3, r26	; 0x03
     1d8:	bc 83       	std	Y+4, r27	; 0x04
     1da:	80 91 05 01 	lds	r24, 0x0105
     1de:	88 2f       	mov	r24, r24
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	aa 27       	eor	r26, r26
     1e4:	97 fd       	sbrc	r25, 7
     1e6:	a0 95       	com	r26
     1e8:	ba 2f       	mov	r27, r26
     1ea:	bc 01       	movw	r22, r24
     1ec:	cd 01       	movw	r24, r26
     1ee:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     1f2:	dc 01       	movw	r26, r24
     1f4:	cb 01       	movw	r24, r22
     1f6:	bc 01       	movw	r22, r24
     1f8:	cd 01       	movw	r24, r26
     1fa:	29 85       	ldd	r18, Y+9	; 0x09
     1fc:	3a 85       	ldd	r19, Y+10	; 0x0a
     1fe:	4b 85       	ldd	r20, Y+11	; 0x0b
     200:	5c 85       	ldd	r21, Y+12	; 0x0c
     202:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     206:	dc 01       	movw	r26, r24
     208:	cb 01       	movw	r24, r22
     20a:	9c 01       	movw	r18, r24
     20c:	ad 01       	movw	r20, r26
     20e:	8d 85       	ldd	r24, Y+13	; 0x0d
     210:	9e 85       	ldd	r25, Y+14	; 0x0e
     212:	fc 01       	movw	r30, r24
     214:	e8 5b       	subi	r30, 0xB8	; 184
     216:	ff 4f       	sbci	r31, 0xFF	; 255
     218:	20 83       	st	Z, r18
     21a:	31 83       	std	Z+1, r19	; 0x01
     21c:	42 83       	std	Z+2, r20	; 0x02
     21e:	53 83       	std	Z+3, r21	; 0x03
     220:	80 91 05 01 	lds	r24, 0x0105
     224:	88 2f       	mov	r24, r24
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	aa 27       	eor	r26, r26
     22a:	97 fd       	sbrc	r25, 7
     22c:	a0 95       	com	r26
     22e:	ba 2f       	mov	r27, r26
     230:	bc 01       	movw	r22, r24
     232:	cd 01       	movw	r24, r26
     234:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     238:	dc 01       	movw	r26, r24
     23a:	cb 01       	movw	r24, r22
     23c:	bc 01       	movw	r22, r24
     23e:	cd 01       	movw	r24, r26
     240:	2d 81       	ldd	r18, Y+5	; 0x05
     242:	3e 81       	ldd	r19, Y+6	; 0x06
     244:	4f 81       	ldd	r20, Y+7	; 0x07
     246:	58 85       	ldd	r21, Y+8	; 0x08
     248:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     24c:	dc 01       	movw	r26, r24
     24e:	cb 01       	movw	r24, r22
     250:	9c 01       	movw	r18, r24
     252:	ad 01       	movw	r20, r26
     254:	8d 85       	ldd	r24, Y+13	; 0x0d
     256:	9e 85       	ldd	r25, Y+14	; 0x0e
     258:	fc 01       	movw	r30, r24
     25a:	e4 5b       	subi	r30, 0xB4	; 180
     25c:	ff 4f       	sbci	r31, 0xFF	; 255
     25e:	20 83       	st	Z, r18
     260:	31 83       	std	Z+1, r19	; 0x01
     262:	42 83       	std	Z+2, r20	; 0x02
     264:	53 83       	std	Z+3, r21	; 0x03
     266:	80 91 05 01 	lds	r24, 0x0105
     26a:	88 2f       	mov	r24, r24
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	aa 27       	eor	r26, r26
     270:	97 fd       	sbrc	r25, 7
     272:	a0 95       	com	r26
     274:	ba 2f       	mov	r27, r26
     276:	bc 01       	movw	r22, r24
     278:	cd 01       	movw	r24, r26
     27a:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     27e:	dc 01       	movw	r26, r24
     280:	cb 01       	movw	r24, r22
     282:	bc 01       	movw	r22, r24
     284:	cd 01       	movw	r24, r26
     286:	29 81       	ldd	r18, Y+1	; 0x01
     288:	3a 81       	ldd	r19, Y+2	; 0x02
     28a:	4b 81       	ldd	r20, Y+3	; 0x03
     28c:	5c 81       	ldd	r21, Y+4	; 0x04
     28e:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     292:	dc 01       	movw	r26, r24
     294:	cb 01       	movw	r24, r22
     296:	9c 01       	movw	r18, r24
     298:	ad 01       	movw	r20, r26
     29a:	8d 85       	ldd	r24, Y+13	; 0x0d
     29c:	9e 85       	ldd	r25, Y+14	; 0x0e
     29e:	fc 01       	movw	r30, r24
     2a0:	e0 5b       	subi	r30, 0xB0	; 176
     2a2:	ff 4f       	sbci	r31, 0xFF	; 255
     2a4:	20 83       	st	Z, r18
     2a6:	31 83       	std	Z+1, r19	; 0x01
     2a8:	42 83       	std	Z+2, r20	; 0x02
     2aa:	53 83       	std	Z+3, r21	; 0x03
     2ac:	80 91 06 01 	lds	r24, 0x0106
     2b0:	88 2f       	mov	r24, r24
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	aa 27       	eor	r26, r26
     2b6:	97 fd       	sbrc	r25, 7
     2b8:	a0 95       	com	r26
     2ba:	ba 2f       	mov	r27, r26
     2bc:	bc 01       	movw	r22, r24
     2be:	cd 01       	movw	r24, r26
     2c0:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     2c4:	7b 01       	movw	r14, r22
     2c6:	8c 01       	movw	r16, r24
     2c8:	8d 85       	ldd	r24, Y+13	; 0x0d
     2ca:	9e 85       	ldd	r25, Y+14	; 0x0e
     2cc:	fc 01       	movw	r30, r24
     2ce:	e8 5b       	subi	r30, 0xB8	; 184
     2d0:	ff 4f       	sbci	r31, 0xFF	; 255
     2d2:	20 81       	ld	r18, Z
     2d4:	31 81       	ldd	r19, Z+1	; 0x01
     2d6:	42 81       	ldd	r20, Z+2	; 0x02
     2d8:	53 81       	ldd	r21, Z+3	; 0x03
     2da:	c8 01       	movw	r24, r16
     2dc:	b7 01       	movw	r22, r14
     2de:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     2e2:	dc 01       	movw	r26, r24
     2e4:	cb 01       	movw	r24, r22
     2e6:	9c 01       	movw	r18, r24
     2e8:	ad 01       	movw	r20, r26
     2ea:	8d 85       	ldd	r24, Y+13	; 0x0d
     2ec:	9e 85       	ldd	r25, Y+14	; 0x0e
     2ee:	fc 01       	movw	r30, r24
     2f0:	e4 57       	subi	r30, 0x74	; 116
     2f2:	ff 4f       	sbci	r31, 0xFF	; 255
     2f4:	20 83       	st	Z, r18
     2f6:	31 83       	std	Z+1, r19	; 0x01
     2f8:	42 83       	std	Z+2, r20	; 0x02
     2fa:	53 83       	std	Z+3, r21	; 0x03
     2fc:	80 91 07 01 	lds	r24, 0x0107
     300:	88 2f       	mov	r24, r24
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	aa 27       	eor	r26, r26
     306:	97 fd       	sbrc	r25, 7
     308:	a0 95       	com	r26
     30a:	ba 2f       	mov	r27, r26
     30c:	bc 01       	movw	r22, r24
     30e:	cd 01       	movw	r24, r26
     310:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     314:	7b 01       	movw	r14, r22
     316:	8c 01       	movw	r16, r24
     318:	8d 85       	ldd	r24, Y+13	; 0x0d
     31a:	9e 85       	ldd	r25, Y+14	; 0x0e
     31c:	fc 01       	movw	r30, r24
     31e:	e4 5b       	subi	r30, 0xB4	; 180
     320:	ff 4f       	sbci	r31, 0xFF	; 255
     322:	20 81       	ld	r18, Z
     324:	31 81       	ldd	r19, Z+1	; 0x01
     326:	42 81       	ldd	r20, Z+2	; 0x02
     328:	53 81       	ldd	r21, Z+3	; 0x03
     32a:	c8 01       	movw	r24, r16
     32c:	b7 01       	movw	r22, r14
     32e:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     332:	dc 01       	movw	r26, r24
     334:	cb 01       	movw	r24, r22
     336:	9c 01       	movw	r18, r24
     338:	ad 01       	movw	r20, r26
     33a:	8d 85       	ldd	r24, Y+13	; 0x0d
     33c:	9e 85       	ldd	r25, Y+14	; 0x0e
     33e:	fc 01       	movw	r30, r24
     340:	e0 57       	subi	r30, 0x70	; 112
     342:	ff 4f       	sbci	r31, 0xFF	; 255
     344:	20 83       	st	Z, r18
     346:	31 83       	std	Z+1, r19	; 0x01
     348:	42 83       	std	Z+2, r20	; 0x02
     34a:	53 83       	std	Z+3, r21	; 0x03
     34c:	80 91 08 01 	lds	r24, 0x0108
     350:	88 2f       	mov	r24, r24
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	aa 27       	eor	r26, r26
     356:	97 fd       	sbrc	r25, 7
     358:	a0 95       	com	r26
     35a:	ba 2f       	mov	r27, r26
     35c:	bc 01       	movw	r22, r24
     35e:	cd 01       	movw	r24, r26
     360:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     364:	7b 01       	movw	r14, r22
     366:	8c 01       	movw	r16, r24
     368:	8d 85       	ldd	r24, Y+13	; 0x0d
     36a:	9e 85       	ldd	r25, Y+14	; 0x0e
     36c:	fc 01       	movw	r30, r24
     36e:	e0 5b       	subi	r30, 0xB0	; 176
     370:	ff 4f       	sbci	r31, 0xFF	; 255
     372:	20 81       	ld	r18, Z
     374:	31 81       	ldd	r19, Z+1	; 0x01
     376:	42 81       	ldd	r20, Z+2	; 0x02
     378:	53 81       	ldd	r21, Z+3	; 0x03
     37a:	c8 01       	movw	r24, r16
     37c:	b7 01       	movw	r22, r14
     37e:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     382:	dc 01       	movw	r26, r24
     384:	cb 01       	movw	r24, r22
     386:	9c 01       	movw	r18, r24
     388:	ad 01       	movw	r20, r26
     38a:	8d 85       	ldd	r24, Y+13	; 0x0d
     38c:	9e 85       	ldd	r25, Y+14	; 0x0e
     38e:	fc 01       	movw	r30, r24
     390:	ec 56       	subi	r30, 0x6C	; 108
     392:	ff 4f       	sbci	r31, 0xFF	; 255
     394:	20 83       	st	Z, r18
     396:	31 83       	std	Z+1, r19	; 0x01
     398:	42 83       	std	Z+2, r20	; 0x02
     39a:	53 83       	std	Z+3, r21	; 0x03
     39c:	81 e0       	ldi	r24, 0x01	; 1
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <vTaskDelay>
     3a4:	c9 ce       	rjmp	.-622    	; 0x138 <body_rates+0x28>

000003a6 <roll_pitch>:
	ptr->u4 = Izz * ptr->r_dot;
	vTaskDelay(1);
	}
}
void roll_pitch(void *pt)
{
     3a6:	af 92       	push	r10
     3a8:	bf 92       	push	r11
     3aa:	cf 92       	push	r12
     3ac:	df 92       	push	r13
     3ae:	ef 92       	push	r14
     3b0:	ff 92       	push	r15
     3b2:	0f 93       	push	r16
     3b4:	1f 93       	push	r17
     3b6:	df 93       	push	r29
     3b8:	cf 93       	push	r28
     3ba:	cd b7       	in	r28, 0x3d	; 61
     3bc:	de b7       	in	r29, 0x3e	; 62
     3be:	e8 97       	sbiw	r28, 0x38	; 56
     3c0:	0f b6       	in	r0, 0x3f	; 63
     3c2:	f8 94       	cli
     3c4:	de bf       	out	0x3e, r29	; 62
     3c6:	0f be       	out	0x3f, r0	; 63
     3c8:	cd bf       	out	0x3d, r28	; 61
     3ca:	98 af       	std	Y+56, r25	; 0x38
     3cc:	8f ab       	std	Y+55, r24	; 0x37
	parameters * ptr = pt;
     3ce:	8f a9       	ldd	r24, Y+55	; 0x37
     3d0:	98 ad       	ldd	r25, Y+56	; 0x38
     3d2:	9e ab       	std	Y+54, r25	; 0x36
     3d4:	8d ab       	std	Y+53, r24	; 0x35
	while(1)
	{f32 dt = 0.001, b_x_dot_cmd, b_y_dot_cmd, taw=1/kp_bank;
     3d6:	8f e6       	ldi	r24, 0x6F	; 111
     3d8:	92 e1       	ldi	r25, 0x12	; 18
     3da:	a3 e8       	ldi	r26, 0x83	; 131
     3dc:	ba e3       	ldi	r27, 0x3A	; 58
     3de:	89 ab       	std	Y+49, r24	; 0x31
     3e0:	9a ab       	std	Y+50, r25	; 0x32
     3e2:	ab ab       	std	Y+51, r26	; 0x33
     3e4:	bc ab       	std	Y+52, r27	; 0x34
     3e6:	80 91 0a 01 	lds	r24, 0x010A
     3ea:	28 2f       	mov	r18, r24
     3ec:	30 e0       	ldi	r19, 0x00	; 0
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	b9 01       	movw	r22, r18
     3f4:	0e 94 02 24 	call	0x4804	; 0x4804 <__divmodhi4>
     3f8:	cb 01       	movw	r24, r22
     3fa:	aa 27       	eor	r26, r26
     3fc:	97 fd       	sbrc	r25, 7
     3fe:	a0 95       	com	r26
     400:	ba 2f       	mov	r27, r26
     402:	bc 01       	movw	r22, r24
     404:	cd 01       	movw	r24, r26
     406:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     40a:	dc 01       	movw	r26, r24
     40c:	cb 01       	movw	r24, r22
     40e:	8d a3       	std	Y+37, r24	; 0x25
     410:	9e a3       	std	Y+38, r25	; 0x26
     412:	af a3       	std	Y+39, r26	; 0x27
     414:	b8 a7       	std	Y+40, r27	; 0x28
	f32 R11 = 1;
     416:	80 e0       	ldi	r24, 0x00	; 0
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	a0 e8       	ldi	r26, 0x80	; 128
     41c:	bf e3       	ldi	r27, 0x3F	; 63
     41e:	89 a3       	std	Y+33, r24	; 0x21
     420:	9a a3       	std	Y+34, r25	; 0x22
     422:	ab a3       	std	Y+35, r26	; 0x23
     424:	bc a3       	std	Y+36, r27	; 0x24
	f32 R12 = sin(ptr->phi)*tan(ptr->theta);
     426:	ed a9       	ldd	r30, Y+53	; 0x35
     428:	fe a9       	ldd	r31, Y+54	; 0x36
     42a:	84 a1       	ldd	r24, Z+36	; 0x24
     42c:	95 a1       	ldd	r25, Z+37	; 0x25
     42e:	a6 a1       	ldd	r26, Z+38	; 0x26
     430:	b7 a1       	ldd	r27, Z+39	; 0x27
     432:	bc 01       	movw	r22, r24
     434:	cd 01       	movw	r24, r26
     436:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     43a:	7b 01       	movw	r14, r22
     43c:	8c 01       	movw	r16, r24
     43e:	ed a9       	ldd	r30, Y+53	; 0x35
     440:	fe a9       	ldd	r31, Y+54	; 0x36
     442:	80 a5       	ldd	r24, Z+40	; 0x28
     444:	91 a5       	ldd	r25, Z+41	; 0x29
     446:	a2 a5       	ldd	r26, Z+42	; 0x2a
     448:	b3 a5       	ldd	r27, Z+43	; 0x2b
     44a:	bc 01       	movw	r22, r24
     44c:	cd 01       	movw	r24, r26
     44e:	0e 94 8b 23 	call	0x4716	; 0x4716 <tan>
     452:	9b 01       	movw	r18, r22
     454:	ac 01       	movw	r20, r24
     456:	c8 01       	movw	r24, r16
     458:	b7 01       	movw	r22, r14
     45a:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     45e:	dc 01       	movw	r26, r24
     460:	cb 01       	movw	r24, r22
     462:	8d 8f       	std	Y+29, r24	; 0x1d
     464:	9e 8f       	std	Y+30, r25	; 0x1e
     466:	af 8f       	std	Y+31, r26	; 0x1f
     468:	b8 a3       	std	Y+32, r27	; 0x20
	f32 R22 = cos(ptr->phi);
     46a:	ed a9       	ldd	r30, Y+53	; 0x35
     46c:	fe a9       	ldd	r31, Y+54	; 0x36
     46e:	84 a1       	ldd	r24, Z+36	; 0x24
     470:	95 a1       	ldd	r25, Z+37	; 0x25
     472:	a6 a1       	ldd	r26, Z+38	; 0x26
     474:	b7 a1       	ldd	r27, Z+39	; 0x27
     476:	bc 01       	movw	r22, r24
     478:	cd 01       	movw	r24, r26
     47a:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     47e:	dc 01       	movw	r26, r24
     480:	cb 01       	movw	r24, r22
     482:	89 8f       	std	Y+25, r24	; 0x19
     484:	9a 8f       	std	Y+26, r25	; 0x1a
     486:	ab 8f       	std	Y+27, r26	; 0x1b
     488:	bc 8f       	std	Y+28, r27	; 0x1c
	f32 R21 = 0;
     48a:	80 e0       	ldi	r24, 0x00	; 0
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	a0 e0       	ldi	r26, 0x00	; 0
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	8d 8b       	std	Y+21, r24	; 0x15
     494:	9e 8b       	std	Y+22, r25	; 0x16
     496:	af 8b       	std	Y+23, r26	; 0x17
     498:	b8 8f       	std	Y+24, r27	; 0x18
	f32 R33 = cos(ptr->phi)/cos(ptr->theta);
     49a:	ed a9       	ldd	r30, Y+53	; 0x35
     49c:	fe a9       	ldd	r31, Y+54	; 0x36
     49e:	84 a1       	ldd	r24, Z+36	; 0x24
     4a0:	95 a1       	ldd	r25, Z+37	; 0x25
     4a2:	a6 a1       	ldd	r26, Z+38	; 0x26
     4a4:	b7 a1       	ldd	r27, Z+39	; 0x27
     4a6:	bc 01       	movw	r22, r24
     4a8:	cd 01       	movw	r24, r26
     4aa:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     4ae:	7b 01       	movw	r14, r22
     4b0:	8c 01       	movw	r16, r24
     4b2:	ed a9       	ldd	r30, Y+53	; 0x35
     4b4:	fe a9       	ldd	r31, Y+54	; 0x36
     4b6:	80 a5       	ldd	r24, Z+40	; 0x28
     4b8:	91 a5       	ldd	r25, Z+41	; 0x29
     4ba:	a2 a5       	ldd	r26, Z+42	; 0x2a
     4bc:	b3 a5       	ldd	r27, Z+43	; 0x2b
     4be:	bc 01       	movw	r22, r24
     4c0:	cd 01       	movw	r24, r26
     4c2:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     4c6:	9b 01       	movw	r18, r22
     4c8:	ac 01       	movw	r20, r24
     4ca:	c8 01       	movw	r24, r16
     4cc:	b7 01       	movw	r22, r14
     4ce:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     4d2:	dc 01       	movw	r26, r24
     4d4:	cb 01       	movw	r24, r22
     4d6:	89 8b       	std	Y+17, r24	; 0x11
     4d8:	9a 8b       	std	Y+18, r25	; 0x12
     4da:	ab 8b       	std	Y+19, r26	; 0x13
     4dc:	bc 8b       	std	Y+20, r27	; 0x14
	f32 R13= cos(ptr->phi)* tan(ptr->theta);
     4de:	ed a9       	ldd	r30, Y+53	; 0x35
     4e0:	fe a9       	ldd	r31, Y+54	; 0x36
     4e2:	84 a1       	ldd	r24, Z+36	; 0x24
     4e4:	95 a1       	ldd	r25, Z+37	; 0x25
     4e6:	a6 a1       	ldd	r26, Z+38	; 0x26
     4e8:	b7 a1       	ldd	r27, Z+39	; 0x27
     4ea:	bc 01       	movw	r22, r24
     4ec:	cd 01       	movw	r24, r26
     4ee:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     4f2:	7b 01       	movw	r14, r22
     4f4:	8c 01       	movw	r16, r24
     4f6:	ed a9       	ldd	r30, Y+53	; 0x35
     4f8:	fe a9       	ldd	r31, Y+54	; 0x36
     4fa:	80 a5       	ldd	r24, Z+40	; 0x28
     4fc:	91 a5       	ldd	r25, Z+41	; 0x29
     4fe:	a2 a5       	ldd	r26, Z+42	; 0x2a
     500:	b3 a5       	ldd	r27, Z+43	; 0x2b
     502:	bc 01       	movw	r22, r24
     504:	cd 01       	movw	r24, r26
     506:	0e 94 8b 23 	call	0x4716	; 0x4716 <tan>
     50a:	9b 01       	movw	r18, r22
     50c:	ac 01       	movw	r20, r24
     50e:	c8 01       	movw	r24, r16
     510:	b7 01       	movw	r22, r14
     512:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     516:	dc 01       	movw	r26, r24
     518:	cb 01       	movw	r24, r22
     51a:	8d 87       	std	Y+13, r24	; 0x0d
     51c:	9e 87       	std	Y+14, r25	; 0x0e
     51e:	af 87       	std	Y+15, r26	; 0x0f
     520:	b8 8b       	std	Y+16, r27	; 0x10
	f32 R13_cmd= ptr->x_dot_dot_cmd*m/ptr->u1;
     522:	8d a9       	ldd	r24, Y+53	; 0x35
     524:	9e a9       	ldd	r25, Y+54	; 0x36
     526:	fc 01       	movw	r30, r24
     528:	e4 59       	subi	r30, 0x94	; 148
     52a:	ff 4f       	sbci	r31, 0xFF	; 255
     52c:	e0 80       	ld	r14, Z
     52e:	f1 80       	ldd	r15, Z+1	; 0x01
     530:	02 81       	ldd	r16, Z+2	; 0x02
     532:	13 81       	ldd	r17, Z+3	; 0x03
     534:	80 91 09 01 	lds	r24, 0x0109
     538:	88 2f       	mov	r24, r24
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	aa 27       	eor	r26, r26
     53e:	97 fd       	sbrc	r25, 7
     540:	a0 95       	com	r26
     542:	ba 2f       	mov	r27, r26
     544:	bc 01       	movw	r22, r24
     546:	cd 01       	movw	r24, r26
     548:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     54c:	9b 01       	movw	r18, r22
     54e:	ac 01       	movw	r20, r24
     550:	c8 01       	movw	r24, r16
     552:	b7 01       	movw	r22, r14
     554:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     558:	dc 01       	movw	r26, r24
     55a:	cb 01       	movw	r24, r22
     55c:	7c 01       	movw	r14, r24
     55e:	8d 01       	movw	r16, r26
     560:	8d a9       	ldd	r24, Y+53	; 0x35
     562:	9e a9       	ldd	r25, Y+54	; 0x36
     564:	fc 01       	movw	r30, r24
     566:	e8 57       	subi	r30, 0x78	; 120
     568:	ff 4f       	sbci	r31, 0xFF	; 255
     56a:	20 81       	ld	r18, Z
     56c:	31 81       	ldd	r19, Z+1	; 0x01
     56e:	42 81       	ldd	r20, Z+2	; 0x02
     570:	53 81       	ldd	r21, Z+3	; 0x03
     572:	c8 01       	movw	r24, r16
     574:	b7 01       	movw	r22, r14
     576:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     57a:	dc 01       	movw	r26, r24
     57c:	cb 01       	movw	r24, r22
     57e:	89 87       	std	Y+9, r24	; 0x09
     580:	9a 87       	std	Y+10, r25	; 0x0a
     582:	ab 87       	std	Y+11, r26	; 0x0b
     584:	bc 87       	std	Y+12, r27	; 0x0c
	f32 R23= -sin(ptr->phi);
     586:	ed a9       	ldd	r30, Y+53	; 0x35
     588:	fe a9       	ldd	r31, Y+54	; 0x36
     58a:	84 a1       	ldd	r24, Z+36	; 0x24
     58c:	95 a1       	ldd	r25, Z+37	; 0x25
     58e:	a6 a1       	ldd	r26, Z+38	; 0x26
     590:	b7 a1       	ldd	r27, Z+39	; 0x27
     592:	bc 01       	movw	r22, r24
     594:	cd 01       	movw	r24, r26
     596:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     59a:	dc 01       	movw	r26, r24
     59c:	cb 01       	movw	r24, r22
     59e:	b0 58       	subi	r27, 0x80	; 128
     5a0:	8d 83       	std	Y+5, r24	; 0x05
     5a2:	9e 83       	std	Y+6, r25	; 0x06
     5a4:	af 83       	std	Y+7, r26	; 0x07
     5a6:	b8 87       	std	Y+8, r27	; 0x08
	f32 R23_cmd= ptr->y_dot_dot_cmd*m/ptr->u1;
     5a8:	8d a9       	ldd	r24, Y+53	; 0x35
     5aa:	9e a9       	ldd	r25, Y+54	; 0x36
     5ac:	fc 01       	movw	r30, r24
     5ae:	e0 59       	subi	r30, 0x90	; 144
     5b0:	ff 4f       	sbci	r31, 0xFF	; 255
     5b2:	e0 80       	ld	r14, Z
     5b4:	f1 80       	ldd	r15, Z+1	; 0x01
     5b6:	02 81       	ldd	r16, Z+2	; 0x02
     5b8:	13 81       	ldd	r17, Z+3	; 0x03
     5ba:	80 91 09 01 	lds	r24, 0x0109
     5be:	88 2f       	mov	r24, r24
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	aa 27       	eor	r26, r26
     5c4:	97 fd       	sbrc	r25, 7
     5c6:	a0 95       	com	r26
     5c8:	ba 2f       	mov	r27, r26
     5ca:	bc 01       	movw	r22, r24
     5cc:	cd 01       	movw	r24, r26
     5ce:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     5d2:	9b 01       	movw	r18, r22
     5d4:	ac 01       	movw	r20, r24
     5d6:	c8 01       	movw	r24, r16
     5d8:	b7 01       	movw	r22, r14
     5da:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     5de:	dc 01       	movw	r26, r24
     5e0:	cb 01       	movw	r24, r22
     5e2:	7c 01       	movw	r14, r24
     5e4:	8d 01       	movw	r16, r26
     5e6:	8d a9       	ldd	r24, Y+53	; 0x35
     5e8:	9e a9       	ldd	r25, Y+54	; 0x36
     5ea:	fc 01       	movw	r30, r24
     5ec:	e8 57       	subi	r30, 0x78	; 120
     5ee:	ff 4f       	sbci	r31, 0xFF	; 255
     5f0:	20 81       	ld	r18, Z
     5f2:	31 81       	ldd	r19, Z+1	; 0x01
     5f4:	42 81       	ldd	r20, Z+2	; 0x02
     5f6:	53 81       	ldd	r21, Z+3	; 0x03
     5f8:	c8 01       	movw	r24, r16
     5fa:	b7 01       	movw	r22, r14
     5fc:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     600:	dc 01       	movw	r26, r24
     602:	cb 01       	movw	r24, r22
     604:	89 83       	std	Y+1, r24	; 0x01
     606:	9a 83       	std	Y+2, r25	; 0x02
     608:	ab 83       	std	Y+3, r26	; 0x03
     60a:	bc 83       	std	Y+4, r27	; 0x04

	ptr->phi_dot = ptr->p + ptr->q * sin(ptr->phi) * tan(ptr->theta) + ptr->r * cos(ptr->phi) * tan(ptr->theta);
     60c:	ed a9       	ldd	r30, Y+53	; 0x35
     60e:	fe a9       	ldd	r31, Y+54	; 0x36
     610:	a4 ac       	ldd	r10, Z+60	; 0x3c
     612:	b5 ac       	ldd	r11, Z+61	; 0x3d
     614:	c6 ac       	ldd	r12, Z+62	; 0x3e
     616:	d7 ac       	ldd	r13, Z+63	; 0x3f
     618:	8d a9       	ldd	r24, Y+53	; 0x35
     61a:	9e a9       	ldd	r25, Y+54	; 0x36
     61c:	fc 01       	movw	r30, r24
     61e:	e0 5c       	subi	r30, 0xC0	; 192
     620:	ff 4f       	sbci	r31, 0xFF	; 255
     622:	e0 80       	ld	r14, Z
     624:	f1 80       	ldd	r15, Z+1	; 0x01
     626:	02 81       	ldd	r16, Z+2	; 0x02
     628:	13 81       	ldd	r17, Z+3	; 0x03
     62a:	ed a9       	ldd	r30, Y+53	; 0x35
     62c:	fe a9       	ldd	r31, Y+54	; 0x36
     62e:	84 a1       	ldd	r24, Z+36	; 0x24
     630:	95 a1       	ldd	r25, Z+37	; 0x25
     632:	a6 a1       	ldd	r26, Z+38	; 0x26
     634:	b7 a1       	ldd	r27, Z+39	; 0x27
     636:	bc 01       	movw	r22, r24
     638:	cd 01       	movw	r24, r26
     63a:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     63e:	9b 01       	movw	r18, r22
     640:	ac 01       	movw	r20, r24
     642:	c8 01       	movw	r24, r16
     644:	b7 01       	movw	r22, r14
     646:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     64a:	dc 01       	movw	r26, r24
     64c:	cb 01       	movw	r24, r22
     64e:	7c 01       	movw	r14, r24
     650:	8d 01       	movw	r16, r26
     652:	ed a9       	ldd	r30, Y+53	; 0x35
     654:	fe a9       	ldd	r31, Y+54	; 0x36
     656:	80 a5       	ldd	r24, Z+40	; 0x28
     658:	91 a5       	ldd	r25, Z+41	; 0x29
     65a:	a2 a5       	ldd	r26, Z+42	; 0x2a
     65c:	b3 a5       	ldd	r27, Z+43	; 0x2b
     65e:	bc 01       	movw	r22, r24
     660:	cd 01       	movw	r24, r26
     662:	0e 94 8b 23 	call	0x4716	; 0x4716 <tan>
     666:	9b 01       	movw	r18, r22
     668:	ac 01       	movw	r20, r24
     66a:	c8 01       	movw	r24, r16
     66c:	b7 01       	movw	r22, r14
     66e:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     672:	dc 01       	movw	r26, r24
     674:	cb 01       	movw	r24, r22
     676:	9c 01       	movw	r18, r24
     678:	ad 01       	movw	r20, r26
     67a:	c6 01       	movw	r24, r12
     67c:	b5 01       	movw	r22, r10
     67e:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     682:	dc 01       	movw	r26, r24
     684:	cb 01       	movw	r24, r22
     686:	5c 01       	movw	r10, r24
     688:	6d 01       	movw	r12, r26
     68a:	8d a9       	ldd	r24, Y+53	; 0x35
     68c:	9e a9       	ldd	r25, Y+54	; 0x36
     68e:	fc 01       	movw	r30, r24
     690:	ec 5b       	subi	r30, 0xBC	; 188
     692:	ff 4f       	sbci	r31, 0xFF	; 255
     694:	e0 80       	ld	r14, Z
     696:	f1 80       	ldd	r15, Z+1	; 0x01
     698:	02 81       	ldd	r16, Z+2	; 0x02
     69a:	13 81       	ldd	r17, Z+3	; 0x03
     69c:	ed a9       	ldd	r30, Y+53	; 0x35
     69e:	fe a9       	ldd	r31, Y+54	; 0x36
     6a0:	84 a1       	ldd	r24, Z+36	; 0x24
     6a2:	95 a1       	ldd	r25, Z+37	; 0x25
     6a4:	a6 a1       	ldd	r26, Z+38	; 0x26
     6a6:	b7 a1       	ldd	r27, Z+39	; 0x27
     6a8:	bc 01       	movw	r22, r24
     6aa:	cd 01       	movw	r24, r26
     6ac:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     6b0:	9b 01       	movw	r18, r22
     6b2:	ac 01       	movw	r20, r24
     6b4:	c8 01       	movw	r24, r16
     6b6:	b7 01       	movw	r22, r14
     6b8:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     6bc:	dc 01       	movw	r26, r24
     6be:	cb 01       	movw	r24, r22
     6c0:	7c 01       	movw	r14, r24
     6c2:	8d 01       	movw	r16, r26
     6c4:	ed a9       	ldd	r30, Y+53	; 0x35
     6c6:	fe a9       	ldd	r31, Y+54	; 0x36
     6c8:	80 a5       	ldd	r24, Z+40	; 0x28
     6ca:	91 a5       	ldd	r25, Z+41	; 0x29
     6cc:	a2 a5       	ldd	r26, Z+42	; 0x2a
     6ce:	b3 a5       	ldd	r27, Z+43	; 0x2b
     6d0:	bc 01       	movw	r22, r24
     6d2:	cd 01       	movw	r24, r26
     6d4:	0e 94 8b 23 	call	0x4716	; 0x4716 <tan>
     6d8:	9b 01       	movw	r18, r22
     6da:	ac 01       	movw	r20, r24
     6dc:	c8 01       	movw	r24, r16
     6de:	b7 01       	movw	r22, r14
     6e0:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     6e4:	dc 01       	movw	r26, r24
     6e6:	cb 01       	movw	r24, r22
     6e8:	9c 01       	movw	r18, r24
     6ea:	ad 01       	movw	r20, r26
     6ec:	c6 01       	movw	r24, r12
     6ee:	b5 01       	movw	r22, r10
     6f0:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     6f4:	dc 01       	movw	r26, r24
     6f6:	cb 01       	movw	r24, r22
     6f8:	ed a9       	ldd	r30, Y+53	; 0x35
     6fa:	fe a9       	ldd	r31, Y+54	; 0x36
     6fc:	80 ab       	std	Z+48, r24	; 0x30
     6fe:	91 ab       	std	Z+49, r25	; 0x31
     700:	a2 ab       	std	Z+50, r26	; 0x32
     702:	b3 ab       	std	Z+51, r27	; 0x33
    ptr->theta_dot = ptr->q * cos(ptr->phi) - ptr->r * sin(ptr->phi);
     704:	8d a9       	ldd	r24, Y+53	; 0x35
     706:	9e a9       	ldd	r25, Y+54	; 0x36
     708:	fc 01       	movw	r30, r24
     70a:	e0 5c       	subi	r30, 0xC0	; 192
     70c:	ff 4f       	sbci	r31, 0xFF	; 255
     70e:	e0 80       	ld	r14, Z
     710:	f1 80       	ldd	r15, Z+1	; 0x01
     712:	02 81       	ldd	r16, Z+2	; 0x02
     714:	13 81       	ldd	r17, Z+3	; 0x03
     716:	ed a9       	ldd	r30, Y+53	; 0x35
     718:	fe a9       	ldd	r31, Y+54	; 0x36
     71a:	84 a1       	ldd	r24, Z+36	; 0x24
     71c:	95 a1       	ldd	r25, Z+37	; 0x25
     71e:	a6 a1       	ldd	r26, Z+38	; 0x26
     720:	b7 a1       	ldd	r27, Z+39	; 0x27
     722:	bc 01       	movw	r22, r24
     724:	cd 01       	movw	r24, r26
     726:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     72a:	9b 01       	movw	r18, r22
     72c:	ac 01       	movw	r20, r24
     72e:	c8 01       	movw	r24, r16
     730:	b7 01       	movw	r22, r14
     732:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     736:	dc 01       	movw	r26, r24
     738:	cb 01       	movw	r24, r22
     73a:	5c 01       	movw	r10, r24
     73c:	6d 01       	movw	r12, r26
     73e:	8d a9       	ldd	r24, Y+53	; 0x35
     740:	9e a9       	ldd	r25, Y+54	; 0x36
     742:	fc 01       	movw	r30, r24
     744:	ec 5b       	subi	r30, 0xBC	; 188
     746:	ff 4f       	sbci	r31, 0xFF	; 255
     748:	e0 80       	ld	r14, Z
     74a:	f1 80       	ldd	r15, Z+1	; 0x01
     74c:	02 81       	ldd	r16, Z+2	; 0x02
     74e:	13 81       	ldd	r17, Z+3	; 0x03
     750:	ed a9       	ldd	r30, Y+53	; 0x35
     752:	fe a9       	ldd	r31, Y+54	; 0x36
     754:	84 a1       	ldd	r24, Z+36	; 0x24
     756:	95 a1       	ldd	r25, Z+37	; 0x25
     758:	a6 a1       	ldd	r26, Z+38	; 0x26
     75a:	b7 a1       	ldd	r27, Z+39	; 0x27
     75c:	bc 01       	movw	r22, r24
     75e:	cd 01       	movw	r24, r26
     760:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     764:	9b 01       	movw	r18, r22
     766:	ac 01       	movw	r20, r24
     768:	c8 01       	movw	r24, r16
     76a:	b7 01       	movw	r22, r14
     76c:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     770:	dc 01       	movw	r26, r24
     772:	cb 01       	movw	r24, r22
     774:	9c 01       	movw	r18, r24
     776:	ad 01       	movw	r20, r26
     778:	c6 01       	movw	r24, r12
     77a:	b5 01       	movw	r22, r10
     77c:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     780:	dc 01       	movw	r26, r24
     782:	cb 01       	movw	r24, r22
     784:	ed a9       	ldd	r30, Y+53	; 0x35
     786:	fe a9       	ldd	r31, Y+54	; 0x36
     788:	84 ab       	std	Z+52, r24	; 0x34
     78a:	95 ab       	std	Z+53, r25	; 0x35
     78c:	a6 ab       	std	Z+54, r26	; 0x36
     78e:	b7 ab       	std	Z+55, r27	; 0x37
    ptr->psi_dot = ptr-> q * sin(ptr->phi) / cos(ptr->theta) + ptr->r * cos(ptr->phi) / sin(ptr->theta);
     790:	8d a9       	ldd	r24, Y+53	; 0x35
     792:	9e a9       	ldd	r25, Y+54	; 0x36
     794:	fc 01       	movw	r30, r24
     796:	e0 5c       	subi	r30, 0xC0	; 192
     798:	ff 4f       	sbci	r31, 0xFF	; 255
     79a:	e0 80       	ld	r14, Z
     79c:	f1 80       	ldd	r15, Z+1	; 0x01
     79e:	02 81       	ldd	r16, Z+2	; 0x02
     7a0:	13 81       	ldd	r17, Z+3	; 0x03
     7a2:	ed a9       	ldd	r30, Y+53	; 0x35
     7a4:	fe a9       	ldd	r31, Y+54	; 0x36
     7a6:	84 a1       	ldd	r24, Z+36	; 0x24
     7a8:	95 a1       	ldd	r25, Z+37	; 0x25
     7aa:	a6 a1       	ldd	r26, Z+38	; 0x26
     7ac:	b7 a1       	ldd	r27, Z+39	; 0x27
     7ae:	bc 01       	movw	r22, r24
     7b0:	cd 01       	movw	r24, r26
     7b2:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     7b6:	9b 01       	movw	r18, r22
     7b8:	ac 01       	movw	r20, r24
     7ba:	c8 01       	movw	r24, r16
     7bc:	b7 01       	movw	r22, r14
     7be:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     7c2:	dc 01       	movw	r26, r24
     7c4:	cb 01       	movw	r24, r22
     7c6:	7c 01       	movw	r14, r24
     7c8:	8d 01       	movw	r16, r26
     7ca:	ed a9       	ldd	r30, Y+53	; 0x35
     7cc:	fe a9       	ldd	r31, Y+54	; 0x36
     7ce:	80 a5       	ldd	r24, Z+40	; 0x28
     7d0:	91 a5       	ldd	r25, Z+41	; 0x29
     7d2:	a2 a5       	ldd	r26, Z+42	; 0x2a
     7d4:	b3 a5       	ldd	r27, Z+43	; 0x2b
     7d6:	bc 01       	movw	r22, r24
     7d8:	cd 01       	movw	r24, r26
     7da:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     7de:	9b 01       	movw	r18, r22
     7e0:	ac 01       	movw	r20, r24
     7e2:	c8 01       	movw	r24, r16
     7e4:	b7 01       	movw	r22, r14
     7e6:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     7ea:	dc 01       	movw	r26, r24
     7ec:	cb 01       	movw	r24, r22
     7ee:	5c 01       	movw	r10, r24
     7f0:	6d 01       	movw	r12, r26
     7f2:	8d a9       	ldd	r24, Y+53	; 0x35
     7f4:	9e a9       	ldd	r25, Y+54	; 0x36
     7f6:	fc 01       	movw	r30, r24
     7f8:	ec 5b       	subi	r30, 0xBC	; 188
     7fa:	ff 4f       	sbci	r31, 0xFF	; 255
     7fc:	e0 80       	ld	r14, Z
     7fe:	f1 80       	ldd	r15, Z+1	; 0x01
     800:	02 81       	ldd	r16, Z+2	; 0x02
     802:	13 81       	ldd	r17, Z+3	; 0x03
     804:	ed a9       	ldd	r30, Y+53	; 0x35
     806:	fe a9       	ldd	r31, Y+54	; 0x36
     808:	84 a1       	ldd	r24, Z+36	; 0x24
     80a:	95 a1       	ldd	r25, Z+37	; 0x25
     80c:	a6 a1       	ldd	r26, Z+38	; 0x26
     80e:	b7 a1       	ldd	r27, Z+39	; 0x27
     810:	bc 01       	movw	r22, r24
     812:	cd 01       	movw	r24, r26
     814:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     818:	9b 01       	movw	r18, r22
     81a:	ac 01       	movw	r20, r24
     81c:	c8 01       	movw	r24, r16
     81e:	b7 01       	movw	r22, r14
     820:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     824:	dc 01       	movw	r26, r24
     826:	cb 01       	movw	r24, r22
     828:	7c 01       	movw	r14, r24
     82a:	8d 01       	movw	r16, r26
     82c:	ed a9       	ldd	r30, Y+53	; 0x35
     82e:	fe a9       	ldd	r31, Y+54	; 0x36
     830:	80 a5       	ldd	r24, Z+40	; 0x28
     832:	91 a5       	ldd	r25, Z+41	; 0x29
     834:	a2 a5       	ldd	r26, Z+42	; 0x2a
     836:	b3 a5       	ldd	r27, Z+43	; 0x2b
     838:	bc 01       	movw	r22, r24
     83a:	cd 01       	movw	r24, r26
     83c:	0e 94 85 23 	call	0x470a	; 0x470a <sin>
     840:	9b 01       	movw	r18, r22
     842:	ac 01       	movw	r20, r24
     844:	c8 01       	movw	r24, r16
     846:	b7 01       	movw	r22, r14
     848:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     84c:	dc 01       	movw	r26, r24
     84e:	cb 01       	movw	r24, r22
     850:	9c 01       	movw	r18, r24
     852:	ad 01       	movw	r20, r26
     854:	c6 01       	movw	r24, r12
     856:	b5 01       	movw	r22, r10
     858:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     85c:	dc 01       	movw	r26, r24
     85e:	cb 01       	movw	r24, r22
     860:	ed a9       	ldd	r30, Y+53	; 0x35
     862:	fe a9       	ldd	r31, Y+54	; 0x36
     864:	80 af       	std	Z+56, r24	; 0x38
     866:	91 af       	std	Z+57, r25	; 0x39
     868:	a2 af       	std	Z+58, r26	; 0x3a
     86a:	b3 af       	std	Z+59, r27	; 0x3b
    ptr->phi += ptr->phi_dot * dt;
     86c:	ed a9       	ldd	r30, Y+53	; 0x35
     86e:	fe a9       	ldd	r31, Y+54	; 0x36
     870:	e4 a0       	ldd	r14, Z+36	; 0x24
     872:	f5 a0       	ldd	r15, Z+37	; 0x25
     874:	06 a1       	ldd	r16, Z+38	; 0x26
     876:	17 a1       	ldd	r17, Z+39	; 0x27
     878:	ed a9       	ldd	r30, Y+53	; 0x35
     87a:	fe a9       	ldd	r31, Y+54	; 0x36
     87c:	80 a9       	ldd	r24, Z+48	; 0x30
     87e:	91 a9       	ldd	r25, Z+49	; 0x31
     880:	a2 a9       	ldd	r26, Z+50	; 0x32
     882:	b3 a9       	ldd	r27, Z+51	; 0x33
     884:	bc 01       	movw	r22, r24
     886:	cd 01       	movw	r24, r26
     888:	29 a9       	ldd	r18, Y+49	; 0x31
     88a:	3a a9       	ldd	r19, Y+50	; 0x32
     88c:	4b a9       	ldd	r20, Y+51	; 0x33
     88e:	5c a9       	ldd	r21, Y+52	; 0x34
     890:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     894:	dc 01       	movw	r26, r24
     896:	cb 01       	movw	r24, r22
     898:	9c 01       	movw	r18, r24
     89a:	ad 01       	movw	r20, r26
     89c:	c8 01       	movw	r24, r16
     89e:	b7 01       	movw	r22, r14
     8a0:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     8a4:	dc 01       	movw	r26, r24
     8a6:	cb 01       	movw	r24, r22
     8a8:	ed a9       	ldd	r30, Y+53	; 0x35
     8aa:	fe a9       	ldd	r31, Y+54	; 0x36
     8ac:	84 a3       	std	Z+36, r24	; 0x24
     8ae:	95 a3       	std	Z+37, r25	; 0x25
     8b0:	a6 a3       	std	Z+38, r26	; 0x26
     8b2:	b7 a3       	std	Z+39, r27	; 0x27
    ptr->theta += ptr->theta_dot * dt;
     8b4:	ed a9       	ldd	r30, Y+53	; 0x35
     8b6:	fe a9       	ldd	r31, Y+54	; 0x36
     8b8:	e0 a4       	ldd	r14, Z+40	; 0x28
     8ba:	f1 a4       	ldd	r15, Z+41	; 0x29
     8bc:	02 a5       	ldd	r16, Z+42	; 0x2a
     8be:	13 a5       	ldd	r17, Z+43	; 0x2b
     8c0:	ed a9       	ldd	r30, Y+53	; 0x35
     8c2:	fe a9       	ldd	r31, Y+54	; 0x36
     8c4:	84 a9       	ldd	r24, Z+52	; 0x34
     8c6:	95 a9       	ldd	r25, Z+53	; 0x35
     8c8:	a6 a9       	ldd	r26, Z+54	; 0x36
     8ca:	b7 a9       	ldd	r27, Z+55	; 0x37
     8cc:	bc 01       	movw	r22, r24
     8ce:	cd 01       	movw	r24, r26
     8d0:	29 a9       	ldd	r18, Y+49	; 0x31
     8d2:	3a a9       	ldd	r19, Y+50	; 0x32
     8d4:	4b a9       	ldd	r20, Y+51	; 0x33
     8d6:	5c a9       	ldd	r21, Y+52	; 0x34
     8d8:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     8dc:	dc 01       	movw	r26, r24
     8de:	cb 01       	movw	r24, r22
     8e0:	9c 01       	movw	r18, r24
     8e2:	ad 01       	movw	r20, r26
     8e4:	c8 01       	movw	r24, r16
     8e6:	b7 01       	movw	r22, r14
     8e8:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     8ec:	dc 01       	movw	r26, r24
     8ee:	cb 01       	movw	r24, r22
     8f0:	ed a9       	ldd	r30, Y+53	; 0x35
     8f2:	fe a9       	ldd	r31, Y+54	; 0x36
     8f4:	80 a7       	std	Z+40, r24	; 0x28
     8f6:	91 a7       	std	Z+41, r25	; 0x29
     8f8:	a2 a7       	std	Z+42, r26	; 0x2a
     8fa:	b3 a7       	std	Z+43, r27	; 0x2b
    ptr->psi += ptr->psi_dot * dt;
     8fc:	ed a9       	ldd	r30, Y+53	; 0x35
     8fe:	fe a9       	ldd	r31, Y+54	; 0x36
     900:	e4 a4       	ldd	r14, Z+44	; 0x2c
     902:	f5 a4       	ldd	r15, Z+45	; 0x2d
     904:	06 a5       	ldd	r16, Z+46	; 0x2e
     906:	17 a5       	ldd	r17, Z+47	; 0x2f
     908:	ed a9       	ldd	r30, Y+53	; 0x35
     90a:	fe a9       	ldd	r31, Y+54	; 0x36
     90c:	80 ad       	ldd	r24, Z+56	; 0x38
     90e:	91 ad       	ldd	r25, Z+57	; 0x39
     910:	a2 ad       	ldd	r26, Z+58	; 0x3a
     912:	b3 ad       	ldd	r27, Z+59	; 0x3b
     914:	bc 01       	movw	r22, r24
     916:	cd 01       	movw	r24, r26
     918:	29 a9       	ldd	r18, Y+49	; 0x31
     91a:	3a a9       	ldd	r19, Y+50	; 0x32
     91c:	4b a9       	ldd	r20, Y+51	; 0x33
     91e:	5c a9       	ldd	r21, Y+52	; 0x34
     920:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     924:	dc 01       	movw	r26, r24
     926:	cb 01       	movw	r24, r22
     928:	9c 01       	movw	r18, r24
     92a:	ad 01       	movw	r20, r26
     92c:	c8 01       	movw	r24, r16
     92e:	b7 01       	movw	r22, r14
     930:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     934:	dc 01       	movw	r26, r24
     936:	cb 01       	movw	r24, r22
     938:	ed a9       	ldd	r30, Y+53	; 0x35
     93a:	fe a9       	ldd	r31, Y+54	; 0x36
     93c:	84 a7       	std	Z+44, r24	; 0x2c
     93e:	95 a7       	std	Z+45, r25	; 0x2d
     940:	a6 a7       	std	Z+46, r26	; 0x2e
     942:	b7 a7       	std	Z+47, r27	; 0x2f

    b_x_dot_cmd= (R13-R13_cmd)/taw;
     944:	6d 85       	ldd	r22, Y+13	; 0x0d
     946:	7e 85       	ldd	r23, Y+14	; 0x0e
     948:	8f 85       	ldd	r24, Y+15	; 0x0f
     94a:	98 89       	ldd	r25, Y+16	; 0x10
     94c:	29 85       	ldd	r18, Y+9	; 0x09
     94e:	3a 85       	ldd	r19, Y+10	; 0x0a
     950:	4b 85       	ldd	r20, Y+11	; 0x0b
     952:	5c 85       	ldd	r21, Y+12	; 0x0c
     954:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     958:	dc 01       	movw	r26, r24
     95a:	cb 01       	movw	r24, r22
     95c:	bc 01       	movw	r22, r24
     95e:	cd 01       	movw	r24, r26
     960:	2d a1       	ldd	r18, Y+37	; 0x25
     962:	3e a1       	ldd	r19, Y+38	; 0x26
     964:	4f a1       	ldd	r20, Y+39	; 0x27
     966:	58 a5       	ldd	r21, Y+40	; 0x28
     968:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     96c:	dc 01       	movw	r26, r24
     96e:	cb 01       	movw	r24, r22
     970:	8d a7       	std	Y+45, r24	; 0x2d
     972:	9e a7       	std	Y+46, r25	; 0x2e
     974:	af a7       	std	Y+47, r26	; 0x2f
     976:	b8 ab       	std	Y+48, r27	; 0x30
    b_y_dot_cmd= (R23-R23_cmd)/taw;
     978:	6d 81       	ldd	r22, Y+5	; 0x05
     97a:	7e 81       	ldd	r23, Y+6	; 0x06
     97c:	8f 81       	ldd	r24, Y+7	; 0x07
     97e:	98 85       	ldd	r25, Y+8	; 0x08
     980:	29 81       	ldd	r18, Y+1	; 0x01
     982:	3a 81       	ldd	r19, Y+2	; 0x02
     984:	4b 81       	ldd	r20, Y+3	; 0x03
     986:	5c 81       	ldd	r21, Y+4	; 0x04
     988:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     98c:	dc 01       	movw	r26, r24
     98e:	cb 01       	movw	r24, r22
     990:	bc 01       	movw	r22, r24
     992:	cd 01       	movw	r24, r26
     994:	2d a1       	ldd	r18, Y+37	; 0x25
     996:	3e a1       	ldd	r19, Y+38	; 0x26
     998:	4f a1       	ldd	r20, Y+39	; 0x27
     99a:	58 a5       	ldd	r21, Y+40	; 0x28
     99c:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     9a0:	dc 01       	movw	r26, r24
     9a2:	cb 01       	movw	r24, r22
     9a4:	89 a7       	std	Y+41, r24	; 0x29
     9a6:	9a a7       	std	Y+42, r25	; 0x2a
     9a8:	ab a7       	std	Y+43, r26	; 0x2b
     9aa:	bc a7       	std	Y+44, r27	; 0x2c

    ptr->p_cmd = 1/R33 * (R21*b_x_dot_cmd - R11*b_y_dot_cmd);
     9ac:	60 e0       	ldi	r22, 0x00	; 0
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	80 e8       	ldi	r24, 0x80	; 128
     9b2:	9f e3       	ldi	r25, 0x3F	; 63
     9b4:	29 89       	ldd	r18, Y+17	; 0x11
     9b6:	3a 89       	ldd	r19, Y+18	; 0x12
     9b8:	4b 89       	ldd	r20, Y+19	; 0x13
     9ba:	5c 89       	ldd	r21, Y+20	; 0x14
     9bc:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     9c0:	dc 01       	movw	r26, r24
     9c2:	cb 01       	movw	r24, r22
     9c4:	5c 01       	movw	r10, r24
     9c6:	6d 01       	movw	r12, r26
     9c8:	6d 89       	ldd	r22, Y+21	; 0x15
     9ca:	7e 89       	ldd	r23, Y+22	; 0x16
     9cc:	8f 89       	ldd	r24, Y+23	; 0x17
     9ce:	98 8d       	ldd	r25, Y+24	; 0x18
     9d0:	2d a5       	ldd	r18, Y+45	; 0x2d
     9d2:	3e a5       	ldd	r19, Y+46	; 0x2e
     9d4:	4f a5       	ldd	r20, Y+47	; 0x2f
     9d6:	58 a9       	ldd	r21, Y+48	; 0x30
     9d8:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     9dc:	dc 01       	movw	r26, r24
     9de:	cb 01       	movw	r24, r22
     9e0:	7c 01       	movw	r14, r24
     9e2:	8d 01       	movw	r16, r26
     9e4:	69 a1       	ldd	r22, Y+33	; 0x21
     9e6:	7a a1       	ldd	r23, Y+34	; 0x22
     9e8:	8b a1       	ldd	r24, Y+35	; 0x23
     9ea:	9c a1       	ldd	r25, Y+36	; 0x24
     9ec:	29 a5       	ldd	r18, Y+41	; 0x29
     9ee:	3a a5       	ldd	r19, Y+42	; 0x2a
     9f0:	4b a5       	ldd	r20, Y+43	; 0x2b
     9f2:	5c a5       	ldd	r21, Y+44	; 0x2c
     9f4:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     9f8:	dc 01       	movw	r26, r24
     9fa:	cb 01       	movw	r24, r22
     9fc:	9c 01       	movw	r18, r24
     9fe:	ad 01       	movw	r20, r26
     a00:	c8 01       	movw	r24, r16
     a02:	b7 01       	movw	r22, r14
     a04:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     a08:	dc 01       	movw	r26, r24
     a0a:	cb 01       	movw	r24, r22
     a0c:	9c 01       	movw	r18, r24
     a0e:	ad 01       	movw	r20, r26
     a10:	c6 01       	movw	r24, r12
     a12:	b5 01       	movw	r22, r10
     a14:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     a18:	dc 01       	movw	r26, r24
     a1a:	cb 01       	movw	r24, r22
     a1c:	9c 01       	movw	r18, r24
     a1e:	ad 01       	movw	r20, r26
     a20:	8d a9       	ldd	r24, Y+53	; 0x35
     a22:	9e a9       	ldd	r25, Y+54	; 0x36
     a24:	fc 01       	movw	r30, r24
     a26:	e4 58       	subi	r30, 0x84	; 132
     a28:	ff 4f       	sbci	r31, 0xFF	; 255
     a2a:	20 83       	st	Z, r18
     a2c:	31 83       	std	Z+1, r19	; 0x01
     a2e:	42 83       	std	Z+2, r20	; 0x02
     a30:	53 83       	std	Z+3, r21	; 0x03
    ptr->q_cmd = 1/R33 * (R22*b_x_dot_cmd - R12*b_y_dot_cmd);
     a32:	60 e0       	ldi	r22, 0x00	; 0
     a34:	70 e0       	ldi	r23, 0x00	; 0
     a36:	80 e8       	ldi	r24, 0x80	; 128
     a38:	9f e3       	ldi	r25, 0x3F	; 63
     a3a:	29 89       	ldd	r18, Y+17	; 0x11
     a3c:	3a 89       	ldd	r19, Y+18	; 0x12
     a3e:	4b 89       	ldd	r20, Y+19	; 0x13
     a40:	5c 89       	ldd	r21, Y+20	; 0x14
     a42:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     a46:	dc 01       	movw	r26, r24
     a48:	cb 01       	movw	r24, r22
     a4a:	5c 01       	movw	r10, r24
     a4c:	6d 01       	movw	r12, r26
     a4e:	69 8d       	ldd	r22, Y+25	; 0x19
     a50:	7a 8d       	ldd	r23, Y+26	; 0x1a
     a52:	8b 8d       	ldd	r24, Y+27	; 0x1b
     a54:	9c 8d       	ldd	r25, Y+28	; 0x1c
     a56:	2d a5       	ldd	r18, Y+45	; 0x2d
     a58:	3e a5       	ldd	r19, Y+46	; 0x2e
     a5a:	4f a5       	ldd	r20, Y+47	; 0x2f
     a5c:	58 a9       	ldd	r21, Y+48	; 0x30
     a5e:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     a62:	dc 01       	movw	r26, r24
     a64:	cb 01       	movw	r24, r22
     a66:	7c 01       	movw	r14, r24
     a68:	8d 01       	movw	r16, r26
     a6a:	6d 8d       	ldd	r22, Y+29	; 0x1d
     a6c:	7e 8d       	ldd	r23, Y+30	; 0x1e
     a6e:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a70:	98 a1       	ldd	r25, Y+32	; 0x20
     a72:	29 a5       	ldd	r18, Y+41	; 0x29
     a74:	3a a5       	ldd	r19, Y+42	; 0x2a
     a76:	4b a5       	ldd	r20, Y+43	; 0x2b
     a78:	5c a5       	ldd	r21, Y+44	; 0x2c
     a7a:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     a7e:	dc 01       	movw	r26, r24
     a80:	cb 01       	movw	r24, r22
     a82:	9c 01       	movw	r18, r24
     a84:	ad 01       	movw	r20, r26
     a86:	c8 01       	movw	r24, r16
     a88:	b7 01       	movw	r22, r14
     a8a:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     a8e:	dc 01       	movw	r26, r24
     a90:	cb 01       	movw	r24, r22
     a92:	9c 01       	movw	r18, r24
     a94:	ad 01       	movw	r20, r26
     a96:	c6 01       	movw	r24, r12
     a98:	b5 01       	movw	r22, r10
     a9a:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     a9e:	dc 01       	movw	r26, r24
     aa0:	cb 01       	movw	r24, r22
     aa2:	9c 01       	movw	r18, r24
     aa4:	ad 01       	movw	r20, r26
     aa6:	8d a9       	ldd	r24, Y+53	; 0x35
     aa8:	9e a9       	ldd	r25, Y+54	; 0x36
     aaa:	fc 01       	movw	r30, r24
     aac:	e0 58       	subi	r30, 0x80	; 128
     aae:	ff 4f       	sbci	r31, 0xFF	; 255
     ab0:	20 83       	st	Z, r18
     ab2:	31 83       	std	Z+1, r19	; 0x01
     ab4:	42 83       	std	Z+2, r20	; 0x02
     ab6:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(1);
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <vTaskDelay>
     ac0:	8a cc       	rjmp	.-1772   	; 0x3d6 <roll_pitch+0x30>

00000ac2 <yaw_controller>:

	}
}
void yaw_controller(void *pt)
{
     ac2:	ef 92       	push	r14
     ac4:	ff 92       	push	r15
     ac6:	0f 93       	push	r16
     ac8:	1f 93       	push	r17
     aca:	df 93       	push	r29
     acc:	cf 93       	push	r28
     ace:	00 d0       	rcall	.+0      	; 0xad0 <yaw_controller+0xe>
     ad0:	00 d0       	rcall	.+0      	; 0xad2 <yaw_controller+0x10>
     ad2:	cd b7       	in	r28, 0x3d	; 61
     ad4:	de b7       	in	r29, 0x3e	; 62
     ad6:	9c 83       	std	Y+4, r25	; 0x04
     ad8:	8b 83       	std	Y+3, r24	; 0x03
	parameters* ptr= pt;
     ada:	8b 81       	ldd	r24, Y+3	; 0x03
     adc:	9c 81       	ldd	r25, Y+4	; 0x04
     ade:	9a 83       	std	Y+2, r25	; 0x02
     ae0:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{ptr->r_cmd = kp_rate*(ptr->psi_cmd - ptr->psi);
     ae2:	80 91 05 01 	lds	r24, 0x0105
     ae6:	88 2f       	mov	r24, r24
     ae8:	90 e0       	ldi	r25, 0x00	; 0
     aea:	aa 27       	eor	r26, r26
     aec:	97 fd       	sbrc	r25, 7
     aee:	a0 95       	com	r26
     af0:	ba 2f       	mov	r27, r26
     af2:	bc 01       	movw	r22, r24
     af4:	cd 01       	movw	r24, r26
     af6:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     afa:	7b 01       	movw	r14, r22
     afc:	8c 01       	movw	r16, r24
     afe:	89 81       	ldd	r24, Y+1	; 0x01
     b00:	9a 81       	ldd	r25, Y+2	; 0x02
     b02:	fc 01       	movw	r30, r24
     b04:	e8 58       	subi	r30, 0x88	; 136
     b06:	ff 4f       	sbci	r31, 0xFF	; 255
     b08:	80 81       	ld	r24, Z
     b0a:	91 81       	ldd	r25, Z+1	; 0x01
     b0c:	a2 81       	ldd	r26, Z+2	; 0x02
     b0e:	b3 81       	ldd	r27, Z+3	; 0x03
     b10:	e9 81       	ldd	r30, Y+1	; 0x01
     b12:	fa 81       	ldd	r31, Y+2	; 0x02
     b14:	24 a5       	ldd	r18, Z+44	; 0x2c
     b16:	35 a5       	ldd	r19, Z+45	; 0x2d
     b18:	46 a5       	ldd	r20, Z+46	; 0x2e
     b1a:	57 a5       	ldd	r21, Z+47	; 0x2f
     b1c:	bc 01       	movw	r22, r24
     b1e:	cd 01       	movw	r24, r26
     b20:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     b24:	dc 01       	movw	r26, r24
     b26:	cb 01       	movw	r24, r22
     b28:	9c 01       	movw	r18, r24
     b2a:	ad 01       	movw	r20, r26
     b2c:	c8 01       	movw	r24, r16
     b2e:	b7 01       	movw	r22, r14
     b30:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     b34:	dc 01       	movw	r26, r24
     b36:	cb 01       	movw	r24, r22
     b38:	9c 01       	movw	r18, r24
     b3a:	ad 01       	movw	r20, r26
     b3c:	89 81       	ldd	r24, Y+1	; 0x01
     b3e:	9a 81       	ldd	r25, Y+2	; 0x02
     b40:	fc 01       	movw	r30, r24
     b42:	ec 57       	subi	r30, 0x7C	; 124
     b44:	ff 4f       	sbci	r31, 0xFF	; 255
     b46:	20 83       	st	Z, r18
     b48:	31 83       	std	Z+1, r19	; 0x01
     b4a:	42 83       	std	Z+2, r20	; 0x02
     b4c:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     b4e:	84 e6       	ldi	r24, 0x64	; 100
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <vTaskDelay>
     b56:	c5 cf       	rjmp	.-118    	; 0xae2 <yaw_controller+0x20>

00000b58 <altitude_controller>:

	}
}
void altitude_controller(void *pt)
{
     b58:	af 92       	push	r10
     b5a:	bf 92       	push	r11
     b5c:	cf 92       	push	r12
     b5e:	df 92       	push	r13
     b60:	ef 92       	push	r14
     b62:	ff 92       	push	r15
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	df 93       	push	r29
     b6a:	cf 93       	push	r28
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
     b70:	28 97       	sbiw	r28, 0x08	; 8
     b72:	0f b6       	in	r0, 0x3f	; 63
     b74:	f8 94       	cli
     b76:	de bf       	out	0x3e, r29	; 62
     b78:	0f be       	out	0x3f, r0	; 63
     b7a:	cd bf       	out	0x3d, r28	; 61
     b7c:	98 87       	std	Y+8, r25	; 0x08
     b7e:	8f 83       	std	Y+7, r24	; 0x07
	parameters* ptr= pt;
     b80:	8f 81       	ldd	r24, Y+7	; 0x07
     b82:	98 85       	ldd	r25, Y+8	; 0x08
     b84:	9e 83       	std	Y+6, r25	; 0x06
     b86:	8d 83       	std	Y+5, r24	; 0x05
	while(1)
	{f32 R33 = cos(ptr->phi)/cos(ptr->theta);
     b88:	ed 81       	ldd	r30, Y+5	; 0x05
     b8a:	fe 81       	ldd	r31, Y+6	; 0x06
     b8c:	84 a1       	ldd	r24, Z+36	; 0x24
     b8e:	95 a1       	ldd	r25, Z+37	; 0x25
     b90:	a6 a1       	ldd	r26, Z+38	; 0x26
     b92:	b7 a1       	ldd	r27, Z+39	; 0x27
     b94:	bc 01       	movw	r22, r24
     b96:	cd 01       	movw	r24, r26
     b98:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     b9c:	7b 01       	movw	r14, r22
     b9e:	8c 01       	movw	r16, r24
     ba0:	ed 81       	ldd	r30, Y+5	; 0x05
     ba2:	fe 81       	ldd	r31, Y+6	; 0x06
     ba4:	80 a5       	ldd	r24, Z+40	; 0x28
     ba6:	91 a5       	ldd	r25, Z+41	; 0x29
     ba8:	a2 a5       	ldd	r26, Z+42	; 0x2a
     baa:	b3 a5       	ldd	r27, Z+43	; 0x2b
     bac:	bc 01       	movw	r22, r24
     bae:	cd 01       	movw	r24, r26
     bb0:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <cos>
     bb4:	9b 01       	movw	r18, r22
     bb6:	ac 01       	movw	r20, r24
     bb8:	c8 01       	movw	r24, r16
     bba:	b7 01       	movw	r22, r14
     bbc:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     bc0:	dc 01       	movw	r26, r24
     bc2:	cb 01       	movw	r24, r22
     bc4:	89 83       	std	Y+1, r24	; 0x01
     bc6:	9a 83       	std	Y+2, r25	; 0x02
     bc8:	ab 83       	std	Y+3, r26	; 0x03
     bca:	bc 83       	std	Y+4, r27	; 0x04
	ptr->z_dot_dot_cmd= kp_rate*(ptr->z_cmd- ptr->z) + kd*(ptr->z_dot_cmd-ptr->z_dot);
     bcc:	80 91 05 01 	lds	r24, 0x0105
     bd0:	88 2f       	mov	r24, r24
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	aa 27       	eor	r26, r26
     bd6:	97 fd       	sbrc	r25, 7
     bd8:	a0 95       	com	r26
     bda:	ba 2f       	mov	r27, r26
     bdc:	bc 01       	movw	r22, r24
     bde:	cd 01       	movw	r24, r26
     be0:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     be4:	7b 01       	movw	r14, r22
     be6:	8c 01       	movw	r16, r24
     be8:	8d 81       	ldd	r24, Y+5	; 0x05
     bea:	9e 81       	ldd	r25, Y+6	; 0x06
     bec:	fc 01       	movw	r30, r24
     bee:	e4 5a       	subi	r30, 0xA4	; 164
     bf0:	ff 4f       	sbci	r31, 0xFF	; 255
     bf2:	80 81       	ld	r24, Z
     bf4:	91 81       	ldd	r25, Z+1	; 0x01
     bf6:	a2 81       	ldd	r26, Z+2	; 0x02
     bf8:	b3 81       	ldd	r27, Z+3	; 0x03
     bfa:	ed 81       	ldd	r30, Y+5	; 0x05
     bfc:	fe 81       	ldd	r31, Y+6	; 0x06
     bfe:	20 85       	ldd	r18, Z+8	; 0x08
     c00:	31 85       	ldd	r19, Z+9	; 0x09
     c02:	42 85       	ldd	r20, Z+10	; 0x0a
     c04:	53 85       	ldd	r21, Z+11	; 0x0b
     c06:	bc 01       	movw	r22, r24
     c08:	cd 01       	movw	r24, r26
     c0a:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     c0e:	dc 01       	movw	r26, r24
     c10:	cb 01       	movw	r24, r22
     c12:	9c 01       	movw	r18, r24
     c14:	ad 01       	movw	r20, r26
     c16:	c8 01       	movw	r24, r16
     c18:	b7 01       	movw	r22, r14
     c1a:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     c1e:	dc 01       	movw	r26, r24
     c20:	cb 01       	movw	r24, r22
     c22:	5c 01       	movw	r10, r24
     c24:	6d 01       	movw	r12, r26
     c26:	80 91 f3 03 	lds	r24, 0x03F3
     c2a:	88 2f       	mov	r24, r24
     c2c:	90 e0       	ldi	r25, 0x00	; 0
     c2e:	aa 27       	eor	r26, r26
     c30:	97 fd       	sbrc	r25, 7
     c32:	a0 95       	com	r26
     c34:	ba 2f       	mov	r27, r26
     c36:	bc 01       	movw	r22, r24
     c38:	cd 01       	movw	r24, r26
     c3a:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     c3e:	7b 01       	movw	r14, r22
     c40:	8c 01       	movw	r16, r24
     c42:	8d 81       	ldd	r24, Y+5	; 0x05
     c44:	9e 81       	ldd	r25, Y+6	; 0x06
     c46:	fc 01       	movw	r30, r24
     c48:	e8 59       	subi	r30, 0x98	; 152
     c4a:	ff 4f       	sbci	r31, 0xFF	; 255
     c4c:	80 81       	ld	r24, Z
     c4e:	91 81       	ldd	r25, Z+1	; 0x01
     c50:	a2 81       	ldd	r26, Z+2	; 0x02
     c52:	b3 81       	ldd	r27, Z+3	; 0x03
     c54:	ed 81       	ldd	r30, Y+5	; 0x05
     c56:	fe 81       	ldd	r31, Y+6	; 0x06
     c58:	24 89       	ldd	r18, Z+20	; 0x14
     c5a:	35 89       	ldd	r19, Z+21	; 0x15
     c5c:	46 89       	ldd	r20, Z+22	; 0x16
     c5e:	57 89       	ldd	r21, Z+23	; 0x17
     c60:	bc 01       	movw	r22, r24
     c62:	cd 01       	movw	r24, r26
     c64:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     c68:	dc 01       	movw	r26, r24
     c6a:	cb 01       	movw	r24, r22
     c6c:	9c 01       	movw	r18, r24
     c6e:	ad 01       	movw	r20, r26
     c70:	c8 01       	movw	r24, r16
     c72:	b7 01       	movw	r22, r14
     c74:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     c78:	dc 01       	movw	r26, r24
     c7a:	cb 01       	movw	r24, r22
     c7c:	9c 01       	movw	r18, r24
     c7e:	ad 01       	movw	r20, r26
     c80:	c6 01       	movw	r24, r12
     c82:	b5 01       	movw	r22, r10
     c84:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     c88:	dc 01       	movw	r26, r24
     c8a:	cb 01       	movw	r24, r22
     c8c:	9c 01       	movw	r18, r24
     c8e:	ad 01       	movw	r20, r26
     c90:	8d 81       	ldd	r24, Y+5	; 0x05
     c92:	9e 81       	ldd	r25, Y+6	; 0x06
     c94:	fc 01       	movw	r30, r24
     c96:	ec 58       	subi	r30, 0x8C	; 140
     c98:	ff 4f       	sbci	r31, 0xFF	; 255
     c9a:	20 83       	st	Z, r18
     c9c:	31 83       	std	Z+1, r19	; 0x01
     c9e:	42 83       	std	Z+2, r20	; 0x02
     ca0:	53 83       	std	Z+3, r21	; 0x03

	ptr->u1 = m* (ptr->z_dot_dot_cmd - g)/R33;
     ca2:	80 91 09 01 	lds	r24, 0x0109
     ca6:	88 2f       	mov	r24, r24
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	aa 27       	eor	r26, r26
     cac:	97 fd       	sbrc	r25, 7
     cae:	a0 95       	com	r26
     cb0:	ba 2f       	mov	r27, r26
     cb2:	bc 01       	movw	r22, r24
     cb4:	cd 01       	movw	r24, r26
     cb6:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     cba:	5b 01       	movw	r10, r22
     cbc:	6c 01       	movw	r12, r24
     cbe:	8d 81       	ldd	r24, Y+5	; 0x05
     cc0:	9e 81       	ldd	r25, Y+6	; 0x06
     cc2:	fc 01       	movw	r30, r24
     cc4:	ec 58       	subi	r30, 0x8C	; 140
     cc6:	ff 4f       	sbci	r31, 0xFF	; 255
     cc8:	e0 80       	ld	r14, Z
     cca:	f1 80       	ldd	r15, Z+1	; 0x01
     ccc:	02 81       	ldd	r16, Z+2	; 0x02
     cce:	13 81       	ldd	r17, Z+3	; 0x03
     cd0:	80 91 0b 01 	lds	r24, 0x010B
     cd4:	88 2f       	mov	r24, r24
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	aa 27       	eor	r26, r26
     cda:	97 fd       	sbrc	r25, 7
     cdc:	a0 95       	com	r26
     cde:	ba 2f       	mov	r27, r26
     ce0:	bc 01       	movw	r22, r24
     ce2:	cd 01       	movw	r24, r26
     ce4:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     ce8:	9b 01       	movw	r18, r22
     cea:	ac 01       	movw	r20, r24
     cec:	c8 01       	movw	r24, r16
     cee:	b7 01       	movw	r22, r14
     cf0:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     cf4:	dc 01       	movw	r26, r24
     cf6:	cb 01       	movw	r24, r22
     cf8:	9c 01       	movw	r18, r24
     cfa:	ad 01       	movw	r20, r26
     cfc:	c6 01       	movw	r24, r12
     cfe:	b5 01       	movw	r22, r10
     d00:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     d04:	dc 01       	movw	r26, r24
     d06:	cb 01       	movw	r24, r22
     d08:	bc 01       	movw	r22, r24
     d0a:	cd 01       	movw	r24, r26
     d0c:	29 81       	ldd	r18, Y+1	; 0x01
     d0e:	3a 81       	ldd	r19, Y+2	; 0x02
     d10:	4b 81       	ldd	r20, Y+3	; 0x03
     d12:	5c 81       	ldd	r21, Y+4	; 0x04
     d14:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <__divsf3>
     d18:	dc 01       	movw	r26, r24
     d1a:	cb 01       	movw	r24, r22
     d1c:	9c 01       	movw	r18, r24
     d1e:	ad 01       	movw	r20, r26
     d20:	8d 81       	ldd	r24, Y+5	; 0x05
     d22:	9e 81       	ldd	r25, Y+6	; 0x06
     d24:	fc 01       	movw	r30, r24
     d26:	e8 57       	subi	r30, 0x78	; 120
     d28:	ff 4f       	sbci	r31, 0xFF	; 255
     d2a:	20 83       	st	Z, r18
     d2c:	31 83       	std	Z+1, r19	; 0x01
     d2e:	42 83       	std	Z+2, r20	; 0x02
     d30:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     d32:	84 e6       	ldi	r24, 0x64	; 100
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <vTaskDelay>
     d3a:	26 cf       	rjmp	.-436    	; 0xb88 <altitude_controller+0x30>

00000d3c <lateral_controller>:
	}
}
void lateral_controller(void *pt)
{
     d3c:	af 92       	push	r10
     d3e:	bf 92       	push	r11
     d40:	cf 92       	push	r12
     d42:	df 92       	push	r13
     d44:	ef 92       	push	r14
     d46:	ff 92       	push	r15
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	df 93       	push	r29
     d4e:	cf 93       	push	r28
     d50:	00 d0       	rcall	.+0      	; 0xd52 <lateral_controller+0x16>
     d52:	00 d0       	rcall	.+0      	; 0xd54 <lateral_controller+0x18>
     d54:	cd b7       	in	r28, 0x3d	; 61
     d56:	de b7       	in	r29, 0x3e	; 62
     d58:	9c 83       	std	Y+4, r25	; 0x04
     d5a:	8b 83       	std	Y+3, r24	; 0x03
	parameters* ptr= pt;
     d5c:	8b 81       	ldd	r24, Y+3	; 0x03
     d5e:	9c 81       	ldd	r25, Y+4	; 0x04
     d60:	9a 83       	std	Y+2, r25	; 0x02
     d62:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
	ptr->x_dot_dot_cmd= kp_rate*(ptr->x_cmd- ptr->z) + kd*(ptr->x_dot_cmd-ptr->x_dot);
     d64:	80 91 05 01 	lds	r24, 0x0105
     d68:	88 2f       	mov	r24, r24
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	aa 27       	eor	r26, r26
     d6e:	97 fd       	sbrc	r25, 7
     d70:	a0 95       	com	r26
     d72:	ba 2f       	mov	r27, r26
     d74:	bc 01       	movw	r22, r24
     d76:	cd 01       	movw	r24, r26
     d78:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     d7c:	7b 01       	movw	r14, r22
     d7e:	8c 01       	movw	r16, r24
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	9a 81       	ldd	r25, Y+2	; 0x02
     d84:	fc 01       	movw	r30, r24
     d86:	ec 5a       	subi	r30, 0xAC	; 172
     d88:	ff 4f       	sbci	r31, 0xFF	; 255
     d8a:	80 81       	ld	r24, Z
     d8c:	91 81       	ldd	r25, Z+1	; 0x01
     d8e:	a2 81       	ldd	r26, Z+2	; 0x02
     d90:	b3 81       	ldd	r27, Z+3	; 0x03
     d92:	e9 81       	ldd	r30, Y+1	; 0x01
     d94:	fa 81       	ldd	r31, Y+2	; 0x02
     d96:	20 85       	ldd	r18, Z+8	; 0x08
     d98:	31 85       	ldd	r19, Z+9	; 0x09
     d9a:	42 85       	ldd	r20, Z+10	; 0x0a
     d9c:	53 85       	ldd	r21, Z+11	; 0x0b
     d9e:	bc 01       	movw	r22, r24
     da0:	cd 01       	movw	r24, r26
     da2:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     da6:	dc 01       	movw	r26, r24
     da8:	cb 01       	movw	r24, r22
     daa:	9c 01       	movw	r18, r24
     dac:	ad 01       	movw	r20, r26
     dae:	c8 01       	movw	r24, r16
     db0:	b7 01       	movw	r22, r14
     db2:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     db6:	dc 01       	movw	r26, r24
     db8:	cb 01       	movw	r24, r22
     dba:	5c 01       	movw	r10, r24
     dbc:	6d 01       	movw	r12, r26
     dbe:	80 91 f3 03 	lds	r24, 0x03F3
     dc2:	88 2f       	mov	r24, r24
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	aa 27       	eor	r26, r26
     dc8:	97 fd       	sbrc	r25, 7
     dca:	a0 95       	com	r26
     dcc:	ba 2f       	mov	r27, r26
     dce:	bc 01       	movw	r22, r24
     dd0:	cd 01       	movw	r24, r26
     dd2:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     dd6:	7b 01       	movw	r14, r22
     dd8:	8c 01       	movw	r16, r24
     dda:	89 81       	ldd	r24, Y+1	; 0x01
     ddc:	9a 81       	ldd	r25, Y+2	; 0x02
     dde:	fc 01       	movw	r30, r24
     de0:	e0 5a       	subi	r30, 0xA0	; 160
     de2:	ff 4f       	sbci	r31, 0xFF	; 255
     de4:	80 81       	ld	r24, Z
     de6:	91 81       	ldd	r25, Z+1	; 0x01
     de8:	a2 81       	ldd	r26, Z+2	; 0x02
     dea:	b3 81       	ldd	r27, Z+3	; 0x03
     dec:	e9 81       	ldd	r30, Y+1	; 0x01
     dee:	fa 81       	ldd	r31, Y+2	; 0x02
     df0:	24 85       	ldd	r18, Z+12	; 0x0c
     df2:	35 85       	ldd	r19, Z+13	; 0x0d
     df4:	46 85       	ldd	r20, Z+14	; 0x0e
     df6:	57 85       	ldd	r21, Z+15	; 0x0f
     df8:	bc 01       	movw	r22, r24
     dfa:	cd 01       	movw	r24, r26
     dfc:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     e00:	dc 01       	movw	r26, r24
     e02:	cb 01       	movw	r24, r22
     e04:	9c 01       	movw	r18, r24
     e06:	ad 01       	movw	r20, r26
     e08:	c8 01       	movw	r24, r16
     e0a:	b7 01       	movw	r22, r14
     e0c:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     e10:	dc 01       	movw	r26, r24
     e12:	cb 01       	movw	r24, r22
     e14:	9c 01       	movw	r18, r24
     e16:	ad 01       	movw	r20, r26
     e18:	c6 01       	movw	r24, r12
     e1a:	b5 01       	movw	r22, r10
     e1c:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     e20:	dc 01       	movw	r26, r24
     e22:	cb 01       	movw	r24, r22
     e24:	9c 01       	movw	r18, r24
     e26:	ad 01       	movw	r20, r26
     e28:	89 81       	ldd	r24, Y+1	; 0x01
     e2a:	9a 81       	ldd	r25, Y+2	; 0x02
     e2c:	fc 01       	movw	r30, r24
     e2e:	e4 59       	subi	r30, 0x94	; 148
     e30:	ff 4f       	sbci	r31, 0xFF	; 255
     e32:	20 83       	st	Z, r18
     e34:	31 83       	std	Z+1, r19	; 0x01
     e36:	42 83       	std	Z+2, r20	; 0x02
     e38:	53 83       	std	Z+3, r21	; 0x03
	ptr->y_dot_dot_cmd= kp_rate*(ptr->y_cmd- ptr->z) + kd*(ptr->y_dot_cmd-ptr->y_dot);
     e3a:	80 91 05 01 	lds	r24, 0x0105
     e3e:	88 2f       	mov	r24, r24
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	aa 27       	eor	r26, r26
     e44:	97 fd       	sbrc	r25, 7
     e46:	a0 95       	com	r26
     e48:	ba 2f       	mov	r27, r26
     e4a:	bc 01       	movw	r22, r24
     e4c:	cd 01       	movw	r24, r26
     e4e:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     e52:	7b 01       	movw	r14, r22
     e54:	8c 01       	movw	r16, r24
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	9a 81       	ldd	r25, Y+2	; 0x02
     e5a:	fc 01       	movw	r30, r24
     e5c:	e8 5a       	subi	r30, 0xA8	; 168
     e5e:	ff 4f       	sbci	r31, 0xFF	; 255
     e60:	80 81       	ld	r24, Z
     e62:	91 81       	ldd	r25, Z+1	; 0x01
     e64:	a2 81       	ldd	r26, Z+2	; 0x02
     e66:	b3 81       	ldd	r27, Z+3	; 0x03
     e68:	e9 81       	ldd	r30, Y+1	; 0x01
     e6a:	fa 81       	ldd	r31, Y+2	; 0x02
     e6c:	20 85       	ldd	r18, Z+8	; 0x08
     e6e:	31 85       	ldd	r19, Z+9	; 0x09
     e70:	42 85       	ldd	r20, Z+10	; 0x0a
     e72:	53 85       	ldd	r21, Z+11	; 0x0b
     e74:	bc 01       	movw	r22, r24
     e76:	cd 01       	movw	r24, r26
     e78:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     e7c:	dc 01       	movw	r26, r24
     e7e:	cb 01       	movw	r24, r22
     e80:	9c 01       	movw	r18, r24
     e82:	ad 01       	movw	r20, r26
     e84:	c8 01       	movw	r24, r16
     e86:	b7 01       	movw	r22, r14
     e88:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     e8c:	dc 01       	movw	r26, r24
     e8e:	cb 01       	movw	r24, r22
     e90:	5c 01       	movw	r10, r24
     e92:	6d 01       	movw	r12, r26
     e94:	80 91 f3 03 	lds	r24, 0x03F3
     e98:	88 2f       	mov	r24, r24
     e9a:	90 e0       	ldi	r25, 0x00	; 0
     e9c:	aa 27       	eor	r26, r26
     e9e:	97 fd       	sbrc	r25, 7
     ea0:	a0 95       	com	r26
     ea2:	ba 2f       	mov	r27, r26
     ea4:	bc 01       	movw	r22, r24
     ea6:	cd 01       	movw	r24, r26
     ea8:	0e 94 5d 22 	call	0x44ba	; 0x44ba <__floatsisf>
     eac:	7b 01       	movw	r14, r22
     eae:	8c 01       	movw	r16, r24
     eb0:	89 81       	ldd	r24, Y+1	; 0x01
     eb2:	9a 81       	ldd	r25, Y+2	; 0x02
     eb4:	fc 01       	movw	r30, r24
     eb6:	ec 59       	subi	r30, 0x9C	; 156
     eb8:	ff 4f       	sbci	r31, 0xFF	; 255
     eba:	80 81       	ld	r24, Z
     ebc:	91 81       	ldd	r25, Z+1	; 0x01
     ebe:	a2 81       	ldd	r26, Z+2	; 0x02
     ec0:	b3 81       	ldd	r27, Z+3	; 0x03
     ec2:	e9 81       	ldd	r30, Y+1	; 0x01
     ec4:	fa 81       	ldd	r31, Y+2	; 0x02
     ec6:	20 89       	ldd	r18, Z+16	; 0x10
     ec8:	31 89       	ldd	r19, Z+17	; 0x11
     eca:	42 89       	ldd	r20, Z+18	; 0x12
     ecc:	53 89       	ldd	r21, Z+19	; 0x13
     ece:	bc 01       	movw	r22, r24
     ed0:	cd 01       	movw	r24, r26
     ed2:	0e 94 8b 21 	call	0x4316	; 0x4316 <__subsf3>
     ed6:	dc 01       	movw	r26, r24
     ed8:	cb 01       	movw	r24, r22
     eda:	9c 01       	movw	r18, r24
     edc:	ad 01       	movw	r20, r26
     ede:	c8 01       	movw	r24, r16
     ee0:	b7 01       	movw	r22, r14
     ee2:	0e 94 22 23 	call	0x4644	; 0x4644 <__mulsf3>
     ee6:	dc 01       	movw	r26, r24
     ee8:	cb 01       	movw	r24, r22
     eea:	9c 01       	movw	r18, r24
     eec:	ad 01       	movw	r20, r26
     eee:	c6 01       	movw	r24, r12
     ef0:	b5 01       	movw	r22, r10
     ef2:	0e 94 8c 21 	call	0x4318	; 0x4318 <__addsf3>
     ef6:	dc 01       	movw	r26, r24
     ef8:	cb 01       	movw	r24, r22
     efa:	9c 01       	movw	r18, r24
     efc:	ad 01       	movw	r20, r26
     efe:	89 81       	ldd	r24, Y+1	; 0x01
     f00:	9a 81       	ldd	r25, Y+2	; 0x02
     f02:	fc 01       	movw	r30, r24
     f04:	e0 59       	subi	r30, 0x90	; 144
     f06:	ff 4f       	sbci	r31, 0xFF	; 255
     f08:	20 83       	st	Z, r18
     f0a:	31 83       	std	Z+1, r19	; 0x01
     f0c:	42 83       	std	Z+2, r20	; 0x02
     f0e:	53 83       	std	Z+3, r21	; 0x03
	vTaskDelay(100);
     f10:	84 e6       	ldi	r24, 0x64	; 100
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <vTaskDelay>
     f18:	25 cf       	rjmp	.-438    	; 0xd64 <lateral_controller+0x28>

00000f1a <SetPinDir>:
#include "DDIO_128.h"
#include "STD_TYPES.h"
#include "UTILS.h"

void SetPinDir(u8 PinNumber,u8 PinDirection)
{
     f1a:	df 93       	push	r29
     f1c:	cf 93       	push	r28
     f1e:	00 d0       	rcall	.+0      	; 0xf20 <SetPinDir+0x6>
     f20:	00 d0       	rcall	.+0      	; 0xf22 <SetPinDir+0x8>
     f22:	0f 92       	push	r0
     f24:	cd b7       	in	r28, 0x3d	; 61
     f26:	de b7       	in	r29, 0x3e	; 62
     f28:	8a 83       	std	Y+2, r24	; 0x02
     f2a:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/8;
     f2c:	8a 81       	ldd	r24, Y+2	; 0x02
     f2e:	86 95       	lsr	r24
     f30:	86 95       	lsr	r24
     f32:	86 95       	lsr	r24
     f34:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter){
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	28 2f       	mov	r18, r24
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	3d 83       	std	Y+5, r19	; 0x05
     f3e:	2c 83       	std	Y+4, r18	; 0x04
     f40:	8c 81       	ldd	r24, Y+4	; 0x04
     f42:	9d 81       	ldd	r25, Y+5	; 0x05
     f44:	83 30       	cpi	r24, 0x03	; 3
     f46:	91 05       	cpc	r25, r1
     f48:	09 f4       	brne	.+2      	; 0xf4c <SetPinDir+0x32>
     f4a:	bf c0       	rjmp	.+382    	; 0x10ca <SetPinDir+0x1b0>
     f4c:	2c 81       	ldd	r18, Y+4	; 0x04
     f4e:	3d 81       	ldd	r19, Y+5	; 0x05
     f50:	24 30       	cpi	r18, 0x04	; 4
     f52:	31 05       	cpc	r19, r1
     f54:	8c f4       	brge	.+34     	; 0xf78 <SetPinDir+0x5e>
     f56:	8c 81       	ldd	r24, Y+4	; 0x04
     f58:	9d 81       	ldd	r25, Y+5	; 0x05
     f5a:	81 30       	cpi	r24, 0x01	; 1
     f5c:	91 05       	cpc	r25, r1
     f5e:	09 f4       	brne	.+2      	; 0xf62 <SetPinDir+0x48>
     f60:	50 c0       	rjmp	.+160    	; 0x1002 <SetPinDir+0xe8>
     f62:	2c 81       	ldd	r18, Y+4	; 0x04
     f64:	3d 81       	ldd	r19, Y+5	; 0x05
     f66:	22 30       	cpi	r18, 0x02	; 2
     f68:	31 05       	cpc	r19, r1
     f6a:	0c f0       	brlt	.+2      	; 0xf6e <SetPinDir+0x54>
     f6c:	7c c0       	rjmp	.+248    	; 0x1066 <SetPinDir+0x14c>
     f6e:	8c 81       	ldd	r24, Y+4	; 0x04
     f70:	9d 81       	ldd	r25, Y+5	; 0x05
     f72:	00 97       	sbiw	r24, 0x00	; 0
     f74:	a1 f0       	breq	.+40     	; 0xf9e <SetPinDir+0x84>
     f76:	70 c1       	rjmp	.+736    	; 0x1258 <__stack+0x159>
     f78:	2c 81       	ldd	r18, Y+4	; 0x04
     f7a:	3d 81       	ldd	r19, Y+5	; 0x05
     f7c:	25 30       	cpi	r18, 0x05	; 5
     f7e:	31 05       	cpc	r19, r1
     f80:	09 f4       	brne	.+2      	; 0xf84 <SetPinDir+0x6a>
     f82:	07 c1       	rjmp	.+526    	; 0x1192 <__stack+0x93>
     f84:	8c 81       	ldd	r24, Y+4	; 0x04
     f86:	9d 81       	ldd	r25, Y+5	; 0x05
     f88:	85 30       	cpi	r24, 0x05	; 5
     f8a:	91 05       	cpc	r25, r1
     f8c:	0c f4       	brge	.+2      	; 0xf90 <SetPinDir+0x76>
     f8e:	cf c0       	rjmp	.+414    	; 0x112e <__stack+0x2f>
     f90:	2c 81       	ldd	r18, Y+4	; 0x04
     f92:	3d 81       	ldd	r19, Y+5	; 0x05
     f94:	26 30       	cpi	r18, 0x06	; 6
     f96:	31 05       	cpc	r19, r1
     f98:	09 f4       	brne	.+2      	; 0xf9c <SetPinDir+0x82>
     f9a:	2d c1       	rjmp	.+602    	; 0x11f6 <__stack+0xf7>
     f9c:	5d c1       	rjmp	.+698    	; 0x1258 <__stack+0x159>
		case (0):
			if(PinDirection)
     f9e:	8b 81       	ldd	r24, Y+3	; 0x03
     fa0:	88 23       	and	r24, r24
     fa2:	b9 f0       	breq	.+46     	; 0xfd2 <SetPinDir+0xb8>
			SET_BIT(DDRA,PinNumber%8);
     fa4:	aa e3       	ldi	r26, 0x3A	; 58
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	ea e3       	ldi	r30, 0x3A	; 58
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	80 81       	ld	r24, Z
     fae:	48 2f       	mov	r20, r24
     fb0:	8a 81       	ldd	r24, Y+2	; 0x02
     fb2:	88 2f       	mov	r24, r24
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	9c 01       	movw	r18, r24
     fb8:	27 70       	andi	r18, 0x07	; 7
     fba:	30 70       	andi	r19, 0x00	; 0
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	02 2e       	mov	r0, r18
     fc2:	02 c0       	rjmp	.+4      	; 0xfc8 <SetPinDir+0xae>
     fc4:	88 0f       	add	r24, r24
     fc6:	99 1f       	adc	r25, r25
     fc8:	0a 94       	dec	r0
     fca:	e2 f7       	brpl	.-8      	; 0xfc4 <SetPinDir+0xaa>
     fcc:	84 2b       	or	r24, r20
     fce:	8c 93       	st	X, r24
     fd0:	43 c1       	rjmp	.+646    	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRA,PinNumber%8);
     fd2:	aa e3       	ldi	r26, 0x3A	; 58
     fd4:	b0 e0       	ldi	r27, 0x00	; 0
     fd6:	ea e3       	ldi	r30, 0x3A	; 58
     fd8:	f0 e0       	ldi	r31, 0x00	; 0
     fda:	80 81       	ld	r24, Z
     fdc:	48 2f       	mov	r20, r24
     fde:	8a 81       	ldd	r24, Y+2	; 0x02
     fe0:	88 2f       	mov	r24, r24
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	9c 01       	movw	r18, r24
     fe6:	27 70       	andi	r18, 0x07	; 7
     fe8:	30 70       	andi	r19, 0x00	; 0
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	02 2e       	mov	r0, r18
     ff0:	02 c0       	rjmp	.+4      	; 0xff6 <SetPinDir+0xdc>
     ff2:	88 0f       	add	r24, r24
     ff4:	99 1f       	adc	r25, r25
     ff6:	0a 94       	dec	r0
     ff8:	e2 f7       	brpl	.-8      	; 0xff2 <SetPinDir+0xd8>
     ffa:	80 95       	com	r24
     ffc:	84 23       	and	r24, r20
     ffe:	8c 93       	st	X, r24
    1000:	2b c1       	rjmp	.+598    	; 0x1258 <__stack+0x159>
			break;

		case (1):
		    if(PinDirection)
    1002:	8b 81       	ldd	r24, Y+3	; 0x03
    1004:	88 23       	and	r24, r24
    1006:	b9 f0       	breq	.+46     	; 0x1036 <SetPinDir+0x11c>
			SET_BIT(DDRB,PinNumber%8);
    1008:	a7 e3       	ldi	r26, 0x37	; 55
    100a:	b0 e0       	ldi	r27, 0x00	; 0
    100c:	e7 e3       	ldi	r30, 0x37	; 55
    100e:	f0 e0       	ldi	r31, 0x00	; 0
    1010:	80 81       	ld	r24, Z
    1012:	48 2f       	mov	r20, r24
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	88 2f       	mov	r24, r24
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	9c 01       	movw	r18, r24
    101c:	27 70       	andi	r18, 0x07	; 7
    101e:	30 70       	andi	r19, 0x00	; 0
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	02 2e       	mov	r0, r18
    1026:	02 c0       	rjmp	.+4      	; 0x102c <SetPinDir+0x112>
    1028:	88 0f       	add	r24, r24
    102a:	99 1f       	adc	r25, r25
    102c:	0a 94       	dec	r0
    102e:	e2 f7       	brpl	.-8      	; 0x1028 <SetPinDir+0x10e>
    1030:	84 2b       	or	r24, r20
    1032:	8c 93       	st	X, r24
    1034:	11 c1       	rjmp	.+546    	; 0x1258 <__stack+0x159>
	        else
			CLEAR_BIT(DDRB,PinNumber%8);
    1036:	a7 e3       	ldi	r26, 0x37	; 55
    1038:	b0 e0       	ldi	r27, 0x00	; 0
    103a:	e7 e3       	ldi	r30, 0x37	; 55
    103c:	f0 e0       	ldi	r31, 0x00	; 0
    103e:	80 81       	ld	r24, Z
    1040:	48 2f       	mov	r20, r24
    1042:	8a 81       	ldd	r24, Y+2	; 0x02
    1044:	88 2f       	mov	r24, r24
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	9c 01       	movw	r18, r24
    104a:	27 70       	andi	r18, 0x07	; 7
    104c:	30 70       	andi	r19, 0x00	; 0
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	02 2e       	mov	r0, r18
    1054:	02 c0       	rjmp	.+4      	; 0x105a <SetPinDir+0x140>
    1056:	88 0f       	add	r24, r24
    1058:	99 1f       	adc	r25, r25
    105a:	0a 94       	dec	r0
    105c:	e2 f7       	brpl	.-8      	; 0x1056 <SetPinDir+0x13c>
    105e:	80 95       	com	r24
    1060:	84 23       	and	r24, r20
    1062:	8c 93       	st	X, r24
    1064:	f9 c0       	rjmp	.+498    	; 0x1258 <__stack+0x159>
			break;

		case  (2):
			if(PinDirection)
    1066:	8b 81       	ldd	r24, Y+3	; 0x03
    1068:	88 23       	and	r24, r24
    106a:	b9 f0       	breq	.+46     	; 0x109a <SetPinDir+0x180>
			SET_BIT(DDRC,PinNumber%8);
    106c:	a4 e3       	ldi	r26, 0x34	; 52
    106e:	b0 e0       	ldi	r27, 0x00	; 0
    1070:	e4 e3       	ldi	r30, 0x34	; 52
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	80 81       	ld	r24, Z
    1076:	48 2f       	mov	r20, r24
    1078:	8a 81       	ldd	r24, Y+2	; 0x02
    107a:	88 2f       	mov	r24, r24
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	9c 01       	movw	r18, r24
    1080:	27 70       	andi	r18, 0x07	; 7
    1082:	30 70       	andi	r19, 0x00	; 0
    1084:	81 e0       	ldi	r24, 0x01	; 1
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	02 2e       	mov	r0, r18
    108a:	02 c0       	rjmp	.+4      	; 0x1090 <SetPinDir+0x176>
    108c:	88 0f       	add	r24, r24
    108e:	99 1f       	adc	r25, r25
    1090:	0a 94       	dec	r0
    1092:	e2 f7       	brpl	.-8      	; 0x108c <SetPinDir+0x172>
    1094:	84 2b       	or	r24, r20
    1096:	8c 93       	st	X, r24
    1098:	df c0       	rjmp	.+446    	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRC,PinNumber%8);
    109a:	a4 e3       	ldi	r26, 0x34	; 52
    109c:	b0 e0       	ldi	r27, 0x00	; 0
    109e:	e4 e3       	ldi	r30, 0x34	; 52
    10a0:	f0 e0       	ldi	r31, 0x00	; 0
    10a2:	80 81       	ld	r24, Z
    10a4:	48 2f       	mov	r20, r24
    10a6:	8a 81       	ldd	r24, Y+2	; 0x02
    10a8:	88 2f       	mov	r24, r24
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	9c 01       	movw	r18, r24
    10ae:	27 70       	andi	r18, 0x07	; 7
    10b0:	30 70       	andi	r19, 0x00	; 0
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	02 2e       	mov	r0, r18
    10b8:	02 c0       	rjmp	.+4      	; 0x10be <SetPinDir+0x1a4>
    10ba:	88 0f       	add	r24, r24
    10bc:	99 1f       	adc	r25, r25
    10be:	0a 94       	dec	r0
    10c0:	e2 f7       	brpl	.-8      	; 0x10ba <SetPinDir+0x1a0>
    10c2:	80 95       	com	r24
    10c4:	84 23       	and	r24, r20
    10c6:	8c 93       	st	X, r24
    10c8:	c7 c0       	rjmp	.+398    	; 0x1258 <__stack+0x159>
            break;

		case (3):
			if(PinDirection)
    10ca:	8b 81       	ldd	r24, Y+3	; 0x03
    10cc:	88 23       	and	r24, r24
    10ce:	b9 f0       	breq	.+46     	; 0x10fe <SetPinDir+0x1e4>
			SET_BIT(DDRD,PinNumber%8);
    10d0:	a1 e3       	ldi	r26, 0x31	; 49
    10d2:	b0 e0       	ldi	r27, 0x00	; 0
    10d4:	e1 e3       	ldi	r30, 0x31	; 49
    10d6:	f0 e0       	ldi	r31, 0x00	; 0
    10d8:	80 81       	ld	r24, Z
    10da:	48 2f       	mov	r20, r24
    10dc:	8a 81       	ldd	r24, Y+2	; 0x02
    10de:	88 2f       	mov	r24, r24
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	9c 01       	movw	r18, r24
    10e4:	27 70       	andi	r18, 0x07	; 7
    10e6:	30 70       	andi	r19, 0x00	; 0
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	90 e0       	ldi	r25, 0x00	; 0
    10ec:	02 2e       	mov	r0, r18
    10ee:	02 c0       	rjmp	.+4      	; 0x10f4 <SetPinDir+0x1da>
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	0a 94       	dec	r0
    10f6:	e2 f7       	brpl	.-8      	; 0x10f0 <SetPinDir+0x1d6>
    10f8:	84 2b       	or	r24, r20
    10fa:	8c 93       	st	X, r24
    10fc:	ad c0       	rjmp	.+346    	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRD,PinNumber%8);
    10fe:	a1 e3       	ldi	r26, 0x31	; 49
    1100:	b0 e0       	ldi	r27, 0x00	; 0
    1102:	e1 e3       	ldi	r30, 0x31	; 49
    1104:	f0 e0       	ldi	r31, 0x00	; 0
    1106:	80 81       	ld	r24, Z
    1108:	48 2f       	mov	r20, r24
    110a:	8a 81       	ldd	r24, Y+2	; 0x02
    110c:	88 2f       	mov	r24, r24
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	9c 01       	movw	r18, r24
    1112:	27 70       	andi	r18, 0x07	; 7
    1114:	30 70       	andi	r19, 0x00	; 0
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	02 2e       	mov	r0, r18
    111c:	02 c0       	rjmp	.+4      	; 0x1122 <__stack+0x23>
    111e:	88 0f       	add	r24, r24
    1120:	99 1f       	adc	r25, r25
    1122:	0a 94       	dec	r0
    1124:	e2 f7       	brpl	.-8      	; 0x111e <__stack+0x1f>
    1126:	80 95       	com	r24
    1128:	84 23       	and	r24, r20
    112a:	8c 93       	st	X, r24
    112c:	95 c0       	rjmp	.+298    	; 0x1258 <__stack+0x159>
			break;

		case (4):
			if(PinDirection)
    112e:	8b 81       	ldd	r24, Y+3	; 0x03
    1130:	88 23       	and	r24, r24
    1132:	b9 f0       	breq	.+46     	; 0x1162 <__stack+0x63>
			SET_BIT(DDRE,PinNumber%8);
    1134:	a2 e2       	ldi	r26, 0x22	; 34
    1136:	b0 e0       	ldi	r27, 0x00	; 0
    1138:	e2 e2       	ldi	r30, 0x22	; 34
    113a:	f0 e0       	ldi	r31, 0x00	; 0
    113c:	80 81       	ld	r24, Z
    113e:	48 2f       	mov	r20, r24
    1140:	8a 81       	ldd	r24, Y+2	; 0x02
    1142:	88 2f       	mov	r24, r24
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	9c 01       	movw	r18, r24
    1148:	27 70       	andi	r18, 0x07	; 7
    114a:	30 70       	andi	r19, 0x00	; 0
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	02 2e       	mov	r0, r18
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <__stack+0x59>
    1154:	88 0f       	add	r24, r24
    1156:	99 1f       	adc	r25, r25
    1158:	0a 94       	dec	r0
    115a:	e2 f7       	brpl	.-8      	; 0x1154 <__stack+0x55>
    115c:	84 2b       	or	r24, r20
    115e:	8c 93       	st	X, r24
    1160:	7b c0       	rjmp	.+246    	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRE,PinNumber%8);
    1162:	a2 e2       	ldi	r26, 0x22	; 34
    1164:	b0 e0       	ldi	r27, 0x00	; 0
    1166:	e2 e2       	ldi	r30, 0x22	; 34
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	80 81       	ld	r24, Z
    116c:	48 2f       	mov	r20, r24
    116e:	8a 81       	ldd	r24, Y+2	; 0x02
    1170:	88 2f       	mov	r24, r24
    1172:	90 e0       	ldi	r25, 0x00	; 0
    1174:	9c 01       	movw	r18, r24
    1176:	27 70       	andi	r18, 0x07	; 7
    1178:	30 70       	andi	r19, 0x00	; 0
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	02 2e       	mov	r0, r18
    1180:	02 c0       	rjmp	.+4      	; 0x1186 <__stack+0x87>
    1182:	88 0f       	add	r24, r24
    1184:	99 1f       	adc	r25, r25
    1186:	0a 94       	dec	r0
    1188:	e2 f7       	brpl	.-8      	; 0x1182 <__stack+0x83>
    118a:	80 95       	com	r24
    118c:	84 23       	and	r24, r20
    118e:	8c 93       	st	X, r24
    1190:	63 c0       	rjmp	.+198    	; 0x1258 <__stack+0x159>
			break;

		case (5):
			if(PinDirection)
    1192:	8b 81       	ldd	r24, Y+3	; 0x03
    1194:	88 23       	and	r24, r24
    1196:	b9 f0       	breq	.+46     	; 0x11c6 <__stack+0xc7>
			SET_BIT(DDRF,PinNumber%8);
    1198:	a1 e6       	ldi	r26, 0x61	; 97
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	e1 e6       	ldi	r30, 0x61	; 97
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	48 2f       	mov	r20, r24
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	88 2f       	mov	r24, r24
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	9c 01       	movw	r18, r24
    11ac:	27 70       	andi	r18, 0x07	; 7
    11ae:	30 70       	andi	r19, 0x00	; 0
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	02 2e       	mov	r0, r18
    11b6:	02 c0       	rjmp	.+4      	; 0x11bc <__stack+0xbd>
    11b8:	88 0f       	add	r24, r24
    11ba:	99 1f       	adc	r25, r25
    11bc:	0a 94       	dec	r0
    11be:	e2 f7       	brpl	.-8      	; 0x11b8 <__stack+0xb9>
    11c0:	84 2b       	or	r24, r20
    11c2:	8c 93       	st	X, r24
    11c4:	49 c0       	rjmp	.+146    	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRF,PinNumber%8);
    11c6:	a1 e6       	ldi	r26, 0x61	; 97
    11c8:	b0 e0       	ldi	r27, 0x00	; 0
    11ca:	e1 e6       	ldi	r30, 0x61	; 97
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	48 2f       	mov	r20, r24
    11d2:	8a 81       	ldd	r24, Y+2	; 0x02
    11d4:	88 2f       	mov	r24, r24
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	9c 01       	movw	r18, r24
    11da:	27 70       	andi	r18, 0x07	; 7
    11dc:	30 70       	andi	r19, 0x00	; 0
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	02 2e       	mov	r0, r18
    11e4:	02 c0       	rjmp	.+4      	; 0x11ea <__stack+0xeb>
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	0a 94       	dec	r0
    11ec:	e2 f7       	brpl	.-8      	; 0x11e6 <__stack+0xe7>
    11ee:	80 95       	com	r24
    11f0:	84 23       	and	r24, r20
    11f2:	8c 93       	st	X, r24
    11f4:	31 c0       	rjmp	.+98     	; 0x1258 <__stack+0x159>
			break;

		case (6):
			if(PinDirection)
    11f6:	8b 81       	ldd	r24, Y+3	; 0x03
    11f8:	88 23       	and	r24, r24
    11fa:	b9 f0       	breq	.+46     	; 0x122a <__stack+0x12b>
			SET_BIT(DDRG,PinNumber%8);
    11fc:	a4 e6       	ldi	r26, 0x64	; 100
    11fe:	b0 e0       	ldi	r27, 0x00	; 0
    1200:	e4 e6       	ldi	r30, 0x64	; 100
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	80 81       	ld	r24, Z
    1206:	48 2f       	mov	r20, r24
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	88 2f       	mov	r24, r24
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	9c 01       	movw	r18, r24
    1210:	27 70       	andi	r18, 0x07	; 7
    1212:	30 70       	andi	r19, 0x00	; 0
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	02 2e       	mov	r0, r18
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <__stack+0x121>
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	0a 94       	dec	r0
    1222:	e2 f7       	brpl	.-8      	; 0x121c <__stack+0x11d>
    1224:	84 2b       	or	r24, r20
    1226:	8c 93       	st	X, r24
    1228:	17 c0       	rjmp	.+46     	; 0x1258 <__stack+0x159>
			else
			CLEAR_BIT(DDRG,PinNumber%8);
    122a:	a4 e6       	ldi	r26, 0x64	; 100
    122c:	b0 e0       	ldi	r27, 0x00	; 0
    122e:	e4 e6       	ldi	r30, 0x64	; 100
    1230:	f0 e0       	ldi	r31, 0x00	; 0
    1232:	80 81       	ld	r24, Z
    1234:	48 2f       	mov	r20, r24
    1236:	8a 81       	ldd	r24, Y+2	; 0x02
    1238:	88 2f       	mov	r24, r24
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	9c 01       	movw	r18, r24
    123e:	27 70       	andi	r18, 0x07	; 7
    1240:	30 70       	andi	r19, 0x00	; 0
    1242:	81 e0       	ldi	r24, 0x01	; 1
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	02 2e       	mov	r0, r18
    1248:	02 c0       	rjmp	.+4      	; 0x124e <__stack+0x14f>
    124a:	88 0f       	add	r24, r24
    124c:	99 1f       	adc	r25, r25
    124e:	0a 94       	dec	r0
    1250:	e2 f7       	brpl	.-8      	; 0x124a <__stack+0x14b>
    1252:	80 95       	com	r24
    1254:	84 23       	and	r24, r20
    1256:	8c 93       	st	X, r24
			break;


	}
}
    1258:	0f 90       	pop	r0
    125a:	0f 90       	pop	r0
    125c:	0f 90       	pop	r0
    125e:	0f 90       	pop	r0
    1260:	0f 90       	pop	r0
    1262:	cf 91       	pop	r28
    1264:	df 91       	pop	r29
    1266:	08 95       	ret

00001268 <SetPinVal>:




void SetPinVal(u8 PinNumber,u8 PinValue)
{
    1268:	df 93       	push	r29
    126a:	cf 93       	push	r28
    126c:	00 d0       	rcall	.+0      	; 0x126e <SetPinVal+0x6>
    126e:	00 d0       	rcall	.+0      	; 0x1270 <SetPinVal+0x8>
    1270:	0f 92       	push	r0
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
    1276:	8a 83       	std	Y+2, r24	; 0x02
    1278:	6b 83       	std	Y+3, r22	; 0x03
	u8 PortLetter = PinNumber/8;
    127a:	8a 81       	ldd	r24, Y+2	; 0x02
    127c:	86 95       	lsr	r24
    127e:	86 95       	lsr	r24
    1280:	86 95       	lsr	r24
    1282:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter){
    1284:	89 81       	ldd	r24, Y+1	; 0x01
    1286:	28 2f       	mov	r18, r24
    1288:	30 e0       	ldi	r19, 0x00	; 0
    128a:	3d 83       	std	Y+5, r19	; 0x05
    128c:	2c 83       	std	Y+4, r18	; 0x04
    128e:	8c 81       	ldd	r24, Y+4	; 0x04
    1290:	9d 81       	ldd	r25, Y+5	; 0x05
    1292:	83 30       	cpi	r24, 0x03	; 3
    1294:	91 05       	cpc	r25, r1
    1296:	09 f4       	brne	.+2      	; 0x129a <SetPinVal+0x32>
    1298:	bf c0       	rjmp	.+382    	; 0x1418 <SetPinVal+0x1b0>
    129a:	2c 81       	ldd	r18, Y+4	; 0x04
    129c:	3d 81       	ldd	r19, Y+5	; 0x05
    129e:	24 30       	cpi	r18, 0x04	; 4
    12a0:	31 05       	cpc	r19, r1
    12a2:	8c f4       	brge	.+34     	; 0x12c6 <SetPinVal+0x5e>
    12a4:	8c 81       	ldd	r24, Y+4	; 0x04
    12a6:	9d 81       	ldd	r25, Y+5	; 0x05
    12a8:	81 30       	cpi	r24, 0x01	; 1
    12aa:	91 05       	cpc	r25, r1
    12ac:	09 f4       	brne	.+2      	; 0x12b0 <SetPinVal+0x48>
    12ae:	50 c0       	rjmp	.+160    	; 0x1350 <SetPinVal+0xe8>
    12b0:	2c 81       	ldd	r18, Y+4	; 0x04
    12b2:	3d 81       	ldd	r19, Y+5	; 0x05
    12b4:	22 30       	cpi	r18, 0x02	; 2
    12b6:	31 05       	cpc	r19, r1
    12b8:	0c f0       	brlt	.+2      	; 0x12bc <SetPinVal+0x54>
    12ba:	7c c0       	rjmp	.+248    	; 0x13b4 <SetPinVal+0x14c>
    12bc:	8c 81       	ldd	r24, Y+4	; 0x04
    12be:	9d 81       	ldd	r25, Y+5	; 0x05
    12c0:	00 97       	sbiw	r24, 0x00	; 0
    12c2:	a1 f0       	breq	.+40     	; 0x12ec <SetPinVal+0x84>
    12c4:	70 c1       	rjmp	.+736    	; 0x15a6 <SetPinVal+0x33e>
    12c6:	2c 81       	ldd	r18, Y+4	; 0x04
    12c8:	3d 81       	ldd	r19, Y+5	; 0x05
    12ca:	25 30       	cpi	r18, 0x05	; 5
    12cc:	31 05       	cpc	r19, r1
    12ce:	09 f4       	brne	.+2      	; 0x12d2 <SetPinVal+0x6a>
    12d0:	07 c1       	rjmp	.+526    	; 0x14e0 <SetPinVal+0x278>
    12d2:	8c 81       	ldd	r24, Y+4	; 0x04
    12d4:	9d 81       	ldd	r25, Y+5	; 0x05
    12d6:	85 30       	cpi	r24, 0x05	; 5
    12d8:	91 05       	cpc	r25, r1
    12da:	0c f4       	brge	.+2      	; 0x12de <SetPinVal+0x76>
    12dc:	cf c0       	rjmp	.+414    	; 0x147c <SetPinVal+0x214>
    12de:	2c 81       	ldd	r18, Y+4	; 0x04
    12e0:	3d 81       	ldd	r19, Y+5	; 0x05
    12e2:	26 30       	cpi	r18, 0x06	; 6
    12e4:	31 05       	cpc	r19, r1
    12e6:	09 f4       	brne	.+2      	; 0x12ea <SetPinVal+0x82>
    12e8:	2d c1       	rjmp	.+602    	; 0x1544 <SetPinVal+0x2dc>
    12ea:	5d c1       	rjmp	.+698    	; 0x15a6 <SetPinVal+0x33e>
		case (0):
		   if(PinValue)
    12ec:	8b 81       	ldd	r24, Y+3	; 0x03
    12ee:	88 23       	and	r24, r24
    12f0:	b9 f0       	breq	.+46     	; 0x1320 <SetPinVal+0xb8>
			   SET_BIT(PORTA,PinNumber%8);
    12f2:	ab e3       	ldi	r26, 0x3B	; 59
    12f4:	b0 e0       	ldi	r27, 0x00	; 0
    12f6:	eb e3       	ldi	r30, 0x3B	; 59
    12f8:	f0 e0       	ldi	r31, 0x00	; 0
    12fa:	80 81       	ld	r24, Z
    12fc:	48 2f       	mov	r20, r24
    12fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1300:	88 2f       	mov	r24, r24
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	9c 01       	movw	r18, r24
    1306:	27 70       	andi	r18, 0x07	; 7
    1308:	30 70       	andi	r19, 0x00	; 0
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	02 2e       	mov	r0, r18
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <SetPinVal+0xae>
    1312:	88 0f       	add	r24, r24
    1314:	99 1f       	adc	r25, r25
    1316:	0a 94       	dec	r0
    1318:	e2 f7       	brpl	.-8      	; 0x1312 <SetPinVal+0xaa>
    131a:	84 2b       	or	r24, r20
    131c:	8c 93       	st	X, r24
    131e:	43 c1       	rjmp	.+646    	; 0x15a6 <SetPinVal+0x33e>
		   else
			   CLEAR_BIT(PORTA,PinNumber%8);
    1320:	ab e3       	ldi	r26, 0x3B	; 59
    1322:	b0 e0       	ldi	r27, 0x00	; 0
    1324:	eb e3       	ldi	r30, 0x3B	; 59
    1326:	f0 e0       	ldi	r31, 0x00	; 0
    1328:	80 81       	ld	r24, Z
    132a:	48 2f       	mov	r20, r24
    132c:	8a 81       	ldd	r24, Y+2	; 0x02
    132e:	88 2f       	mov	r24, r24
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	9c 01       	movw	r18, r24
    1334:	27 70       	andi	r18, 0x07	; 7
    1336:	30 70       	andi	r19, 0x00	; 0
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	02 2e       	mov	r0, r18
    133e:	02 c0       	rjmp	.+4      	; 0x1344 <SetPinVal+0xdc>
    1340:	88 0f       	add	r24, r24
    1342:	99 1f       	adc	r25, r25
    1344:	0a 94       	dec	r0
    1346:	e2 f7       	brpl	.-8      	; 0x1340 <SetPinVal+0xd8>
    1348:	80 95       	com	r24
    134a:	84 23       	and	r24, r20
    134c:	8c 93       	st	X, r24
    134e:	2b c1       	rjmp	.+598    	; 0x15a6 <SetPinVal+0x33e>
				break;

		case (1):
			if(PinValue)
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	88 23       	and	r24, r24
    1354:	b9 f0       	breq	.+46     	; 0x1384 <SetPinVal+0x11c>
			    SET_BIT(PORTB,PinNumber%8);
    1356:	a8 e3       	ldi	r26, 0x38	; 56
    1358:	b0 e0       	ldi	r27, 0x00	; 0
    135a:	e8 e3       	ldi	r30, 0x38	; 56
    135c:	f0 e0       	ldi	r31, 0x00	; 0
    135e:	80 81       	ld	r24, Z
    1360:	48 2f       	mov	r20, r24
    1362:	8a 81       	ldd	r24, Y+2	; 0x02
    1364:	88 2f       	mov	r24, r24
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	9c 01       	movw	r18, r24
    136a:	27 70       	andi	r18, 0x07	; 7
    136c:	30 70       	andi	r19, 0x00	; 0
    136e:	81 e0       	ldi	r24, 0x01	; 1
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	02 2e       	mov	r0, r18
    1374:	02 c0       	rjmp	.+4      	; 0x137a <SetPinVal+0x112>
    1376:	88 0f       	add	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	0a 94       	dec	r0
    137c:	e2 f7       	brpl	.-8      	; 0x1376 <SetPinVal+0x10e>
    137e:	84 2b       	or	r24, r20
    1380:	8c 93       	st	X, r24
    1382:	11 c1       	rjmp	.+546    	; 0x15a6 <SetPinVal+0x33e>
			else
			    CLEAR_BIT(PORTB,PinNumber%8);
    1384:	a8 e3       	ldi	r26, 0x38	; 56
    1386:	b0 e0       	ldi	r27, 0x00	; 0
    1388:	e8 e3       	ldi	r30, 0x38	; 56
    138a:	f0 e0       	ldi	r31, 0x00	; 0
    138c:	80 81       	ld	r24, Z
    138e:	48 2f       	mov	r20, r24
    1390:	8a 81       	ldd	r24, Y+2	; 0x02
    1392:	88 2f       	mov	r24, r24
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	9c 01       	movw	r18, r24
    1398:	27 70       	andi	r18, 0x07	; 7
    139a:	30 70       	andi	r19, 0x00	; 0
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	02 2e       	mov	r0, r18
    13a2:	02 c0       	rjmp	.+4      	; 0x13a8 <SetPinVal+0x140>
    13a4:	88 0f       	add	r24, r24
    13a6:	99 1f       	adc	r25, r25
    13a8:	0a 94       	dec	r0
    13aa:	e2 f7       	brpl	.-8      	; 0x13a4 <SetPinVal+0x13c>
    13ac:	80 95       	com	r24
    13ae:	84 23       	and	r24, r20
    13b0:	8c 93       	st	X, r24
    13b2:	f9 c0       	rjmp	.+498    	; 0x15a6 <SetPinVal+0x33e>
				break;

		case (2):
			if(PinValue)
    13b4:	8b 81       	ldd	r24, Y+3	; 0x03
    13b6:	88 23       	and	r24, r24
    13b8:	b9 f0       	breq	.+46     	; 0x13e8 <SetPinVal+0x180>
				SET_BIT(PORTC,PinNumber%8);
    13ba:	a5 e3       	ldi	r26, 0x35	; 53
    13bc:	b0 e0       	ldi	r27, 0x00	; 0
    13be:	e5 e3       	ldi	r30, 0x35	; 53
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	48 2f       	mov	r20, r24
    13c6:	8a 81       	ldd	r24, Y+2	; 0x02
    13c8:	88 2f       	mov	r24, r24
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	9c 01       	movw	r18, r24
    13ce:	27 70       	andi	r18, 0x07	; 7
    13d0:	30 70       	andi	r19, 0x00	; 0
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	02 2e       	mov	r0, r18
    13d8:	02 c0       	rjmp	.+4      	; 0x13de <SetPinVal+0x176>
    13da:	88 0f       	add	r24, r24
    13dc:	99 1f       	adc	r25, r25
    13de:	0a 94       	dec	r0
    13e0:	e2 f7       	brpl	.-8      	; 0x13da <SetPinVal+0x172>
    13e2:	84 2b       	or	r24, r20
    13e4:	8c 93       	st	X, r24
    13e6:	df c0       	rjmp	.+446    	; 0x15a6 <SetPinVal+0x33e>
			else
				CLEAR_BIT(PORTC,PinNumber%8);
    13e8:	a5 e3       	ldi	r26, 0x35	; 53
    13ea:	b0 e0       	ldi	r27, 0x00	; 0
    13ec:	e5 e3       	ldi	r30, 0x35	; 53
    13ee:	f0 e0       	ldi	r31, 0x00	; 0
    13f0:	80 81       	ld	r24, Z
    13f2:	48 2f       	mov	r20, r24
    13f4:	8a 81       	ldd	r24, Y+2	; 0x02
    13f6:	88 2f       	mov	r24, r24
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	9c 01       	movw	r18, r24
    13fc:	27 70       	andi	r18, 0x07	; 7
    13fe:	30 70       	andi	r19, 0x00	; 0
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	90 e0       	ldi	r25, 0x00	; 0
    1404:	02 2e       	mov	r0, r18
    1406:	02 c0       	rjmp	.+4      	; 0x140c <SetPinVal+0x1a4>
    1408:	88 0f       	add	r24, r24
    140a:	99 1f       	adc	r25, r25
    140c:	0a 94       	dec	r0
    140e:	e2 f7       	brpl	.-8      	; 0x1408 <SetPinVal+0x1a0>
    1410:	80 95       	com	r24
    1412:	84 23       	and	r24, r20
    1414:	8c 93       	st	X, r24
    1416:	c7 c0       	rjmp	.+398    	; 0x15a6 <SetPinVal+0x33e>
         	 	break;

		case (3):
			if(PinValue)
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	88 23       	and	r24, r24
    141c:	b9 f0       	breq	.+46     	; 0x144c <SetPinVal+0x1e4>
				SET_BIT(PORTD,PinNumber%8);
    141e:	a2 e3       	ldi	r26, 0x32	; 50
    1420:	b0 e0       	ldi	r27, 0x00	; 0
    1422:	e2 e3       	ldi	r30, 0x32	; 50
    1424:	f0 e0       	ldi	r31, 0x00	; 0
    1426:	80 81       	ld	r24, Z
    1428:	48 2f       	mov	r20, r24
    142a:	8a 81       	ldd	r24, Y+2	; 0x02
    142c:	88 2f       	mov	r24, r24
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	9c 01       	movw	r18, r24
    1432:	27 70       	andi	r18, 0x07	; 7
    1434:	30 70       	andi	r19, 0x00	; 0
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	02 2e       	mov	r0, r18
    143c:	02 c0       	rjmp	.+4      	; 0x1442 <SetPinVal+0x1da>
    143e:	88 0f       	add	r24, r24
    1440:	99 1f       	adc	r25, r25
    1442:	0a 94       	dec	r0
    1444:	e2 f7       	brpl	.-8      	; 0x143e <SetPinVal+0x1d6>
    1446:	84 2b       	or	r24, r20
    1448:	8c 93       	st	X, r24
    144a:	ad c0       	rjmp	.+346    	; 0x15a6 <SetPinVal+0x33e>
			else
				CLEAR_BIT(PORTD,PinNumber%8);
    144c:	a2 e3       	ldi	r26, 0x32	; 50
    144e:	b0 e0       	ldi	r27, 0x00	; 0
    1450:	e2 e3       	ldi	r30, 0x32	; 50
    1452:	f0 e0       	ldi	r31, 0x00	; 0
    1454:	80 81       	ld	r24, Z
    1456:	48 2f       	mov	r20, r24
    1458:	8a 81       	ldd	r24, Y+2	; 0x02
    145a:	88 2f       	mov	r24, r24
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	9c 01       	movw	r18, r24
    1460:	27 70       	andi	r18, 0x07	; 7
    1462:	30 70       	andi	r19, 0x00	; 0
    1464:	81 e0       	ldi	r24, 0x01	; 1
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	02 2e       	mov	r0, r18
    146a:	02 c0       	rjmp	.+4      	; 0x1470 <SetPinVal+0x208>
    146c:	88 0f       	add	r24, r24
    146e:	99 1f       	adc	r25, r25
    1470:	0a 94       	dec	r0
    1472:	e2 f7       	brpl	.-8      	; 0x146c <SetPinVal+0x204>
    1474:	80 95       	com	r24
    1476:	84 23       	and	r24, r20
    1478:	8c 93       	st	X, r24
    147a:	95 c0       	rjmp	.+298    	; 0x15a6 <SetPinVal+0x33e>
        		break;

		case (4):
			if(PinValue)
    147c:	8b 81       	ldd	r24, Y+3	; 0x03
    147e:	88 23       	and	r24, r24
    1480:	b9 f0       	breq	.+46     	; 0x14b0 <SetPinVal+0x248>
				SET_BIT(PORTE,PinNumber%8);
    1482:	ae e2       	ldi	r26, 0x2E	; 46
    1484:	b0 e0       	ldi	r27, 0x00	; 0
    1486:	ee e2       	ldi	r30, 0x2E	; 46
    1488:	f0 e0       	ldi	r31, 0x00	; 0
    148a:	80 81       	ld	r24, Z
    148c:	48 2f       	mov	r20, r24
    148e:	8a 81       	ldd	r24, Y+2	; 0x02
    1490:	88 2f       	mov	r24, r24
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	9c 01       	movw	r18, r24
    1496:	27 70       	andi	r18, 0x07	; 7
    1498:	30 70       	andi	r19, 0x00	; 0
    149a:	81 e0       	ldi	r24, 0x01	; 1
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	02 2e       	mov	r0, r18
    14a0:	02 c0       	rjmp	.+4      	; 0x14a6 <SetPinVal+0x23e>
    14a2:	88 0f       	add	r24, r24
    14a4:	99 1f       	adc	r25, r25
    14a6:	0a 94       	dec	r0
    14a8:	e2 f7       	brpl	.-8      	; 0x14a2 <SetPinVal+0x23a>
    14aa:	84 2b       	or	r24, r20
    14ac:	8c 93       	st	X, r24
    14ae:	7b c0       	rjmp	.+246    	; 0x15a6 <SetPinVal+0x33e>
			else
				CLEAR_BIT(PORTE,PinNumber%8);
    14b0:	ae e2       	ldi	r26, 0x2E	; 46
    14b2:	b0 e0       	ldi	r27, 0x00	; 0
    14b4:	ee e2       	ldi	r30, 0x2E	; 46
    14b6:	f0 e0       	ldi	r31, 0x00	; 0
    14b8:	80 81       	ld	r24, Z
    14ba:	48 2f       	mov	r20, r24
    14bc:	8a 81       	ldd	r24, Y+2	; 0x02
    14be:	88 2f       	mov	r24, r24
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	9c 01       	movw	r18, r24
    14c4:	27 70       	andi	r18, 0x07	; 7
    14c6:	30 70       	andi	r19, 0x00	; 0
    14c8:	81 e0       	ldi	r24, 0x01	; 1
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	02 2e       	mov	r0, r18
    14ce:	02 c0       	rjmp	.+4      	; 0x14d4 <SetPinVal+0x26c>
    14d0:	88 0f       	add	r24, r24
    14d2:	99 1f       	adc	r25, r25
    14d4:	0a 94       	dec	r0
    14d6:	e2 f7       	brpl	.-8      	; 0x14d0 <SetPinVal+0x268>
    14d8:	80 95       	com	r24
    14da:	84 23       	and	r24, r20
    14dc:	8c 93       	st	X, r24
    14de:	63 c0       	rjmp	.+198    	; 0x15a6 <SetPinVal+0x33e>
        		break;

		case (5):
			if(PinValue)
    14e0:	8b 81       	ldd	r24, Y+3	; 0x03
    14e2:	88 23       	and	r24, r24
    14e4:	b9 f0       	breq	.+46     	; 0x1514 <SetPinVal+0x2ac>
				SET_BIT(PORTF,PinNumber%8);
    14e6:	a2 e6       	ldi	r26, 0x62	; 98
    14e8:	b0 e0       	ldi	r27, 0x00	; 0
    14ea:	e2 e6       	ldi	r30, 0x62	; 98
    14ec:	f0 e0       	ldi	r31, 0x00	; 0
    14ee:	80 81       	ld	r24, Z
    14f0:	48 2f       	mov	r20, r24
    14f2:	8a 81       	ldd	r24, Y+2	; 0x02
    14f4:	88 2f       	mov	r24, r24
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	9c 01       	movw	r18, r24
    14fa:	27 70       	andi	r18, 0x07	; 7
    14fc:	30 70       	andi	r19, 0x00	; 0
    14fe:	81 e0       	ldi	r24, 0x01	; 1
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	02 2e       	mov	r0, r18
    1504:	02 c0       	rjmp	.+4      	; 0x150a <SetPinVal+0x2a2>
    1506:	88 0f       	add	r24, r24
    1508:	99 1f       	adc	r25, r25
    150a:	0a 94       	dec	r0
    150c:	e2 f7       	brpl	.-8      	; 0x1506 <SetPinVal+0x29e>
    150e:	84 2b       	or	r24, r20
    1510:	8c 93       	st	X, r24
    1512:	49 c0       	rjmp	.+146    	; 0x15a6 <SetPinVal+0x33e>
			else
				CLEAR_BIT(PORTF,PinNumber%8);
    1514:	a2 e6       	ldi	r26, 0x62	; 98
    1516:	b0 e0       	ldi	r27, 0x00	; 0
    1518:	e2 e6       	ldi	r30, 0x62	; 98
    151a:	f0 e0       	ldi	r31, 0x00	; 0
    151c:	80 81       	ld	r24, Z
    151e:	48 2f       	mov	r20, r24
    1520:	8a 81       	ldd	r24, Y+2	; 0x02
    1522:	88 2f       	mov	r24, r24
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	9c 01       	movw	r18, r24
    1528:	27 70       	andi	r18, 0x07	; 7
    152a:	30 70       	andi	r19, 0x00	; 0
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	02 2e       	mov	r0, r18
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <SetPinVal+0x2d0>
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	0a 94       	dec	r0
    153a:	e2 f7       	brpl	.-8      	; 0x1534 <SetPinVal+0x2cc>
    153c:	80 95       	com	r24
    153e:	84 23       	and	r24, r20
    1540:	8c 93       	st	X, r24
    1542:	31 c0       	rjmp	.+98     	; 0x15a6 <SetPinVal+0x33e>
				break;

		case (6):
			if(PinValue)
    1544:	8b 81       	ldd	r24, Y+3	; 0x03
    1546:	88 23       	and	r24, r24
    1548:	b9 f0       	breq	.+46     	; 0x1578 <SetPinVal+0x310>
				SET_BIT(PORTG,PinNumber%8);
    154a:	a5 e6       	ldi	r26, 0x65	; 101
    154c:	b0 e0       	ldi	r27, 0x00	; 0
    154e:	e5 e6       	ldi	r30, 0x65	; 101
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	80 81       	ld	r24, Z
    1554:	48 2f       	mov	r20, r24
    1556:	8a 81       	ldd	r24, Y+2	; 0x02
    1558:	88 2f       	mov	r24, r24
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	9c 01       	movw	r18, r24
    155e:	27 70       	andi	r18, 0x07	; 7
    1560:	30 70       	andi	r19, 0x00	; 0
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	02 2e       	mov	r0, r18
    1568:	02 c0       	rjmp	.+4      	; 0x156e <SetPinVal+0x306>
    156a:	88 0f       	add	r24, r24
    156c:	99 1f       	adc	r25, r25
    156e:	0a 94       	dec	r0
    1570:	e2 f7       	brpl	.-8      	; 0x156a <SetPinVal+0x302>
    1572:	84 2b       	or	r24, r20
    1574:	8c 93       	st	X, r24
    1576:	17 c0       	rjmp	.+46     	; 0x15a6 <SetPinVal+0x33e>
			else
				CLEAR_BIT(PORTG,PinNumber%8);
    1578:	a5 e6       	ldi	r26, 0x65	; 101
    157a:	b0 e0       	ldi	r27, 0x00	; 0
    157c:	e5 e6       	ldi	r30, 0x65	; 101
    157e:	f0 e0       	ldi	r31, 0x00	; 0
    1580:	80 81       	ld	r24, Z
    1582:	48 2f       	mov	r20, r24
    1584:	8a 81       	ldd	r24, Y+2	; 0x02
    1586:	88 2f       	mov	r24, r24
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	9c 01       	movw	r18, r24
    158c:	27 70       	andi	r18, 0x07	; 7
    158e:	30 70       	andi	r19, 0x00	; 0
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	02 2e       	mov	r0, r18
    1596:	02 c0       	rjmp	.+4      	; 0x159c <SetPinVal+0x334>
    1598:	88 0f       	add	r24, r24
    159a:	99 1f       	adc	r25, r25
    159c:	0a 94       	dec	r0
    159e:	e2 f7       	brpl	.-8      	; 0x1598 <SetPinVal+0x330>
    15a0:	80 95       	com	r24
    15a2:	84 23       	and	r24, r20
    15a4:	8c 93       	st	X, r24
        		break;


	}

}
    15a6:	0f 90       	pop	r0
    15a8:	0f 90       	pop	r0
    15aa:	0f 90       	pop	r0
    15ac:	0f 90       	pop	r0
    15ae:	0f 90       	pop	r0
    15b0:	cf 91       	pop	r28
    15b2:	df 91       	pop	r29
    15b4:	08 95       	ret

000015b6 <ReadPinVal>:

u8 ReadPinVal(u8 PinNumber)
{
    15b6:	df 93       	push	r29
    15b8:	cf 93       	push	r28
    15ba:	00 d0       	rcall	.+0      	; 0x15bc <ReadPinVal+0x6>
    15bc:	00 d0       	rcall	.+0      	; 0x15be <ReadPinVal+0x8>
    15be:	00 d0       	rcall	.+0      	; 0x15c0 <ReadPinVal+0xa>
    15c0:	cd b7       	in	r28, 0x3d	; 61
    15c2:	de b7       	in	r29, 0x3e	; 62
    15c4:	8a 83       	std	Y+2, r24	; 0x02
	u8 PortLetter = PinNumber/8;
    15c6:	8a 81       	ldd	r24, Y+2	; 0x02
    15c8:	86 95       	lsr	r24
    15ca:	86 95       	lsr	r24
    15cc:	86 95       	lsr	r24
    15ce:	89 83       	std	Y+1, r24	; 0x01

	switch(PortLetter)
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	28 2f       	mov	r18, r24
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	3d 83       	std	Y+5, r19	; 0x05
    15d8:	2c 83       	std	Y+4, r18	; 0x04
    15da:	4c 81       	ldd	r20, Y+4	; 0x04
    15dc:	5d 81       	ldd	r21, Y+5	; 0x05
    15de:	43 30       	cpi	r20, 0x03	; 3
    15e0:	51 05       	cpc	r21, r1
    15e2:	09 f4       	brne	.+2      	; 0x15e6 <ReadPinVal+0x30>
    15e4:	67 c0       	rjmp	.+206    	; 0x16b4 <ReadPinVal+0xfe>
    15e6:	8c 81       	ldd	r24, Y+4	; 0x04
    15e8:	9d 81       	ldd	r25, Y+5	; 0x05
    15ea:	84 30       	cpi	r24, 0x04	; 4
    15ec:	91 05       	cpc	r25, r1
    15ee:	84 f4       	brge	.+32     	; 0x1610 <ReadPinVal+0x5a>
    15f0:	2c 81       	ldd	r18, Y+4	; 0x04
    15f2:	3d 81       	ldd	r19, Y+5	; 0x05
    15f4:	21 30       	cpi	r18, 0x01	; 1
    15f6:	31 05       	cpc	r19, r1
    15f8:	99 f1       	breq	.+102    	; 0x1660 <ReadPinVal+0xaa>
    15fa:	4c 81       	ldd	r20, Y+4	; 0x04
    15fc:	5d 81       	ldd	r21, Y+5	; 0x05
    15fe:	42 30       	cpi	r20, 0x02	; 2
    1600:	51 05       	cpc	r21, r1
    1602:	0c f0       	brlt	.+2      	; 0x1606 <ReadPinVal+0x50>
    1604:	42 c0       	rjmp	.+132    	; 0x168a <ReadPinVal+0xd4>
    1606:	8c 81       	ldd	r24, Y+4	; 0x04
    1608:	9d 81       	ldd	r25, Y+5	; 0x05
    160a:	00 97       	sbiw	r24, 0x00	; 0
    160c:	a1 f0       	breq	.+40     	; 0x1636 <ReadPinVal+0x80>
    160e:	a6 c0       	rjmp	.+332    	; 0x175c <ReadPinVal+0x1a6>
    1610:	2c 81       	ldd	r18, Y+4	; 0x04
    1612:	3d 81       	ldd	r19, Y+5	; 0x05
    1614:	25 30       	cpi	r18, 0x05	; 5
    1616:	31 05       	cpc	r19, r1
    1618:	09 f4       	brne	.+2      	; 0x161c <ReadPinVal+0x66>
    161a:	76 c0       	rjmp	.+236    	; 0x1708 <ReadPinVal+0x152>
    161c:	4c 81       	ldd	r20, Y+4	; 0x04
    161e:	5d 81       	ldd	r21, Y+5	; 0x05
    1620:	45 30       	cpi	r20, 0x05	; 5
    1622:	51 05       	cpc	r21, r1
    1624:	0c f4       	brge	.+2      	; 0x1628 <ReadPinVal+0x72>
    1626:	5b c0       	rjmp	.+182    	; 0x16de <ReadPinVal+0x128>
    1628:	8c 81       	ldd	r24, Y+4	; 0x04
    162a:	9d 81       	ldd	r25, Y+5	; 0x05
    162c:	86 30       	cpi	r24, 0x06	; 6
    162e:	91 05       	cpc	r25, r1
    1630:	09 f4       	brne	.+2      	; 0x1634 <ReadPinVal+0x7e>
    1632:	7f c0       	rjmp	.+254    	; 0x1732 <ReadPinVal+0x17c>
    1634:	93 c0       	rjmp	.+294    	; 0x175c <ReadPinVal+0x1a6>
	{
		case (0):
				return (GET_BIT(PINA,PinNumber%8));
    1636:	e9 e3       	ldi	r30, 0x39	; 57
    1638:	f0 e0       	ldi	r31, 0x00	; 0
    163a:	80 81       	ld	r24, Z
    163c:	28 2f       	mov	r18, r24
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	8a 81       	ldd	r24, Y+2	; 0x02
    1642:	88 2f       	mov	r24, r24
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	87 70       	andi	r24, 0x07	; 7
    1648:	90 70       	andi	r25, 0x00	; 0
    164a:	a9 01       	movw	r20, r18
    164c:	02 c0       	rjmp	.+4      	; 0x1652 <ReadPinVal+0x9c>
    164e:	55 95       	asr	r21
    1650:	47 95       	ror	r20
    1652:	8a 95       	dec	r24
    1654:	e2 f7       	brpl	.-8      	; 0x164e <ReadPinVal+0x98>
    1656:	ca 01       	movw	r24, r20
    1658:	58 2f       	mov	r21, r24
    165a:	51 70       	andi	r21, 0x01	; 1
    165c:	5b 83       	std	Y+3, r21	; 0x03
    165e:	7f c0       	rjmp	.+254    	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (1):
				return (GET_BIT(PINB,PinNumber%8));
    1660:	e6 e3       	ldi	r30, 0x36	; 54
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	80 81       	ld	r24, Z
    1666:	28 2f       	mov	r18, r24
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	8a 81       	ldd	r24, Y+2	; 0x02
    166c:	88 2f       	mov	r24, r24
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	87 70       	andi	r24, 0x07	; 7
    1672:	90 70       	andi	r25, 0x00	; 0
    1674:	a9 01       	movw	r20, r18
    1676:	02 c0       	rjmp	.+4      	; 0x167c <ReadPinVal+0xc6>
    1678:	55 95       	asr	r21
    167a:	47 95       	ror	r20
    167c:	8a 95       	dec	r24
    167e:	e2 f7       	brpl	.-8      	; 0x1678 <ReadPinVal+0xc2>
    1680:	ca 01       	movw	r24, r20
    1682:	58 2f       	mov	r21, r24
    1684:	51 70       	andi	r21, 0x01	; 1
    1686:	5b 83       	std	Y+3, r21	; 0x03
    1688:	6a c0       	rjmp	.+212    	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (2):
				return (GET_BIT(PINC,PinNumber%8));
    168a:	e3 e3       	ldi	r30, 0x33	; 51
    168c:	f0 e0       	ldi	r31, 0x00	; 0
    168e:	80 81       	ld	r24, Z
    1690:	28 2f       	mov	r18, r24
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	88 2f       	mov	r24, r24
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	87 70       	andi	r24, 0x07	; 7
    169c:	90 70       	andi	r25, 0x00	; 0
    169e:	a9 01       	movw	r20, r18
    16a0:	02 c0       	rjmp	.+4      	; 0x16a6 <ReadPinVal+0xf0>
    16a2:	55 95       	asr	r21
    16a4:	47 95       	ror	r20
    16a6:	8a 95       	dec	r24
    16a8:	e2 f7       	brpl	.-8      	; 0x16a2 <ReadPinVal+0xec>
    16aa:	ca 01       	movw	r24, r20
    16ac:	58 2f       	mov	r21, r24
    16ae:	51 70       	andi	r21, 0x01	; 1
    16b0:	5b 83       	std	Y+3, r21	; 0x03
    16b2:	55 c0       	rjmp	.+170    	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (3):
				return (GET_BIT(PIND,PinNumber%8));
    16b4:	e0 e3       	ldi	r30, 0x30	; 48
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	80 81       	ld	r24, Z
    16ba:	28 2f       	mov	r18, r24
    16bc:	30 e0       	ldi	r19, 0x00	; 0
    16be:	8a 81       	ldd	r24, Y+2	; 0x02
    16c0:	88 2f       	mov	r24, r24
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	87 70       	andi	r24, 0x07	; 7
    16c6:	90 70       	andi	r25, 0x00	; 0
    16c8:	a9 01       	movw	r20, r18
    16ca:	02 c0       	rjmp	.+4      	; 0x16d0 <ReadPinVal+0x11a>
    16cc:	55 95       	asr	r21
    16ce:	47 95       	ror	r20
    16d0:	8a 95       	dec	r24
    16d2:	e2 f7       	brpl	.-8      	; 0x16cc <ReadPinVal+0x116>
    16d4:	ca 01       	movw	r24, r20
    16d6:	58 2f       	mov	r21, r24
    16d8:	51 70       	andi	r21, 0x01	; 1
    16da:	5b 83       	std	Y+3, r21	; 0x03
    16dc:	40 c0       	rjmp	.+128    	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (4):
				return (GET_BIT(PINE,PinNumber%8));
    16de:	e3 e2       	ldi	r30, 0x23	; 35
    16e0:	f0 e0       	ldi	r31, 0x00	; 0
    16e2:	80 81       	ld	r24, Z
    16e4:	28 2f       	mov	r18, r24
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ea:	88 2f       	mov	r24, r24
    16ec:	90 e0       	ldi	r25, 0x00	; 0
    16ee:	87 70       	andi	r24, 0x07	; 7
    16f0:	90 70       	andi	r25, 0x00	; 0
    16f2:	a9 01       	movw	r20, r18
    16f4:	02 c0       	rjmp	.+4      	; 0x16fa <ReadPinVal+0x144>
    16f6:	55 95       	asr	r21
    16f8:	47 95       	ror	r20
    16fa:	8a 95       	dec	r24
    16fc:	e2 f7       	brpl	.-8      	; 0x16f6 <ReadPinVal+0x140>
    16fe:	ca 01       	movw	r24, r20
    1700:	58 2f       	mov	r21, r24
    1702:	51 70       	andi	r21, 0x01	; 1
    1704:	5b 83       	std	Y+3, r21	; 0x03
    1706:	2b c0       	rjmp	.+86     	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (5):
				return (GET_BIT(PINF,PinNumber%8));
    1708:	e0 e2       	ldi	r30, 0x20	; 32
    170a:	f0 e0       	ldi	r31, 0x00	; 0
    170c:	80 81       	ld	r24, Z
    170e:	28 2f       	mov	r18, r24
    1710:	30 e0       	ldi	r19, 0x00	; 0
    1712:	8a 81       	ldd	r24, Y+2	; 0x02
    1714:	88 2f       	mov	r24, r24
    1716:	90 e0       	ldi	r25, 0x00	; 0
    1718:	87 70       	andi	r24, 0x07	; 7
    171a:	90 70       	andi	r25, 0x00	; 0
    171c:	a9 01       	movw	r20, r18
    171e:	02 c0       	rjmp	.+4      	; 0x1724 <ReadPinVal+0x16e>
    1720:	55 95       	asr	r21
    1722:	47 95       	ror	r20
    1724:	8a 95       	dec	r24
    1726:	e2 f7       	brpl	.-8      	; 0x1720 <ReadPinVal+0x16a>
    1728:	ca 01       	movw	r24, r20
    172a:	58 2f       	mov	r21, r24
    172c:	51 70       	andi	r21, 0x01	; 1
    172e:	5b 83       	std	Y+3, r21	; 0x03
    1730:	16 c0       	rjmp	.+44     	; 0x175e <ReadPinVal+0x1a8>
				break;
		case (6):
				return (GET_BIT(PING,PinNumber%8));
    1732:	e3 e6       	ldi	r30, 0x63	; 99
    1734:	f0 e0       	ldi	r31, 0x00	; 0
    1736:	80 81       	ld	r24, Z
    1738:	28 2f       	mov	r18, r24
    173a:	30 e0       	ldi	r19, 0x00	; 0
    173c:	8a 81       	ldd	r24, Y+2	; 0x02
    173e:	88 2f       	mov	r24, r24
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	87 70       	andi	r24, 0x07	; 7
    1744:	90 70       	andi	r25, 0x00	; 0
    1746:	a9 01       	movw	r20, r18
    1748:	02 c0       	rjmp	.+4      	; 0x174e <ReadPinVal+0x198>
    174a:	55 95       	asr	r21
    174c:	47 95       	ror	r20
    174e:	8a 95       	dec	r24
    1750:	e2 f7       	brpl	.-8      	; 0x174a <ReadPinVal+0x194>
    1752:	ca 01       	movw	r24, r20
    1754:	58 2f       	mov	r21, r24
    1756:	51 70       	andi	r21, 0x01	; 1
    1758:	5b 83       	std	Y+3, r21	; 0x03
    175a:	01 c0       	rjmp	.+2      	; 0x175e <ReadPinVal+0x1a8>
    175c:	02 c0       	rjmp	.+4      	; 0x1762 <ReadPinVal+0x1ac>
				break;
	}

}
    175e:	8b 81       	ldd	r24, Y+3	; 0x03
    1760:	8e 83       	std	Y+6, r24	; 0x06
    1762:	8e 81       	ldd	r24, Y+6	; 0x06
    1764:	26 96       	adiw	r28, 0x06	; 6
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	de bf       	out	0x3e, r29	; 62
    176c:	0f be       	out	0x3f, r0	; 63
    176e:	cd bf       	out	0x3d, r28	; 61
    1770:	cf 91       	pop	r28
    1772:	df 91       	pop	r29
    1774:	08 95       	ret

00001776 <ARM_Motors>:

#include "PWM.h"
#include <avr/io.h>

void ARM_Motors(void)
{
    1776:	df 93       	push	r29
    1778:	cf 93       	push	r28
    177a:	00 d0       	rcall	.+0      	; 0x177c <ARM_Motors+0x6>
    177c:	cd b7       	in	r28, 0x3d	; 61
    177e:	de b7       	in	r29, 0x3e	; 62
	TCCR1A |= (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11) ;	//Clear output upon match. TOV on ICR TOP
    1780:	af e4       	ldi	r26, 0x4F	; 79
    1782:	b0 e0       	ldi	r27, 0x00	; 0
    1784:	ef e4       	ldi	r30, 0x4F	; 79
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	80 81       	ld	r24, Z
    178a:	82 6a       	ori	r24, 0xA2	; 162
    178c:	8c 93       	st	X, r24


	TCCR3A |= (1 << COM3A1) | (1 << COM3B1) | (1 << WGM31) | (1 << WGM30);	//Same as timer 1.
    178e:	ab e8       	ldi	r26, 0x8B	; 139
    1790:	b0 e0       	ldi	r27, 0x00	; 0
    1792:	eb e8       	ldi	r30, 0x8B	; 139
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	80 81       	ld	r24, Z
    1798:	83 6a       	ori	r24, 0xA3	; 163
    179a:	8c 93       	st	X, r24

	TCNT1H = 0x8E;
    179c:	ed e4       	ldi	r30, 0x4D	; 77
    179e:	f0 e0       	ldi	r31, 0x00	; 0
    17a0:	8e e8       	ldi	r24, 0x8E	; 142
    17a2:	80 83       	st	Z, r24
	TCNT1L = 0x0B;											//Set default value as explained in description.
    17a4:	ec e4       	ldi	r30, 0x4C	; 76
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	8b e0       	ldi	r24, 0x0B	; 11
    17aa:	80 83       	st	Z, r24


	TCNT3L = 0x8E;											//Set default value as explained in description.
    17ac:	e8 e8       	ldi	r30, 0x88	; 136
    17ae:	f0 e0       	ldi	r31, 0x00	; 0
    17b0:	8e e8       	ldi	r24, 0x8E	; 142
    17b2:	80 83       	st	Z, r24
	TCNT3H = 0x0B;
    17b4:	e9 e8       	ldi	r30, 0x89	; 137
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	8b e0       	ldi	r24, 0x0B	; 11
    17ba:	80 83       	st	Z, r24

	u16 start = 0.2*0.055*36363 + 0.055*36363 + (65535 - 36363);		//(20% ARMING) CHANGE THIS IN CASE OF NOT GOOD ARMING
    17bc:	83 e5       	ldi	r24, 0x53	; 83
    17be:	9b e7       	ldi	r25, 0x7B	; 123
    17c0:	9a 83       	std	Y+2, r25	; 0x02
    17c2:	89 83       	std	Y+1, r24	; 0x01
	 *	The ESC ranges from zero throttle to 100% throttle corresponding to 1 ms (no throttle) to:
	 *	2 ms (full throttle), therefore, to arm the motors at 20% we need a pulse width of 1.2 ms,
	 *	which corresponds to 740 + 15 + 3 = 758.
	 */

	OCR1AH = (start >> 8);
    17c4:	eb e4       	ldi	r30, 0x4B	; 75
    17c6:	f0 e0       	ldi	r31, 0x00	; 0
    17c8:	89 81       	ldd	r24, Y+1	; 0x01
    17ca:	9a 81       	ldd	r25, Y+2	; 0x02
    17cc:	89 2f       	mov	r24, r25
    17ce:	99 27       	eor	r25, r25
    17d0:	80 83       	st	Z, r24
	OCR1AL = start & 0xff;
    17d2:	ea e4       	ldi	r30, 0x4A	; 74
    17d4:	f0 e0       	ldi	r31, 0x00	; 0
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	80 83       	st	Z, r24

	OCR1BH = (start >> 8);
    17da:	e9 e4       	ldi	r30, 0x49	; 73
    17dc:	f0 e0       	ldi	r31, 0x00	; 0
    17de:	89 81       	ldd	r24, Y+1	; 0x01
    17e0:	9a 81       	ldd	r25, Y+2	; 0x02
    17e2:	89 2f       	mov	r24, r25
    17e4:	99 27       	eor	r25, r25
    17e6:	80 83       	st	Z, r24
	OCR1BL = start & 0xff;
    17e8:	e8 e4       	ldi	r30, 0x48	; 72
    17ea:	f0 e0       	ldi	r31, 0x00	; 0
    17ec:	89 81       	ldd	r24, Y+1	; 0x01
    17ee:	80 83       	st	Z, r24

	OCR3AH = (start >> 8);
    17f0:	e7 e8       	ldi	r30, 0x87	; 135
    17f2:	f0 e0       	ldi	r31, 0x00	; 0
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	89 2f       	mov	r24, r25
    17fa:	99 27       	eor	r25, r25
    17fc:	80 83       	st	Z, r24
	OCR3AL = start & 0xff;
    17fe:	e6 e8       	ldi	r30, 0x86	; 134
    1800:	f0 e0       	ldi	r31, 0x00	; 0
    1802:	89 81       	ldd	r24, Y+1	; 0x01
    1804:	80 83       	st	Z, r24

	OCR3BH = (start >> 8);
    1806:	e5 e8       	ldi	r30, 0x85	; 133
    1808:	f0 e0       	ldi	r31, 0x00	; 0
    180a:	89 81       	ldd	r24, Y+1	; 0x01
    180c:	9a 81       	ldd	r25, Y+2	; 0x02
    180e:	89 2f       	mov	r24, r25
    1810:	99 27       	eor	r25, r25
    1812:	80 83       	st	Z, r24
	OCR3BL = start & 0xff;
    1814:	e4 e8       	ldi	r30, 0x84	; 132
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	89 81       	ldd	r24, Y+1	; 0x01
    181a:	80 83       	st	Z, r24

	ICR1H = 0xff;
    181c:	e7 e4       	ldi	r30, 0x47	; 71
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	8f ef       	ldi	r24, 0xFF	; 255
    1822:	80 83       	st	Z, r24
	ICR1L = 0xff;
    1824:	e6 e4       	ldi	r30, 0x46	; 70
    1826:	f0 e0       	ldi	r31, 0x00	; 0
    1828:	8f ef       	ldi	r24, 0xFF	; 255
    182a:	80 83       	st	Z, r24

	TIMSK |= (1 << TOIE1);// | (1 << OCIE1A) | (1 << OCIE1B);
    182c:	a7 e5       	ldi	r26, 0x57	; 87
    182e:	b0 e0       	ldi	r27, 0x00	; 0
    1830:	e7 e5       	ldi	r30, 0x57	; 87
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	80 81       	ld	r24, Z
    1836:	84 60       	ori	r24, 0x04	; 4
    1838:	8c 93       	st	X, r24
	ETIMSK |= (1 << TOIE3);// | (1 << OCIE3A) | (1 << OCIE3B);
    183a:	ad e7       	ldi	r26, 0x7D	; 125
    183c:	b0 e0       	ldi	r27, 0x00	; 0
    183e:	ed e7       	ldi	r30, 0x7D	; 125
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	80 81       	ld	r24, Z
    1844:	84 60       	ori	r24, 0x04	; 4
    1846:	8c 93       	st	X, r24

	TCCR1B |= (1 << WGM12) | (1 << WGM13) | (1 << CS10) | (1 << CS12);		//Prescaler = 1024 and i deleted the shit out of wgm13
    1848:	ae e4       	ldi	r26, 0x4E	; 78
    184a:	b0 e0       	ldi	r27, 0x00	; 0
    184c:	ee e4       	ldi	r30, 0x4E	; 78
    184e:	f0 e0       	ldi	r31, 0x00	; 0
    1850:	80 81       	ld	r24, Z
    1852:	8d 61       	ori	r24, 0x1D	; 29
    1854:	8c 93       	st	X, r24
	TCCR3B |= (1 << CS31) | (1 << WGM32) | (1 << WGM33);					//Same as timer 1.
    1856:	aa e8       	ldi	r26, 0x8A	; 138
    1858:	b0 e0       	ldi	r27, 0x00	; 0
    185a:	ea e8       	ldi	r30, 0x8A	; 138
    185c:	f0 e0       	ldi	r31, 0x00	; 0
    185e:	80 81       	ld	r24, Z
    1860:	8a 61       	ori	r24, 0x1A	; 26
    1862:	8c 93       	st	X, r24
}
    1864:	0f 90       	pop	r0
    1866:	0f 90       	pop	r0
    1868:	cf 91       	pop	r28
    186a:	df 91       	pop	r29
    186c:	08 95       	ret

0000186e <ISR>:
ISR(TIMER1_OVF_vect)
	{
    186e:	df 93       	push	r29
    1870:	cf 93       	push	r28
    1872:	00 d0       	rcall	.+0      	; 0x1874 <ISR+0x6>
    1874:	00 d0       	rcall	.+0      	; 0x1876 <ISR+0x8>
    1876:	cd b7       	in	r28, 0x3d	; 61
    1878:	de b7       	in	r29, 0x3e	; 62
    187a:	9a 83       	std	Y+2, r25	; 0x02
    187c:	89 83       	std	Y+1, r24	; 0x01
		TCNT1H = 0x8E;
    187e:	ed e4       	ldi	r30, 0x4D	; 77
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	8e e8       	ldi	r24, 0x8E	; 142
    1884:	80 83       	st	Z, r24
		TCNT1L = 0x0B;
    1886:	ec e4       	ldi	r30, 0x4C	; 76
    1888:	f0 e0       	ldi	r31, 0x00	; 0
    188a:	8b e0       	ldi	r24, 0x0B	; 11
    188c:	80 83       	st	Z, r24
	}
    188e:	0f 90       	pop	r0
    1890:	0f 90       	pop	r0
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	cf 91       	pop	r28
    1898:	df 91       	pop	r29
    189a:	08 95       	ret

0000189c <PWM>:
	 * 												3    4
	 *
	 */

void PWM(u8 dutyCycle, u8 motorNumber)					//dutyCycle is a percentage of how much force is needed of max
{
    189c:	df 93       	push	r29
    189e:	cf 93       	push	r28
    18a0:	00 d0       	rcall	.+0      	; 0x18a2 <PWM+0x6>
    18a2:	00 d0       	rcall	.+0      	; 0x18a4 <PWM+0x8>
    18a4:	00 d0       	rcall	.+0      	; 0x18a6 <PWM+0xa>
    18a6:	cd b7       	in	r28, 0x3d	; 61
    18a8:	de b7       	in	r29, 0x3e	; 62
    18aa:	8b 83       	std	Y+3, r24	; 0x03
    18ac:	6c 83       	std	Y+4, r22	; 0x04
	u16 temp = 36363 + (dutyCycle/100) * 2000 + 2000;			//First get the value needed then split to LOW and HIGH
    18ae:	8b 81       	ldd	r24, Y+3	; 0x03
    18b0:	94 e6       	ldi	r25, 0x64	; 100
    18b2:	69 2f       	mov	r22, r25
    18b4:	0e 94 f6 23 	call	0x47ec	; 0x47ec <__udivmodqi4>
    18b8:	28 2f       	mov	r18, r24
    18ba:	30 e0       	ldi	r19, 0x00	; 0
    18bc:	80 ed       	ldi	r24, 0xD0	; 208
    18be:	97 e0       	ldi	r25, 0x07	; 7
    18c0:	ac 01       	movw	r20, r24
    18c2:	24 9f       	mul	r18, r20
    18c4:	c0 01       	movw	r24, r0
    18c6:	25 9f       	mul	r18, r21
    18c8:	90 0d       	add	r25, r0
    18ca:	34 9f       	mul	r19, r20
    18cc:	90 0d       	add	r25, r0
    18ce:	11 24       	eor	r1, r1
    18d0:	85 52       	subi	r24, 0x25	; 37
    18d2:	9a 46       	sbci	r25, 0x6A	; 106
    18d4:	9a 83       	std	Y+2, r25	; 0x02
    18d6:	89 83       	std	Y+1, r24	; 0x01
	//u16 temp =  (dutyCycle/100.0) * (65535);

	switch(motorNumber)
    18d8:	8c 81       	ldd	r24, Y+4	; 0x04
    18da:	28 2f       	mov	r18, r24
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	3e 83       	std	Y+6, r19	; 0x06
    18e0:	2d 83       	std	Y+5, r18	; 0x05
    18e2:	4d 81       	ldd	r20, Y+5	; 0x05
    18e4:	5e 81       	ldd	r21, Y+6	; 0x06
    18e6:	42 30       	cpi	r20, 0x02	; 2
    18e8:	51 05       	cpc	r21, r1
    18ea:	11 f1       	breq	.+68     	; 0x1930 <PWM+0x94>
    18ec:	8d 81       	ldd	r24, Y+5	; 0x05
    18ee:	9e 81       	ldd	r25, Y+6	; 0x06
    18f0:	83 30       	cpi	r24, 0x03	; 3
    18f2:	91 05       	cpc	r25, r1
    18f4:	34 f4       	brge	.+12     	; 0x1902 <PWM+0x66>
    18f6:	2d 81       	ldd	r18, Y+5	; 0x05
    18f8:	3e 81       	ldd	r19, Y+6	; 0x06
    18fa:	21 30       	cpi	r18, 0x01	; 1
    18fc:	31 05       	cpc	r19, r1
    18fe:	61 f0       	breq	.+24     	; 0x1918 <PWM+0x7c>
    1900:	3b c0       	rjmp	.+118    	; 0x1978 <PWM+0xdc>
    1902:	4d 81       	ldd	r20, Y+5	; 0x05
    1904:	5e 81       	ldd	r21, Y+6	; 0x06
    1906:	43 30       	cpi	r20, 0x03	; 3
    1908:	51 05       	cpc	r21, r1
    190a:	f1 f0       	breq	.+60     	; 0x1948 <PWM+0xac>
    190c:	8d 81       	ldd	r24, Y+5	; 0x05
    190e:	9e 81       	ldd	r25, Y+6	; 0x06
    1910:	84 30       	cpi	r24, 0x04	; 4
    1912:	91 05       	cpc	r25, r1
    1914:	29 f1       	breq	.+74     	; 0x1960 <PWM+0xc4>
    1916:	30 c0       	rjmp	.+96     	; 0x1978 <PWM+0xdc>
	{
	case 1:

		OCR1AH = (temp >> 8);
    1918:	eb e4       	ldi	r30, 0x4B	; 75
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	9a 81       	ldd	r25, Y+2	; 0x02
    1920:	89 2f       	mov	r24, r25
    1922:	99 27       	eor	r25, r25
    1924:	80 83       	st	Z, r24
		OCR1AL = temp & 0xff;
    1926:	ea e4       	ldi	r30, 0x4A	; 74
    1928:	f0 e0       	ldi	r31, 0x00	; 0
    192a:	89 81       	ldd	r24, Y+1	; 0x01
    192c:	80 83       	st	Z, r24
    192e:	65 c0       	rjmp	.+202    	; 0x19fa <PWM+0x15e>
		break;
	case 2:

		OCR1BH = (temp >> 8);
    1930:	e9 e4       	ldi	r30, 0x49	; 73
    1932:	f0 e0       	ldi	r31, 0x00	; 0
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	9a 81       	ldd	r25, Y+2	; 0x02
    1938:	89 2f       	mov	r24, r25
    193a:	99 27       	eor	r25, r25
    193c:	80 83       	st	Z, r24
		OCR1BL = temp & 0xff;
    193e:	e8 e4       	ldi	r30, 0x48	; 72
    1940:	f0 e0       	ldi	r31, 0x00	; 0
    1942:	89 81       	ldd	r24, Y+1	; 0x01
    1944:	80 83       	st	Z, r24
    1946:	59 c0       	rjmp	.+178    	; 0x19fa <PWM+0x15e>
		break;
	case 3:
		OCR3AH = (temp >> 8);
    1948:	e7 e8       	ldi	r30, 0x87	; 135
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	9a 81       	ldd	r25, Y+2	; 0x02
    1950:	89 2f       	mov	r24, r25
    1952:	99 27       	eor	r25, r25
    1954:	80 83       	st	Z, r24
		OCR3AL = temp & 0xff;
    1956:	e6 e8       	ldi	r30, 0x86	; 134
    1958:	f0 e0       	ldi	r31, 0x00	; 0
    195a:	89 81       	ldd	r24, Y+1	; 0x01
    195c:	80 83       	st	Z, r24
    195e:	4d c0       	rjmp	.+154    	; 0x19fa <PWM+0x15e>
		break;
	case 4:

		OCR3BH = (temp >> 8);
    1960:	e5 e8       	ldi	r30, 0x85	; 133
    1962:	f0 e0       	ldi	r31, 0x00	; 0
    1964:	89 81       	ldd	r24, Y+1	; 0x01
    1966:	9a 81       	ldd	r25, Y+2	; 0x02
    1968:	89 2f       	mov	r24, r25
    196a:	99 27       	eor	r25, r25
    196c:	80 83       	st	Z, r24
		OCR3BL = temp & 0xff;
    196e:	e4 e8       	ldi	r30, 0x84	; 132
    1970:	f0 e0       	ldi	r31, 0x00	; 0
    1972:	89 81       	ldd	r24, Y+1	; 0x01
    1974:	80 83       	st	Z, r24
    1976:	41 c0       	rjmp	.+130    	; 0x19fa <PWM+0x15e>
		break;
	default:
		temp = 36363 + (dutyCycle/100) * 2000 + 2000;
    1978:	8b 81       	ldd	r24, Y+3	; 0x03
    197a:	94 e6       	ldi	r25, 0x64	; 100
    197c:	69 2f       	mov	r22, r25
    197e:	0e 94 f6 23 	call	0x47ec	; 0x47ec <__udivmodqi4>
    1982:	28 2f       	mov	r18, r24
    1984:	30 e0       	ldi	r19, 0x00	; 0
    1986:	80 ed       	ldi	r24, 0xD0	; 208
    1988:	97 e0       	ldi	r25, 0x07	; 7
    198a:	ac 01       	movw	r20, r24
    198c:	24 9f       	mul	r18, r20
    198e:	c0 01       	movw	r24, r0
    1990:	25 9f       	mul	r18, r21
    1992:	90 0d       	add	r25, r0
    1994:	34 9f       	mul	r19, r20
    1996:	90 0d       	add	r25, r0
    1998:	11 24       	eor	r1, r1
    199a:	85 52       	subi	r24, 0x25	; 37
    199c:	9a 46       	sbci	r25, 0x6A	; 106
    199e:	9a 83       	std	Y+2, r25	; 0x02
    19a0:	89 83       	std	Y+1, r24	; 0x01
		OCR1AH = (temp >> 8);
    19a2:	eb e4       	ldi	r30, 0x4B	; 75
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	89 81       	ldd	r24, Y+1	; 0x01
    19a8:	9a 81       	ldd	r25, Y+2	; 0x02
    19aa:	89 2f       	mov	r24, r25
    19ac:	99 27       	eor	r25, r25
    19ae:	80 83       	st	Z, r24
		OCR1AL = temp & 0xff;
    19b0:	ea e4       	ldi	r30, 0x4A	; 74
    19b2:	f0 e0       	ldi	r31, 0x00	; 0
    19b4:	89 81       	ldd	r24, Y+1	; 0x01
    19b6:	80 83       	st	Z, r24

		OCR1BH = (temp >> 8);
    19b8:	e9 e4       	ldi	r30, 0x49	; 73
    19ba:	f0 e0       	ldi	r31, 0x00	; 0
    19bc:	89 81       	ldd	r24, Y+1	; 0x01
    19be:	9a 81       	ldd	r25, Y+2	; 0x02
    19c0:	89 2f       	mov	r24, r25
    19c2:	99 27       	eor	r25, r25
    19c4:	80 83       	st	Z, r24
		OCR1BL = temp & 0xff;
    19c6:	e8 e4       	ldi	r30, 0x48	; 72
    19c8:	f0 e0       	ldi	r31, 0x00	; 0
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	80 83       	st	Z, r24

		OCR3AH = (temp >> 8);
    19ce:	e7 e8       	ldi	r30, 0x87	; 135
    19d0:	f0 e0       	ldi	r31, 0x00	; 0
    19d2:	89 81       	ldd	r24, Y+1	; 0x01
    19d4:	9a 81       	ldd	r25, Y+2	; 0x02
    19d6:	89 2f       	mov	r24, r25
    19d8:	99 27       	eor	r25, r25
    19da:	80 83       	st	Z, r24
		OCR3AL = temp & 0xff;
    19dc:	e6 e8       	ldi	r30, 0x86	; 134
    19de:	f0 e0       	ldi	r31, 0x00	; 0
    19e0:	89 81       	ldd	r24, Y+1	; 0x01
    19e2:	80 83       	st	Z, r24

		OCR3BH = (temp >> 8);
    19e4:	e5 e8       	ldi	r30, 0x85	; 133
    19e6:	f0 e0       	ldi	r31, 0x00	; 0
    19e8:	89 81       	ldd	r24, Y+1	; 0x01
    19ea:	9a 81       	ldd	r25, Y+2	; 0x02
    19ec:	89 2f       	mov	r24, r25
    19ee:	99 27       	eor	r25, r25
    19f0:	80 83       	st	Z, r24
		OCR3BL = temp & 0xff;
    19f2:	e4 e8       	ldi	r30, 0x84	; 132
    19f4:	f0 e0       	ldi	r31, 0x00	; 0
    19f6:	89 81       	ldd	r24, Y+1	; 0x01
    19f8:	80 83       	st	Z, r24

	}



}
    19fa:	26 96       	adiw	r28, 0x06	; 6
    19fc:	0f b6       	in	r0, 0x3f	; 63
    19fe:	f8 94       	cli
    1a00:	de bf       	out	0x3e, r29	; 62
    1a02:	0f be       	out	0x3f, r0	; 63
    1a04:	cd bf       	out	0x3d, r28	; 61
    1a06:	cf 91       	pop	r28
    1a08:	df 91       	pop	r29
    1a0a:	08 95       	ret

00001a0c <DISARM_Motors>:

/* Disabling all timers*/
void DISARM_Motors(void)
{
    1a0c:	df 93       	push	r29
    1a0e:	cf 93       	push	r28
    1a10:	cd b7       	in	r28, 0x3d	; 61
    1a12:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = 0;
    1a14:	ef e4       	ldi	r30, 0x4F	; 79
    1a16:	f0 e0       	ldi	r31, 0x00	; 0
    1a18:	10 82       	st	Z, r1
	TCCR1B = 0;
    1a1a:	ee e4       	ldi	r30, 0x4E	; 78
    1a1c:	f0 e0       	ldi	r31, 0x00	; 0
    1a1e:	10 82       	st	Z, r1
	TCCR3A = 0;
    1a20:	eb e8       	ldi	r30, 0x8B	; 139
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	10 82       	st	Z, r1
	TCCR3B = 0;
    1a26:	ea e8       	ldi	r30, 0x8A	; 138
    1a28:	f0 e0       	ldi	r31, 0x00	; 0
    1a2a:	10 82       	st	Z, r1
	TCNT1 = 0;
    1a2c:	ec e4       	ldi	r30, 0x4C	; 76
    1a2e:	f0 e0       	ldi	r31, 0x00	; 0
    1a30:	11 82       	std	Z+1, r1	; 0x01
    1a32:	10 82       	st	Z, r1
	TCNT3 = 0;
    1a34:	e8 e8       	ldi	r30, 0x88	; 136
    1a36:	f0 e0       	ldi	r31, 0x00	; 0
    1a38:	11 82       	std	Z+1, r1	; 0x01
    1a3a:	10 82       	st	Z, r1
	OCR1A = 0;
    1a3c:	ea e4       	ldi	r30, 0x4A	; 74
    1a3e:	f0 e0       	ldi	r31, 0x00	; 0
    1a40:	11 82       	std	Z+1, r1	; 0x01
    1a42:	10 82       	st	Z, r1
	OCR1B = 0;
    1a44:	e8 e4       	ldi	r30, 0x48	; 72
    1a46:	f0 e0       	ldi	r31, 0x00	; 0
    1a48:	11 82       	std	Z+1, r1	; 0x01
    1a4a:	10 82       	st	Z, r1
	OCR3A = 0;
    1a4c:	e6 e8       	ldi	r30, 0x86	; 134
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	11 82       	std	Z+1, r1	; 0x01
    1a52:	10 82       	st	Z, r1
	OCR3B = 0;
    1a54:	e4 e8       	ldi	r30, 0x84	; 132
    1a56:	f0 e0       	ldi	r31, 0x00	; 0
    1a58:	11 82       	std	Z+1, r1	; 0x01
    1a5a:	10 82       	st	Z, r1
	TIMSK = 0;
    1a5c:	e7 e5       	ldi	r30, 0x57	; 87
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	10 82       	st	Z, r1
	ETIMSK = 0;
    1a62:	ed e7       	ldi	r30, 0x7D	; 125
    1a64:	f0 e0       	ldi	r31, 0x00	; 0
    1a66:	10 82       	st	Z, r1
}
    1a68:	cf 91       	pop	r28
    1a6a:	df 91       	pop	r29
    1a6c:	08 95       	ret

00001a6e <UART0_init>:
 * UART_sendString(" ... #") NOTE : you must send '#' at the end of the string
 * UART_receiveString()
 *
 */
void UART0_init()
{
    1a6e:	df 93       	push	r29
    1a70:	cf 93       	push	r28
    1a72:	cd b7       	in	r28, 0x3d	; 61
    1a74:	de b7       	in	r29, 0x3e	; 62
	//UCSR0A=(1<<U2X);											// double speed mode

	UCSR0B	=	0b00011000;									//sender and receiver
    1a76:	e1 ec       	ldi	r30, 0xC1	; 193
    1a78:	f0 e0       	ldi	r31, 0x00	; 0
    1a7a:	88 e1       	ldi	r24, 0x18	; 24
    1a7c:	80 83       	st	Z, r24
	UCSR0C	= 	0b10000110;							//no parity check and send 8 bits
    1a7e:	e2 ec       	ldi	r30, 0xC2	; 194
    1a80:	f0 e0       	ldi	r31, 0x00	; 0
    1a82:	86 e8       	ldi	r24, 0x86	; 134
    1a84:	80 83       	st	Z, r24

	UBRR0L=103;
    1a86:	e4 ec       	ldi	r30, 0xC4	; 196
    1a88:	f0 e0       	ldi	r31, 0x00	; 0
    1a8a:	87 e6       	ldi	r24, 0x67	; 103
    1a8c:	80 83       	st	Z, r24

}
    1a8e:	cf 91       	pop	r28
    1a90:	df 91       	pop	r29
    1a92:	08 95       	ret

00001a94 <UART1_init>:

void UART1_init()
{
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
	//UCSR1A=(1<<U2X);											// double speed mode
	UCSR1B	=	0b00011000;										//sender and receiver
    1a9c:	e9 ec       	ldi	r30, 0xC9	; 201
    1a9e:	f0 e0       	ldi	r31, 0x00	; 0
    1aa0:	88 e1       	ldi	r24, 0x18	; 24
    1aa2:	80 83       	st	Z, r24
	UCSR1C	= 	0b10000110;							//no parity check and send 8 bits
    1aa4:	ea ec       	ldi	r30, 0xCA	; 202
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	86 e8       	ldi	r24, 0x86	; 134
    1aaa:	80 83       	st	Z, r24
	//UBRR1H=BAUD_PRESCALE<<8; 								//baud rate 9600
	UBRR1L	=	103;
    1aac:	ec ec       	ldi	r30, 0xCC	; 204
    1aae:	f0 e0       	ldi	r31, 0x00	; 0
    1ab0:	87 e6       	ldi	r24, 0x67	; 103
    1ab2:	80 83       	st	Z, r24

}
    1ab4:	cf 91       	pop	r28
    1ab6:	df 91       	pop	r29
    1ab8:	08 95       	ret

00001aba <UART2_init>:


void UART2_init()
{
    1aba:	df 93       	push	r29
    1abc:	cf 93       	push	r28
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
	//UCSR2A	=	(1<<U2X);											// double speed mode
	UCSR2B	= 	0b00011000;									//sender and receiver
    1ac2:	e1 ed       	ldi	r30, 0xD1	; 209
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	88 e1       	ldi	r24, 0x18	; 24
    1ac8:	80 83       	st	Z, r24
	UCSR2C	=	0b10000110;							//no parity check and send 8 bits
    1aca:	e2 ed       	ldi	r30, 0xD2	; 210
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	86 e8       	ldi	r24, 0x86	; 134
    1ad0:	80 83       	st	Z, r24
	//UBRR2H=BAUD_PRESCALE<<8; 								//baud rate 9600
	UBRR2L=103;
    1ad2:	e4 ed       	ldi	r30, 0xD4	; 212
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	87 e6       	ldi	r24, 0x67	; 103
    1ad8:	80 83       	st	Z, r24
}
    1ada:	cf 91       	pop	r28
    1adc:	df 91       	pop	r29
    1ade:	08 95       	ret

00001ae0 <UART0_sendByte>:



/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */
void UART0_sendByte (u8 data)
{
    1ae0:	df 93       	push	r29
    1ae2:	cf 93       	push	r28
    1ae4:	0f 92       	push	r0
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	89 83       	std	Y+1, r24	; 0x01
	UDR0=data;
    1aec:	e6 ec       	ldi	r30, 0xC6	; 198
    1aee:	f0 e0       	ldi	r31, 0x00	; 0
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	80 83       	st	Z, r24
	while (!GET_BIT(UCSR0A,5)){}
    1af4:	e0 ec       	ldi	r30, 0xC0	; 192
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	80 81       	ld	r24, Z
    1afa:	82 95       	swap	r24
    1afc:	86 95       	lsr	r24
    1afe:	87 70       	andi	r24, 0x07	; 7
    1b00:	88 2f       	mov	r24, r24
    1b02:	90 e0       	ldi	r25, 0x00	; 0
    1b04:	81 70       	andi	r24, 0x01	; 1
    1b06:	90 70       	andi	r25, 0x00	; 0
    1b08:	00 97       	sbiw	r24, 0x00	; 0
    1b0a:	a1 f3       	breq	.-24     	; 0x1af4 <UART0_sendByte+0x14>
	SET_BIT(UCSR0A,TXC);
    1b0c:	a0 ec       	ldi	r26, 0xC0	; 192
    1b0e:	b0 e0       	ldi	r27, 0x00	; 0
    1b10:	e0 ec       	ldi	r30, 0xC0	; 192
    1b12:	f0 e0       	ldi	r31, 0x00	; 0
    1b14:	80 81       	ld	r24, Z
    1b16:	80 64       	ori	r24, 0x40	; 64
    1b18:	8c 93       	st	X, r24

}
    1b1a:	0f 90       	pop	r0
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <UART0_receiveByte>:
/* this fun receive a byte and waits until the data is empty to avoid overwriting */
u8 UART0_receiveByte (void)
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	cd b7       	in	r28, 0x3d	; 61
    1b28:	de b7       	in	r29, 0x3e	; 62
	while (!GET_BIT(UCSR0A,7)){}
    1b2a:	e0 ec       	ldi	r30, 0xC0	; 192
    1b2c:	f0 e0       	ldi	r31, 0x00	; 0
    1b2e:	80 81       	ld	r24, Z
    1b30:	88 23       	and	r24, r24
    1b32:	dc f7       	brge	.-10     	; 0x1b2a <UART0_receiveByte+0x8>
	/*
	 * wait until the last byte is received
	 */
	return UDR0;
    1b34:	e6 ec       	ldi	r30, 0xC6	; 198
    1b36:	f0 e0       	ldi	r31, 0x00	; 0
    1b38:	80 81       	ld	r24, Z
}
    1b3a:	cf 91       	pop	r28
    1b3c:	df 91       	pop	r29
    1b3e:	08 95       	ret

00001b40 <UART1_sendByte>:

/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */
void UART1_sendByte (u8 data)
{
    1b40:	df 93       	push	r29
    1b42:	cf 93       	push	r28
    1b44:	0f 92       	push	r0
    1b46:	cd b7       	in	r28, 0x3d	; 61
    1b48:	de b7       	in	r29, 0x3e	; 62
    1b4a:	89 83       	std	Y+1, r24	; 0x01
	UDR1=data;
    1b4c:	ee ec       	ldi	r30, 0xCE	; 206
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	80 83       	st	Z, r24
	while (!GET_BIT(UCSR1A,5)){}
    1b54:	e8 ec       	ldi	r30, 0xC8	; 200
    1b56:	f0 e0       	ldi	r31, 0x00	; 0
    1b58:	80 81       	ld	r24, Z
    1b5a:	82 95       	swap	r24
    1b5c:	86 95       	lsr	r24
    1b5e:	87 70       	andi	r24, 0x07	; 7
    1b60:	88 2f       	mov	r24, r24
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	81 70       	andi	r24, 0x01	; 1
    1b66:	90 70       	andi	r25, 0x00	; 0
    1b68:	00 97       	sbiw	r24, 0x00	; 0
    1b6a:	a1 f3       	breq	.-24     	; 0x1b54 <UART1_sendByte+0x14>
	SET_BIT(UCSR1A,TXC);
    1b6c:	a8 ec       	ldi	r26, 0xC8	; 200
    1b6e:	b0 e0       	ldi	r27, 0x00	; 0
    1b70:	e8 ec       	ldi	r30, 0xC8	; 200
    1b72:	f0 e0       	ldi	r31, 0x00	; 0
    1b74:	80 81       	ld	r24, Z
    1b76:	80 64       	ori	r24, 0x40	; 64
    1b78:	8c 93       	st	X, r24

}
    1b7a:	0f 90       	pop	r0
    1b7c:	cf 91       	pop	r28
    1b7e:	df 91       	pop	r29
    1b80:	08 95       	ret

00001b82 <UART1_receiveByte>:
/* this fun receive a byte and waits untill the data is empty to avoid overwriting */
u8 UART1_receiveByte (void)
{
    1b82:	df 93       	push	r29
    1b84:	cf 93       	push	r28
    1b86:	cd b7       	in	r28, 0x3d	; 61
    1b88:	de b7       	in	r29, 0x3e	; 62
	while (!GET_BIT(UCSR1A,7)){}
    1b8a:	e8 ec       	ldi	r30, 0xC8	; 200
    1b8c:	f0 e0       	ldi	r31, 0x00	; 0
    1b8e:	80 81       	ld	r24, Z
    1b90:	88 23       	and	r24, r24
    1b92:	dc f7       	brge	.-10     	; 0x1b8a <UART1_receiveByte+0x8>
	/*
	 * wait until the last byte is received
	 */
	return UDR1;
    1b94:	ee ec       	ldi	r30, 0xCE	; 206
    1b96:	f0 e0       	ldi	r31, 0x00	; 0
    1b98:	80 81       	ld	r24, Z
}
    1b9a:	cf 91       	pop	r28
    1b9c:	df 91       	pop	r29
    1b9e:	08 95       	ret

00001ba0 <UART2_sendByte>:


/* this fun sends a byte and waits till the U DATA is sent then send another byte  to avoid overwriting  */
void UART2_sendByte (u8 data)
{
    1ba0:	df 93       	push	r29
    1ba2:	cf 93       	push	r28
    1ba4:	0f 92       	push	r0
    1ba6:	cd b7       	in	r28, 0x3d	; 61
    1ba8:	de b7       	in	r29, 0x3e	; 62
    1baa:	89 83       	std	Y+1, r24	; 0x01
	UDR2=data;
    1bac:	e6 ed       	ldi	r30, 0xD6	; 214
    1bae:	f0 e0       	ldi	r31, 0x00	; 0
    1bb0:	89 81       	ldd	r24, Y+1	; 0x01
    1bb2:	80 83       	st	Z, r24
	while (!GET_BIT(UCSR2A,5)){}
    1bb4:	e0 ed       	ldi	r30, 0xD0	; 208
    1bb6:	f0 e0       	ldi	r31, 0x00	; 0
    1bb8:	80 81       	ld	r24, Z
    1bba:	82 95       	swap	r24
    1bbc:	86 95       	lsr	r24
    1bbe:	87 70       	andi	r24, 0x07	; 7
    1bc0:	88 2f       	mov	r24, r24
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	81 70       	andi	r24, 0x01	; 1
    1bc6:	90 70       	andi	r25, 0x00	; 0
    1bc8:	00 97       	sbiw	r24, 0x00	; 0
    1bca:	a1 f3       	breq	.-24     	; 0x1bb4 <UART2_sendByte+0x14>
	SET_BIT(UCSR2A,TXC);
    1bcc:	a0 ed       	ldi	r26, 0xD0	; 208
    1bce:	b0 e0       	ldi	r27, 0x00	; 0
    1bd0:	e0 ed       	ldi	r30, 0xD0	; 208
    1bd2:	f0 e0       	ldi	r31, 0x00	; 0
    1bd4:	80 81       	ld	r24, Z
    1bd6:	80 64       	ori	r24, 0x40	; 64
    1bd8:	8c 93       	st	X, r24

}
    1bda:	0f 90       	pop	r0
    1bdc:	cf 91       	pop	r28
    1bde:	df 91       	pop	r29
    1be0:	08 95       	ret

00001be2 <UART2_receiveByte>:
/* this fun receive a byte and waits untill the data is empty to avoid overwriting */
u8 UART2_receiveByte (void)
{
    1be2:	df 93       	push	r29
    1be4:	cf 93       	push	r28
    1be6:	cd b7       	in	r28, 0x3d	; 61
    1be8:	de b7       	in	r29, 0x3e	; 62
	while (!GET_BIT(UCSR2A,7)){}
    1bea:	e0 ed       	ldi	r30, 0xD0	; 208
    1bec:	f0 e0       	ldi	r31, 0x00	; 0
    1bee:	80 81       	ld	r24, Z
    1bf0:	88 23       	and	r24, r24
    1bf2:	dc f7       	brge	.-10     	; 0x1bea <UART2_receiveByte+0x8>
	/*
	 * wait until the last byte is received
	 */
	return UDR2;
    1bf4:	e6 ed       	ldi	r30, 0xD6	; 214
    1bf6:	f0 e0       	ldi	r31, 0x00	; 0
    1bf8:	80 81       	ld	r24, Z
}
    1bfa:	cf 91       	pop	r28
    1bfc:	df 91       	pop	r29
    1bfe:	08 95       	ret

00001c00 <UART0_sendString>:



void UART0_sendString (const u8 *str)
{
    1c00:	df 93       	push	r29
    1c02:	cf 93       	push	r28
    1c04:	00 d0       	rcall	.+0      	; 0x1c06 <UART0_sendString+0x6>
    1c06:	cd b7       	in	r28, 0x3d	; 61
    1c08:	de b7       	in	r29, 0x3e	; 62
    1c0a:	9a 83       	std	Y+2, r25	; 0x02
    1c0c:	89 83       	std	Y+1, r24	; 0x01
    1c0e:	0a c0       	rjmp	.+20     	; 0x1c24 <UART0_sendString+0x24>
	while (*str != '\0')
	{
		UART0_sendByte(*str);
    1c10:	e9 81       	ldd	r30, Y+1	; 0x01
    1c12:	fa 81       	ldd	r31, Y+2	; 0x02
    1c14:	80 81       	ld	r24, Z
    1c16:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <UART0_sendByte>
		str++;
    1c1a:	89 81       	ldd	r24, Y+1	; 0x01
    1c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1e:	01 96       	adiw	r24, 0x01	; 1
    1c20:	9a 83       	std	Y+2, r25	; 0x02
    1c22:	89 83       	std	Y+1, r24	; 0x01



void UART0_sendString (const u8 *str)
{
	while (*str != '\0')
    1c24:	e9 81       	ldd	r30, Y+1	; 0x01
    1c26:	fa 81       	ldd	r31, Y+2	; 0x02
    1c28:	80 81       	ld	r24, Z
    1c2a:	88 23       	and	r24, r24
    1c2c:	89 f7       	brne	.-30     	; 0x1c10 <UART0_sendString+0x10>
	{
		UART0_sendByte(*str);
		str++;
	}
}
    1c2e:	0f 90       	pop	r0
    1c30:	0f 90       	pop	r0
    1c32:	cf 91       	pop	r28
    1c34:	df 91       	pop	r29
    1c36:	08 95       	ret

00001c38 <UART0_receiveString>:


void UART0_receiveString (u8 *str)
{
    1c38:	df 93       	push	r29
    1c3a:	cf 93       	push	r28
    1c3c:	00 d0       	rcall	.+0      	; 0x1c3e <UART0_receiveString+0x6>
    1c3e:	cd b7       	in	r28, 0x3d	; 61
    1c40:	de b7       	in	r29, 0x3e	; 62
    1c42:	9a 83       	std	Y+2, r25	; 0x02
    1c44:	89 83       	std	Y+1, r24	; 0x01
	*str=UART0_receiveByte();
    1c46:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <UART0_receiveByte>
    1c4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c4e:	80 83       	st	Z, r24
    1c50:	0a c0       	rjmp	.+20     	; 0x1c66 <UART0_receiveString+0x2e>
	while (*str != '#')
	{
		str++;
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	9a 81       	ldd	r25, Y+2	; 0x02
    1c56:	01 96       	adiw	r24, 0x01	; 1
    1c58:	9a 83       	std	Y+2, r25	; 0x02
    1c5a:	89 83       	std	Y+1, r24	; 0x01
		*str=UART0_receiveByte();
    1c5c:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <UART0_receiveByte>
    1c60:	e9 81       	ldd	r30, Y+1	; 0x01
    1c62:	fa 81       	ldd	r31, Y+2	; 0x02
    1c64:	80 83       	st	Z, r24


void UART0_receiveString (u8 *str)
{
	*str=UART0_receiveByte();
	while (*str != '#')
    1c66:	e9 81       	ldd	r30, Y+1	; 0x01
    1c68:	fa 81       	ldd	r31, Y+2	; 0x02
    1c6a:	80 81       	ld	r24, Z
    1c6c:	83 32       	cpi	r24, 0x23	; 35
    1c6e:	89 f7       	brne	.-30     	; 0x1c52 <UART0_receiveString+0x1a>
	{
		str++;
		*str=UART0_receiveByte();

	}
	*str='\0';
    1c70:	e9 81       	ldd	r30, Y+1	; 0x01
    1c72:	fa 81       	ldd	r31, Y+2	; 0x02
    1c74:	10 82       	st	Z, r1

}
    1c76:	0f 90       	pop	r0
    1c78:	0f 90       	pop	r0
    1c7a:	cf 91       	pop	r28
    1c7c:	df 91       	pop	r29
    1c7e:	08 95       	ret

00001c80 <UART1_sendString>:


void UART1_sendString (const u8 *str)
{
    1c80:	df 93       	push	r29
    1c82:	cf 93       	push	r28
    1c84:	00 d0       	rcall	.+0      	; 0x1c86 <UART1_sendString+0x6>
    1c86:	cd b7       	in	r28, 0x3d	; 61
    1c88:	de b7       	in	r29, 0x3e	; 62
    1c8a:	9a 83       	std	Y+2, r25	; 0x02
    1c8c:	89 83       	std	Y+1, r24	; 0x01
    1c8e:	0a c0       	rjmp	.+20     	; 0x1ca4 <UART1_sendString+0x24>
	while (*str != '\0')
	{
		UART1_sendByte(*str);
    1c90:	e9 81       	ldd	r30, Y+1	; 0x01
    1c92:	fa 81       	ldd	r31, Y+2	; 0x02
    1c94:	80 81       	ld	r24, Z
    1c96:	0e 94 a0 0d 	call	0x1b40	; 0x1b40 <UART1_sendByte>
		str++;
    1c9a:	89 81       	ldd	r24, Y+1	; 0x01
    1c9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c9e:	01 96       	adiw	r24, 0x01	; 1
    1ca0:	9a 83       	std	Y+2, r25	; 0x02
    1ca2:	89 83       	std	Y+1, r24	; 0x01
}


void UART1_sendString (const u8 *str)
{
	while (*str != '\0')
    1ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca8:	80 81       	ld	r24, Z
    1caa:	88 23       	and	r24, r24
    1cac:	89 f7       	brne	.-30     	; 0x1c90 <UART1_sendString+0x10>
	{
		UART1_sendByte(*str);
		str++;
	}
}
    1cae:	0f 90       	pop	r0
    1cb0:	0f 90       	pop	r0
    1cb2:	cf 91       	pop	r28
    1cb4:	df 91       	pop	r29
    1cb6:	08 95       	ret

00001cb8 <UART1_receiveString>:


void UART1_receiveString (u8 *str)
{
    1cb8:	df 93       	push	r29
    1cba:	cf 93       	push	r28
    1cbc:	00 d0       	rcall	.+0      	; 0x1cbe <UART1_receiveString+0x6>
    1cbe:	cd b7       	in	r28, 0x3d	; 61
    1cc0:	de b7       	in	r29, 0x3e	; 62
    1cc2:	9a 83       	std	Y+2, r25	; 0x02
    1cc4:	89 83       	std	Y+1, r24	; 0x01
	*str=UART1_receiveByte();
    1cc6:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <UART1_receiveByte>
    1cca:	e9 81       	ldd	r30, Y+1	; 0x01
    1ccc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cce:	80 83       	st	Z, r24
    1cd0:	0a c0       	rjmp	.+20     	; 0x1ce6 <UART1_receiveString+0x2e>
	while (*str != '#')
	{
		str++;
    1cd2:	89 81       	ldd	r24, Y+1	; 0x01
    1cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1cd6:	01 96       	adiw	r24, 0x01	; 1
    1cd8:	9a 83       	std	Y+2, r25	; 0x02
    1cda:	89 83       	std	Y+1, r24	; 0x01
		*str=UART1_receiveByte();
    1cdc:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <UART1_receiveByte>
    1ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce4:	80 83       	st	Z, r24


void UART1_receiveString (u8 *str)
{
	*str=UART1_receiveByte();
	while (*str != '#')
    1ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cea:	80 81       	ld	r24, Z
    1cec:	83 32       	cpi	r24, 0x23	; 35
    1cee:	89 f7       	brne	.-30     	; 0x1cd2 <UART1_receiveString+0x1a>
	{
		str++;
		*str=UART1_receiveByte();

	}
	*str='\0';
    1cf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf4:	10 82       	st	Z, r1

}
    1cf6:	0f 90       	pop	r0
    1cf8:	0f 90       	pop	r0
    1cfa:	cf 91       	pop	r28
    1cfc:	df 91       	pop	r29
    1cfe:	08 95       	ret

00001d00 <UART2_sendString>:



void UART2_sendString (const u8 *str)
{
    1d00:	df 93       	push	r29
    1d02:	cf 93       	push	r28
    1d04:	00 d0       	rcall	.+0      	; 0x1d06 <UART2_sendString+0x6>
    1d06:	cd b7       	in	r28, 0x3d	; 61
    1d08:	de b7       	in	r29, 0x3e	; 62
    1d0a:	9a 83       	std	Y+2, r25	; 0x02
    1d0c:	89 83       	std	Y+1, r24	; 0x01
    1d0e:	0a c0       	rjmp	.+20     	; 0x1d24 <UART2_sendString+0x24>
	while (*str != '\0')
	{
		UART2_sendByte(*str);
    1d10:	e9 81       	ldd	r30, Y+1	; 0x01
    1d12:	fa 81       	ldd	r31, Y+2	; 0x02
    1d14:	80 81       	ld	r24, Z
    1d16:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <UART2_sendByte>
		str++;
    1d1a:	89 81       	ldd	r24, Y+1	; 0x01
    1d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d1e:	01 96       	adiw	r24, 0x01	; 1
    1d20:	9a 83       	std	Y+2, r25	; 0x02
    1d22:	89 83       	std	Y+1, r24	; 0x01



void UART2_sendString (const u8 *str)
{
	while (*str != '\0')
    1d24:	e9 81       	ldd	r30, Y+1	; 0x01
    1d26:	fa 81       	ldd	r31, Y+2	; 0x02
    1d28:	80 81       	ld	r24, Z
    1d2a:	88 23       	and	r24, r24
    1d2c:	89 f7       	brne	.-30     	; 0x1d10 <UART2_sendString+0x10>
	{
		UART2_sendByte(*str);
		str++;
	}
}
    1d2e:	0f 90       	pop	r0
    1d30:	0f 90       	pop	r0
    1d32:	cf 91       	pop	r28
    1d34:	df 91       	pop	r29
    1d36:	08 95       	ret

00001d38 <UART2_receiveString>:


void UART2_receiveString (u8 *str)
{
    1d38:	df 93       	push	r29
    1d3a:	cf 93       	push	r28
    1d3c:	00 d0       	rcall	.+0      	; 0x1d3e <UART2_receiveString+0x6>
    1d3e:	cd b7       	in	r28, 0x3d	; 61
    1d40:	de b7       	in	r29, 0x3e	; 62
    1d42:	9a 83       	std	Y+2, r25	; 0x02
    1d44:	89 83       	std	Y+1, r24	; 0x01
	*str=UART2_receiveByte();
    1d46:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <UART2_receiveByte>
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	80 83       	st	Z, r24
    1d50:	0a c0       	rjmp	.+20     	; 0x1d66 <UART2_receiveString+0x2e>
	while (*str != ',')
	{
		str++;
    1d52:	89 81       	ldd	r24, Y+1	; 0x01
    1d54:	9a 81       	ldd	r25, Y+2	; 0x02
    1d56:	01 96       	adiw	r24, 0x01	; 1
    1d58:	9a 83       	std	Y+2, r25	; 0x02
    1d5a:	89 83       	std	Y+1, r24	; 0x01
		*str=UART2_receiveByte();
    1d5c:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <UART2_receiveByte>
    1d60:	e9 81       	ldd	r30, Y+1	; 0x01
    1d62:	fa 81       	ldd	r31, Y+2	; 0x02
    1d64:	80 83       	st	Z, r24


void UART2_receiveString (u8 *str)
{
	*str=UART2_receiveByte();
	while (*str != ',')
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	80 81       	ld	r24, Z
    1d6c:	8c 32       	cpi	r24, 0x2C	; 44
    1d6e:	89 f7       	brne	.-30     	; 0x1d52 <UART2_receiveString+0x1a>
	{
		str++;
		*str=UART2_receiveByte();

	}
	*str='\0';
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	10 82       	st	Z, r1

}
    1d76:	0f 90       	pop	r0
    1d78:	0f 90       	pop	r0
    1d7a:	cf 91       	pop	r28
    1d7c:	df 91       	pop	r29
    1d7e:	08 95       	ret

00001d80 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1d80:	df 93       	push	r29
    1d82:	cf 93       	push	r28
    1d84:	cd b7       	in	r28, 0x3d	; 61
    1d86:	de b7       	in	r29, 0x3e	; 62
    1d88:	27 97       	sbiw	r28, 0x07	; 7
    1d8a:	0f b6       	in	r0, 0x3f	; 63
    1d8c:	f8 94       	cli
    1d8e:	de bf       	out	0x3e, r29	; 62
    1d90:	0f be       	out	0x3f, r0	; 63
    1d92:	cd bf       	out	0x3d, r28	; 61
    1d94:	9d 83       	std	Y+5, r25	; 0x05
    1d96:	8c 83       	std	Y+4, r24	; 0x04
    1d98:	6e 83       	std	Y+6, r22	; 0x06
    1d9a:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1d9c:	8a e1       	ldi	r24, 0x1A	; 26
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	0e 94 98 11 	call	0x2330	; 0x2330 <pvPortMalloc>
    1da4:	9a 83       	std	Y+2, r25	; 0x02
    1da6:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1da8:	89 81       	ldd	r24, Y+1	; 0x01
    1daa:	9a 81       	ldd	r25, Y+2	; 0x02
    1dac:	00 97       	sbiw	r24, 0x00	; 0
    1dae:	09 f4       	brne	.+2      	; 0x1db2 <xCoRoutineCreate+0x32>
    1db0:	6f c0       	rjmp	.+222    	; 0x1e90 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1db2:	80 91 0e 01 	lds	r24, 0x010E
    1db6:	90 91 0f 01 	lds	r25, 0x010F
    1dba:	00 97       	sbiw	r24, 0x00	; 0
    1dbc:	41 f4       	brne	.+16     	; 0x1dce <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1dbe:	89 81       	ldd	r24, Y+1	; 0x01
    1dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1dc2:	90 93 0f 01 	sts	0x010F, r25
    1dc6:	80 93 0e 01 	sts	0x010E, r24
			prvInitialiseCoRoutineLists();
    1dca:	0e 94 27 11 	call	0x224e	; 0x224e <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1dce:	8e 81       	ldd	r24, Y+6	; 0x06
    1dd0:	82 30       	cpi	r24, 0x02	; 2
    1dd2:	10 f0       	brcs	.+4      	; 0x1dd8 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1dd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dda:	fa 81       	ldd	r31, Y+2	; 0x02
    1ddc:	11 8e       	std	Z+25, r1	; 0x19
    1dde:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1de0:	e9 81       	ldd	r30, Y+1	; 0x01
    1de2:	fa 81       	ldd	r31, Y+2	; 0x02
    1de4:	8e 81       	ldd	r24, Y+6	; 0x06
    1de6:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1de8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dea:	fa 81       	ldd	r31, Y+2	; 0x02
    1dec:	8f 81       	ldd	r24, Y+7	; 0x07
    1dee:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1df0:	e9 81       	ldd	r30, Y+1	; 0x01
    1df2:	fa 81       	ldd	r31, Y+2	; 0x02
    1df4:	8c 81       	ldd	r24, Y+4	; 0x04
    1df6:	9d 81       	ldd	r25, Y+5	; 0x05
    1df8:	91 83       	std	Z+1, r25	; 0x01
    1dfa:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1dfc:	89 81       	ldd	r24, Y+1	; 0x01
    1dfe:	9a 81       	ldd	r25, Y+2	; 0x02
    1e00:	02 96       	adiw	r24, 0x02	; 2
    1e02:	0e 94 2e 12 	call	0x245c	; 0x245c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
    1e08:	9a 81       	ldd	r25, Y+2	; 0x02
    1e0a:	0c 96       	adiw	r24, 0x0c	; 12
    1e0c:	0e 94 2e 12 	call	0x245c	; 0x245c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1e10:	e9 81       	ldd	r30, Y+1	; 0x01
    1e12:	fa 81       	ldd	r31, Y+2	; 0x02
    1e14:	89 81       	ldd	r24, Y+1	; 0x01
    1e16:	9a 81       	ldd	r25, Y+2	; 0x02
    1e18:	91 87       	std	Z+9, r25	; 0x09
    1e1a:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e20:	89 81       	ldd	r24, Y+1	; 0x01
    1e22:	9a 81       	ldd	r25, Y+2	; 0x02
    1e24:	93 8b       	std	Z+19, r25	; 0x13
    1e26:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1e28:	8e 81       	ldd	r24, Y+6	; 0x06
    1e2a:	28 2f       	mov	r18, r24
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	83 e0       	ldi	r24, 0x03	; 3
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	82 1b       	sub	r24, r18
    1e34:	93 0b       	sbc	r25, r19
    1e36:	e9 81       	ldd	r30, Y+1	; 0x01
    1e38:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3a:	95 87       	std	Z+13, r25	; 0x0d
    1e3c:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	96 89       	ldd	r25, Z+22	; 0x16
    1e44:	80 91 10 01 	lds	r24, 0x0110
    1e48:	89 17       	cp	r24, r25
    1e4a:	28 f4       	brcc	.+10     	; 0x1e56 <xCoRoutineCreate+0xd6>
    1e4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e50:	86 89       	ldd	r24, Z+22	; 0x16
    1e52:	80 93 10 01 	sts	0x0110, r24
    1e56:	e9 81       	ldd	r30, Y+1	; 0x01
    1e58:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5a:	86 89       	ldd	r24, Z+22	; 0x16
    1e5c:	28 2f       	mov	r18, r24
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	c9 01       	movw	r24, r18
    1e62:	88 0f       	add	r24, r24
    1e64:	99 1f       	adc	r25, r25
    1e66:	88 0f       	add	r24, r24
    1e68:	99 1f       	adc	r25, r25
    1e6a:	88 0f       	add	r24, r24
    1e6c:	99 1f       	adc	r25, r25
    1e6e:	82 0f       	add	r24, r18
    1e70:	93 1f       	adc	r25, r19
    1e72:	ac 01       	movw	r20, r24
    1e74:	49 5e       	subi	r20, 0xE9	; 233
    1e76:	5e 4f       	sbci	r21, 0xFE	; 254
    1e78:	89 81       	ldd	r24, Y+1	; 0x01
    1e7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e7c:	9c 01       	movw	r18, r24
    1e7e:	2e 5f       	subi	r18, 0xFE	; 254
    1e80:	3f 4f       	sbci	r19, 0xFF	; 255
    1e82:	ca 01       	movw	r24, r20
    1e84:	b9 01       	movw	r22, r18
    1e86:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>

		xReturn = pdPASS;
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	8b 83       	std	Y+3, r24	; 0x03
    1e8e:	02 c0       	rjmp	.+4      	; 0x1e94 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e90:	8f ef       	ldi	r24, 0xFF	; 255
    1e92:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1e94:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1e96:	27 96       	adiw	r28, 0x07	; 7
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	de bf       	out	0x3e, r29	; 62
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	cd bf       	out	0x3d, r28	; 61
    1ea2:	cf 91       	pop	r28
    1ea4:	df 91       	pop	r29
    1ea6:	08 95       	ret

00001ea8 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1ea8:	df 93       	push	r29
    1eaa:	cf 93       	push	r28
    1eac:	00 d0       	rcall	.+0      	; 0x1eae <vCoRoutineAddToDelayedList+0x6>
    1eae:	00 d0       	rcall	.+0      	; 0x1eb0 <vCoRoutineAddToDelayedList+0x8>
    1eb0:	00 d0       	rcall	.+0      	; 0x1eb2 <vCoRoutineAddToDelayedList+0xa>
    1eb2:	cd b7       	in	r28, 0x3d	; 61
    1eb4:	de b7       	in	r29, 0x3e	; 62
    1eb6:	9c 83       	std	Y+4, r25	; 0x04
    1eb8:	8b 83       	std	Y+3, r24	; 0x03
    1eba:	7e 83       	std	Y+6, r23	; 0x06
    1ebc:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1ebe:	20 91 11 01 	lds	r18, 0x0111
    1ec2:	30 91 12 01 	lds	r19, 0x0112
    1ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eca:	82 0f       	add	r24, r18
    1ecc:	93 1f       	adc	r25, r19
    1ece:	9a 83       	std	Y+2, r25	; 0x02
    1ed0:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ed2:	80 91 0e 01 	lds	r24, 0x010E
    1ed6:	90 91 0f 01 	lds	r25, 0x010F
    1eda:	02 96       	adiw	r24, 0x02	; 2
    1edc:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1ee0:	e0 91 0e 01 	lds	r30, 0x010E
    1ee4:	f0 91 0f 01 	lds	r31, 0x010F
    1ee8:	89 81       	ldd	r24, Y+1	; 0x01
    1eea:	9a 81       	ldd	r25, Y+2	; 0x02
    1eec:	93 83       	std	Z+3, r25	; 0x03
    1eee:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1ef0:	20 91 11 01 	lds	r18, 0x0111
    1ef4:	30 91 12 01 	lds	r19, 0x0112
    1ef8:	89 81       	ldd	r24, Y+1	; 0x01
    1efa:	9a 81       	ldd	r25, Y+2	; 0x02
    1efc:	82 17       	cp	r24, r18
    1efe:	93 07       	cpc	r25, r19
    1f00:	70 f4       	brcc	.+28     	; 0x1f1e <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f02:	80 91 3d 01 	lds	r24, 0x013D
    1f06:	90 91 3e 01 	lds	r25, 0x013E
    1f0a:	20 91 0e 01 	lds	r18, 0x010E
    1f0e:	30 91 0f 01 	lds	r19, 0x010F
    1f12:	2e 5f       	subi	r18, 0xFE	; 254
    1f14:	3f 4f       	sbci	r19, 0xFF	; 255
    1f16:	b9 01       	movw	r22, r18
    1f18:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>
    1f1c:	0d c0       	rjmp	.+26     	; 0x1f38 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f1e:	80 91 3b 01 	lds	r24, 0x013B
    1f22:	90 91 3c 01 	lds	r25, 0x013C
    1f26:	20 91 0e 01 	lds	r18, 0x010E
    1f2a:	30 91 0f 01 	lds	r19, 0x010F
    1f2e:	2e 5f       	subi	r18, 0xFE	; 254
    1f30:	3f 4f       	sbci	r19, 0xFF	; 255
    1f32:	b9 01       	movw	r22, r18
    1f34:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>
	}

	if( pxEventList )
    1f38:	8d 81       	ldd	r24, Y+5	; 0x05
    1f3a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f3c:	00 97       	sbiw	r24, 0x00	; 0
    1f3e:	61 f0       	breq	.+24     	; 0x1f58 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1f40:	80 91 0e 01 	lds	r24, 0x010E
    1f44:	90 91 0f 01 	lds	r25, 0x010F
    1f48:	9c 01       	movw	r18, r24
    1f4a:	24 5f       	subi	r18, 0xF4	; 244
    1f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f50:	9e 81       	ldd	r25, Y+6	; 0x06
    1f52:	b9 01       	movw	r22, r18
    1f54:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>
	}
}
    1f58:	26 96       	adiw	r28, 0x06	; 6
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	de bf       	out	0x3e, r29	; 62
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	cd bf       	out	0x3d, r28	; 61
    1f64:	cf 91       	pop	r28
    1f66:	df 91       	pop	r29
    1f68:	08 95       	ret

00001f6a <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1f6a:	df 93       	push	r29
    1f6c:	cf 93       	push	r28
    1f6e:	00 d0       	rcall	.+0      	; 0x1f70 <prvCheckPendingReadyList+0x6>
    1f70:	cd b7       	in	r28, 0x3d	; 61
    1f72:	de b7       	in	r29, 0x3e	; 62
    1f74:	3a c0       	rjmp	.+116    	; 0x1fea <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1f76:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1f78:	e0 91 44 01 	lds	r30, 0x0144
    1f7c:	f0 91 45 01 	lds	r31, 0x0145
    1f80:	86 81       	ldd	r24, Z+6	; 0x06
    1f82:	97 81       	ldd	r25, Z+7	; 0x07
    1f84:	9a 83       	std	Y+2, r25	; 0x02
    1f86:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f88:	89 81       	ldd	r24, Y+1	; 0x01
    1f8a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f8c:	0c 96       	adiw	r24, 0x0c	; 12
    1f8e:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1f92:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f94:	89 81       	ldd	r24, Y+1	; 0x01
    1f96:	9a 81       	ldd	r25, Y+2	; 0x02
    1f98:	02 96       	adiw	r24, 0x02	; 2
    1f9a:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa2:	96 89       	ldd	r25, Z+22	; 0x16
    1fa4:	80 91 10 01 	lds	r24, 0x0110
    1fa8:	89 17       	cp	r24, r25
    1faa:	28 f4       	brcc	.+10     	; 0x1fb6 <prvCheckPendingReadyList+0x4c>
    1fac:	e9 81       	ldd	r30, Y+1	; 0x01
    1fae:	fa 81       	ldd	r31, Y+2	; 0x02
    1fb0:	86 89       	ldd	r24, Z+22	; 0x16
    1fb2:	80 93 10 01 	sts	0x0110, r24
    1fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fba:	86 89       	ldd	r24, Z+22	; 0x16
    1fbc:	28 2f       	mov	r18, r24
    1fbe:	30 e0       	ldi	r19, 0x00	; 0
    1fc0:	c9 01       	movw	r24, r18
    1fc2:	88 0f       	add	r24, r24
    1fc4:	99 1f       	adc	r25, r25
    1fc6:	88 0f       	add	r24, r24
    1fc8:	99 1f       	adc	r25, r25
    1fca:	88 0f       	add	r24, r24
    1fcc:	99 1f       	adc	r25, r25
    1fce:	82 0f       	add	r24, r18
    1fd0:	93 1f       	adc	r25, r19
    1fd2:	ac 01       	movw	r20, r24
    1fd4:	49 5e       	subi	r20, 0xE9	; 233
    1fd6:	5e 4f       	sbci	r21, 0xFE	; 254
    1fd8:	89 81       	ldd	r24, Y+1	; 0x01
    1fda:	9a 81       	ldd	r25, Y+2	; 0x02
    1fdc:	9c 01       	movw	r18, r24
    1fde:	2e 5f       	subi	r18, 0xFE	; 254
    1fe0:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe2:	ca 01       	movw	r24, r20
    1fe4:	b9 01       	movw	r22, r18
    1fe6:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1fea:	80 91 3f 01 	lds	r24, 0x013F
    1fee:	88 23       	and	r24, r24
    1ff0:	09 f0       	breq	.+2      	; 0x1ff4 <prvCheckPendingReadyList+0x8a>
    1ff2:	c1 cf       	rjmp	.-126    	; 0x1f76 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    1ff4:	0f 90       	pop	r0
    1ff6:	0f 90       	pop	r0
    1ff8:	cf 91       	pop	r28
    1ffa:	df 91       	pop	r29
    1ffc:	08 95       	ret

00001ffe <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1ffe:	df 93       	push	r29
    2000:	cf 93       	push	r28
    2002:	00 d0       	rcall	.+0      	; 0x2004 <prvCheckDelayedList+0x6>
    2004:	00 d0       	rcall	.+0      	; 0x2006 <prvCheckDelayedList+0x8>
    2006:	cd b7       	in	r28, 0x3d	; 61
    2008:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    200a:	0e 94 72 1d 	call	0x3ae4	; 0x3ae4 <xTaskGetTickCount>
    200e:	20 91 13 01 	lds	r18, 0x0113
    2012:	30 91 14 01 	lds	r19, 0x0114
    2016:	82 1b       	sub	r24, r18
    2018:	93 0b       	sbc	r25, r19
    201a:	90 93 16 01 	sts	0x0116, r25
    201e:	80 93 15 01 	sts	0x0115, r24
    2022:	85 c0       	rjmp	.+266    	; 0x212e <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2024:	80 91 11 01 	lds	r24, 0x0111
    2028:	90 91 12 01 	lds	r25, 0x0112
    202c:	01 96       	adiw	r24, 0x01	; 1
    202e:	90 93 12 01 	sts	0x0112, r25
    2032:	80 93 11 01 	sts	0x0111, r24
		xPassedTicks--;
    2036:	80 91 15 01 	lds	r24, 0x0115
    203a:	90 91 16 01 	lds	r25, 0x0116
    203e:	01 97       	sbiw	r24, 0x01	; 1
    2040:	90 93 16 01 	sts	0x0116, r25
    2044:	80 93 15 01 	sts	0x0115, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2048:	80 91 11 01 	lds	r24, 0x0111
    204c:	90 91 12 01 	lds	r25, 0x0112
    2050:	00 97       	sbiw	r24, 0x00	; 0
    2052:	09 f0       	breq	.+2      	; 0x2056 <prvCheckDelayedList+0x58>
    2054:	64 c0       	rjmp	.+200    	; 0x211e <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2056:	80 91 3b 01 	lds	r24, 0x013B
    205a:	90 91 3c 01 	lds	r25, 0x013C
    205e:	9a 83       	std	Y+2, r25	; 0x02
    2060:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2062:	80 91 3d 01 	lds	r24, 0x013D
    2066:	90 91 3e 01 	lds	r25, 0x013E
    206a:	90 93 3c 01 	sts	0x013C, r25
    206e:	80 93 3b 01 	sts	0x013B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2072:	89 81       	ldd	r24, Y+1	; 0x01
    2074:	9a 81       	ldd	r25, Y+2	; 0x02
    2076:	90 93 3e 01 	sts	0x013E, r25
    207a:	80 93 3d 01 	sts	0x013D, r24
    207e:	4f c0       	rjmp	.+158    	; 0x211e <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2080:	e0 91 3b 01 	lds	r30, 0x013B
    2084:	f0 91 3c 01 	lds	r31, 0x013C
    2088:	05 80       	ldd	r0, Z+5	; 0x05
    208a:	f6 81       	ldd	r31, Z+6	; 0x06
    208c:	e0 2d       	mov	r30, r0
    208e:	86 81       	ldd	r24, Z+6	; 0x06
    2090:	97 81       	ldd	r25, Z+7	; 0x07
    2092:	9c 83       	std	Y+4, r25	; 0x04
    2094:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2096:	eb 81       	ldd	r30, Y+3	; 0x03
    2098:	fc 81       	ldd	r31, Y+4	; 0x04
    209a:	22 81       	ldd	r18, Z+2	; 0x02
    209c:	33 81       	ldd	r19, Z+3	; 0x03
    209e:	80 91 11 01 	lds	r24, 0x0111
    20a2:	90 91 12 01 	lds	r25, 0x0112
    20a6:	82 17       	cp	r24, r18
    20a8:	93 07       	cpc	r25, r19
    20aa:	08 f4       	brcc	.+2      	; 0x20ae <prvCheckDelayedList+0xb0>
    20ac:	40 c0       	rjmp	.+128    	; 0x212e <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    20ae:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    20b0:	8b 81       	ldd	r24, Y+3	; 0x03
    20b2:	9c 81       	ldd	r25, Y+4	; 0x04
    20b4:	02 96       	adiw	r24, 0x02	; 2
    20b6:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    20ba:	eb 81       	ldd	r30, Y+3	; 0x03
    20bc:	fc 81       	ldd	r31, Y+4	; 0x04
    20be:	84 89       	ldd	r24, Z+20	; 0x14
    20c0:	95 89       	ldd	r25, Z+21	; 0x15
    20c2:	00 97       	sbiw	r24, 0x00	; 0
    20c4:	29 f0       	breq	.+10     	; 0x20d0 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    20c6:	8b 81       	ldd	r24, Y+3	; 0x03
    20c8:	9c 81       	ldd	r25, Y+4	; 0x04
    20ca:	0c 96       	adiw	r24, 0x0c	; 12
    20cc:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    20d0:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    20d2:	eb 81       	ldd	r30, Y+3	; 0x03
    20d4:	fc 81       	ldd	r31, Y+4	; 0x04
    20d6:	96 89       	ldd	r25, Z+22	; 0x16
    20d8:	80 91 10 01 	lds	r24, 0x0110
    20dc:	89 17       	cp	r24, r25
    20de:	28 f4       	brcc	.+10     	; 0x20ea <prvCheckDelayedList+0xec>
    20e0:	eb 81       	ldd	r30, Y+3	; 0x03
    20e2:	fc 81       	ldd	r31, Y+4	; 0x04
    20e4:	86 89       	ldd	r24, Z+22	; 0x16
    20e6:	80 93 10 01 	sts	0x0110, r24
    20ea:	eb 81       	ldd	r30, Y+3	; 0x03
    20ec:	fc 81       	ldd	r31, Y+4	; 0x04
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	28 2f       	mov	r18, r24
    20f2:	30 e0       	ldi	r19, 0x00	; 0
    20f4:	c9 01       	movw	r24, r18
    20f6:	88 0f       	add	r24, r24
    20f8:	99 1f       	adc	r25, r25
    20fa:	88 0f       	add	r24, r24
    20fc:	99 1f       	adc	r25, r25
    20fe:	88 0f       	add	r24, r24
    2100:	99 1f       	adc	r25, r25
    2102:	82 0f       	add	r24, r18
    2104:	93 1f       	adc	r25, r19
    2106:	ac 01       	movw	r20, r24
    2108:	49 5e       	subi	r20, 0xE9	; 233
    210a:	5e 4f       	sbci	r21, 0xFE	; 254
    210c:	8b 81       	ldd	r24, Y+3	; 0x03
    210e:	9c 81       	ldd	r25, Y+4	; 0x04
    2110:	9c 01       	movw	r18, r24
    2112:	2e 5f       	subi	r18, 0xFE	; 254
    2114:	3f 4f       	sbci	r19, 0xFF	; 255
    2116:	ca 01       	movw	r24, r20
    2118:	b9 01       	movw	r22, r18
    211a:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    211e:	e0 91 3b 01 	lds	r30, 0x013B
    2122:	f0 91 3c 01 	lds	r31, 0x013C
    2126:	80 81       	ld	r24, Z
    2128:	88 23       	and	r24, r24
    212a:	09 f0       	breq	.+2      	; 0x212e <prvCheckDelayedList+0x130>
    212c:	a9 cf       	rjmp	.-174    	; 0x2080 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    212e:	80 91 15 01 	lds	r24, 0x0115
    2132:	90 91 16 01 	lds	r25, 0x0116
    2136:	00 97       	sbiw	r24, 0x00	; 0
    2138:	09 f0       	breq	.+2      	; 0x213c <prvCheckDelayedList+0x13e>
    213a:	74 cf       	rjmp	.-280    	; 0x2024 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    213c:	80 91 11 01 	lds	r24, 0x0111
    2140:	90 91 12 01 	lds	r25, 0x0112
    2144:	90 93 14 01 	sts	0x0114, r25
    2148:	80 93 13 01 	sts	0x0113, r24
}
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	0f 90       	pop	r0
    2154:	cf 91       	pop	r28
    2156:	df 91       	pop	r29
    2158:	08 95       	ret

0000215a <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    215a:	df 93       	push	r29
    215c:	cf 93       	push	r28
    215e:	00 d0       	rcall	.+0      	; 0x2160 <vCoRoutineSchedule+0x6>
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2164:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2168:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <prvCheckDelayedList>
    216c:	0a c0       	rjmp	.+20     	; 0x2182 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    216e:	80 91 10 01 	lds	r24, 0x0110
    2172:	88 23       	and	r24, r24
    2174:	09 f4       	brne	.+2      	; 0x2178 <vCoRoutineSchedule+0x1e>
    2176:	66 c0       	rjmp	.+204    	; 0x2244 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2178:	80 91 10 01 	lds	r24, 0x0110
    217c:	81 50       	subi	r24, 0x01	; 1
    217e:	80 93 10 01 	sts	0x0110, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2182:	80 91 10 01 	lds	r24, 0x0110
    2186:	28 2f       	mov	r18, r24
    2188:	30 e0       	ldi	r19, 0x00	; 0
    218a:	c9 01       	movw	r24, r18
    218c:	88 0f       	add	r24, r24
    218e:	99 1f       	adc	r25, r25
    2190:	88 0f       	add	r24, r24
    2192:	99 1f       	adc	r25, r25
    2194:	88 0f       	add	r24, r24
    2196:	99 1f       	adc	r25, r25
    2198:	82 0f       	add	r24, r18
    219a:	93 1f       	adc	r25, r19
    219c:	fc 01       	movw	r30, r24
    219e:	e9 5e       	subi	r30, 0xE9	; 233
    21a0:	fe 4f       	sbci	r31, 0xFE	; 254
    21a2:	80 81       	ld	r24, Z
    21a4:	88 23       	and	r24, r24
    21a6:	19 f3       	breq	.-58     	; 0x216e <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    21a8:	80 91 10 01 	lds	r24, 0x0110
    21ac:	28 2f       	mov	r18, r24
    21ae:	30 e0       	ldi	r19, 0x00	; 0
    21b0:	c9 01       	movw	r24, r18
    21b2:	88 0f       	add	r24, r24
    21b4:	99 1f       	adc	r25, r25
    21b6:	88 0f       	add	r24, r24
    21b8:	99 1f       	adc	r25, r25
    21ba:	88 0f       	add	r24, r24
    21bc:	99 1f       	adc	r25, r25
    21be:	82 0f       	add	r24, r18
    21c0:	93 1f       	adc	r25, r19
    21c2:	89 5e       	subi	r24, 0xE9	; 233
    21c4:	9e 4f       	sbci	r25, 0xFE	; 254
    21c6:	9a 83       	std	Y+2, r25	; 0x02
    21c8:	89 83       	std	Y+1, r24	; 0x01
    21ca:	e9 81       	ldd	r30, Y+1	; 0x01
    21cc:	fa 81       	ldd	r31, Y+2	; 0x02
    21ce:	01 80       	ldd	r0, Z+1	; 0x01
    21d0:	f2 81       	ldd	r31, Z+2	; 0x02
    21d2:	e0 2d       	mov	r30, r0
    21d4:	82 81       	ldd	r24, Z+2	; 0x02
    21d6:	93 81       	ldd	r25, Z+3	; 0x03
    21d8:	e9 81       	ldd	r30, Y+1	; 0x01
    21da:	fa 81       	ldd	r31, Y+2	; 0x02
    21dc:	92 83       	std	Z+2, r25	; 0x02
    21de:	81 83       	std	Z+1, r24	; 0x01
    21e0:	e9 81       	ldd	r30, Y+1	; 0x01
    21e2:	fa 81       	ldd	r31, Y+2	; 0x02
    21e4:	21 81       	ldd	r18, Z+1	; 0x01
    21e6:	32 81       	ldd	r19, Z+2	; 0x02
    21e8:	89 81       	ldd	r24, Y+1	; 0x01
    21ea:	9a 81       	ldd	r25, Y+2	; 0x02
    21ec:	03 96       	adiw	r24, 0x03	; 3
    21ee:	28 17       	cp	r18, r24
    21f0:	39 07       	cpc	r19, r25
    21f2:	59 f4       	brne	.+22     	; 0x220a <vCoRoutineSchedule+0xb0>
    21f4:	e9 81       	ldd	r30, Y+1	; 0x01
    21f6:	fa 81       	ldd	r31, Y+2	; 0x02
    21f8:	01 80       	ldd	r0, Z+1	; 0x01
    21fa:	f2 81       	ldd	r31, Z+2	; 0x02
    21fc:	e0 2d       	mov	r30, r0
    21fe:	82 81       	ldd	r24, Z+2	; 0x02
    2200:	93 81       	ldd	r25, Z+3	; 0x03
    2202:	e9 81       	ldd	r30, Y+1	; 0x01
    2204:	fa 81       	ldd	r31, Y+2	; 0x02
    2206:	92 83       	std	Z+2, r25	; 0x02
    2208:	81 83       	std	Z+1, r24	; 0x01
    220a:	e9 81       	ldd	r30, Y+1	; 0x01
    220c:	fa 81       	ldd	r31, Y+2	; 0x02
    220e:	01 80       	ldd	r0, Z+1	; 0x01
    2210:	f2 81       	ldd	r31, Z+2	; 0x02
    2212:	e0 2d       	mov	r30, r0
    2214:	86 81       	ldd	r24, Z+6	; 0x06
    2216:	97 81       	ldd	r25, Z+7	; 0x07
    2218:	90 93 0f 01 	sts	0x010F, r25
    221c:	80 93 0e 01 	sts	0x010E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2220:	e0 91 0e 01 	lds	r30, 0x010E
    2224:	f0 91 0f 01 	lds	r31, 0x010F
    2228:	40 81       	ld	r20, Z
    222a:	51 81       	ldd	r21, Z+1	; 0x01
    222c:	80 91 0e 01 	lds	r24, 0x010E
    2230:	90 91 0f 01 	lds	r25, 0x010F
    2234:	e0 91 0e 01 	lds	r30, 0x010E
    2238:	f0 91 0f 01 	lds	r31, 0x010F
    223c:	27 89       	ldd	r18, Z+23	; 0x17
    223e:	62 2f       	mov	r22, r18
    2240:	fa 01       	movw	r30, r20
    2242:	09 95       	icall

	return;
}
    2244:	0f 90       	pop	r0
    2246:	0f 90       	pop	r0
    2248:	cf 91       	pop	r28
    224a:	df 91       	pop	r29
    224c:	08 95       	ret

0000224e <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    224e:	df 93       	push	r29
    2250:	cf 93       	push	r28
    2252:	0f 92       	push	r0
    2254:	cd b7       	in	r28, 0x3d	; 61
    2256:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2258:	19 82       	std	Y+1, r1	; 0x01
    225a:	13 c0       	rjmp	.+38     	; 0x2282 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	28 2f       	mov	r18, r24
    2260:	30 e0       	ldi	r19, 0x00	; 0
    2262:	c9 01       	movw	r24, r18
    2264:	88 0f       	add	r24, r24
    2266:	99 1f       	adc	r25, r25
    2268:	88 0f       	add	r24, r24
    226a:	99 1f       	adc	r25, r25
    226c:	88 0f       	add	r24, r24
    226e:	99 1f       	adc	r25, r25
    2270:	82 0f       	add	r24, r18
    2272:	93 1f       	adc	r25, r19
    2274:	89 5e       	subi	r24, 0xE9	; 233
    2276:	9e 4f       	sbci	r25, 0xFE	; 254
    2278:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    227c:	89 81       	ldd	r24, Y+1	; 0x01
    227e:	8f 5f       	subi	r24, 0xFF	; 255
    2280:	89 83       	std	Y+1, r24	; 0x01
    2282:	89 81       	ldd	r24, Y+1	; 0x01
    2284:	82 30       	cpi	r24, 0x02	; 2
    2286:	50 f3       	brcs	.-44     	; 0x225c <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2288:	89 e2       	ldi	r24, 0x29	; 41
    228a:	91 e0       	ldi	r25, 0x01	; 1
    228c:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2290:	82 e3       	ldi	r24, 0x32	; 50
    2292:	91 e0       	ldi	r25, 0x01	; 1
    2294:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2298:	8f e3       	ldi	r24, 0x3F	; 63
    229a:	91 e0       	ldi	r25, 0x01	; 1
    229c:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    22a0:	89 e2       	ldi	r24, 0x29	; 41
    22a2:	91 e0       	ldi	r25, 0x01	; 1
    22a4:	90 93 3c 01 	sts	0x013C, r25
    22a8:	80 93 3b 01 	sts	0x013B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    22ac:	82 e3       	ldi	r24, 0x32	; 50
    22ae:	91 e0       	ldi	r25, 0x01	; 1
    22b0:	90 93 3e 01 	sts	0x013E, r25
    22b4:	80 93 3d 01 	sts	0x013D, r24
}
    22b8:	0f 90       	pop	r0
    22ba:	cf 91       	pop	r28
    22bc:	df 91       	pop	r29
    22be:	08 95       	ret

000022c0 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    22c0:	df 93       	push	r29
    22c2:	cf 93       	push	r28
    22c4:	00 d0       	rcall	.+0      	; 0x22c6 <xCoRoutineRemoveFromEventList+0x6>
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <xCoRoutineRemoveFromEventList+0x8>
    22c8:	0f 92       	push	r0
    22ca:	cd b7       	in	r28, 0x3d	; 61
    22cc:	de b7       	in	r29, 0x3e	; 62
    22ce:	9d 83       	std	Y+5, r25	; 0x05
    22d0:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22d2:	ec 81       	ldd	r30, Y+4	; 0x04
    22d4:	fd 81       	ldd	r31, Y+5	; 0x05
    22d6:	05 80       	ldd	r0, Z+5	; 0x05
    22d8:	f6 81       	ldd	r31, Z+6	; 0x06
    22da:	e0 2d       	mov	r30, r0
    22dc:	86 81       	ldd	r24, Z+6	; 0x06
    22de:	97 81       	ldd	r25, Z+7	; 0x07
    22e0:	9b 83       	std	Y+3, r25	; 0x03
    22e2:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    22e4:	8a 81       	ldd	r24, Y+2	; 0x02
    22e6:	9b 81       	ldd	r25, Y+3	; 0x03
    22e8:	0c 96       	adiw	r24, 0x0c	; 12
    22ea:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    22ee:	8a 81       	ldd	r24, Y+2	; 0x02
    22f0:	9b 81       	ldd	r25, Y+3	; 0x03
    22f2:	9c 01       	movw	r18, r24
    22f4:	24 5f       	subi	r18, 0xF4	; 244
    22f6:	3f 4f       	sbci	r19, 0xFF	; 255
    22f8:	8f e3       	ldi	r24, 0x3F	; 63
    22fa:	91 e0       	ldi	r25, 0x01	; 1
    22fc:	b9 01       	movw	r22, r18
    22fe:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2302:	ea 81       	ldd	r30, Y+2	; 0x02
    2304:	fb 81       	ldd	r31, Y+3	; 0x03
    2306:	96 89       	ldd	r25, Z+22	; 0x16
    2308:	e0 91 0e 01 	lds	r30, 0x010E
    230c:	f0 91 0f 01 	lds	r31, 0x010F
    2310:	86 89       	ldd	r24, Z+22	; 0x16
    2312:	98 17       	cp	r25, r24
    2314:	18 f0       	brcs	.+6      	; 0x231c <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	89 83       	std	Y+1, r24	; 0x01
    231a:	01 c0       	rjmp	.+2      	; 0x231e <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    231c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    231e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2320:	0f 90       	pop	r0
    2322:	0f 90       	pop	r0
    2324:	0f 90       	pop	r0
    2326:	0f 90       	pop	r0
    2328:	0f 90       	pop	r0
    232a:	cf 91       	pop	r28
    232c:	df 91       	pop	r29
    232e:	08 95       	ret

00002330 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2330:	df 93       	push	r29
    2332:	cf 93       	push	r28
    2334:	00 d0       	rcall	.+0      	; 0x2336 <pvPortMalloc+0x6>
    2336:	00 d0       	rcall	.+0      	; 0x2338 <pvPortMalloc+0x8>
    2338:	cd b7       	in	r28, 0x3d	; 61
    233a:	de b7       	in	r29, 0x3e	; 62
    233c:	9c 83       	std	Y+4, r25	; 0x04
    233e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2340:	1a 82       	std	Y+2, r1	; 0x02
    2342:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2344:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2348:	80 91 48 01 	lds	r24, 0x0148
    234c:	90 91 49 01 	lds	r25, 0x0149
    2350:	2b 81       	ldd	r18, Y+3	; 0x03
    2352:	3c 81       	ldd	r19, Y+4	; 0x04
    2354:	82 0f       	add	r24, r18
    2356:	93 1f       	adc	r25, r19
    2358:	22 e0       	ldi	r18, 0x02	; 2
    235a:	88 35       	cpi	r24, 0x58	; 88
    235c:	92 07       	cpc	r25, r18
    235e:	18 f5       	brcc	.+70     	; 0x23a6 <pvPortMalloc+0x76>
    2360:	20 91 48 01 	lds	r18, 0x0148
    2364:	30 91 49 01 	lds	r19, 0x0149
    2368:	8b 81       	ldd	r24, Y+3	; 0x03
    236a:	9c 81       	ldd	r25, Y+4	; 0x04
    236c:	28 0f       	add	r18, r24
    236e:	39 1f       	adc	r19, r25
    2370:	80 91 48 01 	lds	r24, 0x0148
    2374:	90 91 49 01 	lds	r25, 0x0149
    2378:	82 17       	cp	r24, r18
    237a:	93 07       	cpc	r25, r19
    237c:	a0 f4       	brcc	.+40     	; 0x23a6 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    237e:	80 91 48 01 	lds	r24, 0x0148
    2382:	90 91 49 01 	lds	r25, 0x0149
    2386:	86 5b       	subi	r24, 0xB6	; 182
    2388:	9e 4f       	sbci	r25, 0xFE	; 254
    238a:	9a 83       	std	Y+2, r25	; 0x02
    238c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    238e:	20 91 48 01 	lds	r18, 0x0148
    2392:	30 91 49 01 	lds	r19, 0x0149
    2396:	8b 81       	ldd	r24, Y+3	; 0x03
    2398:	9c 81       	ldd	r25, Y+4	; 0x04
    239a:	82 0f       	add	r24, r18
    239c:	93 1f       	adc	r25, r19
    239e:	90 93 49 01 	sts	0x0149, r25
    23a2:	80 93 48 01 	sts	0x0148, r24
		}	
	}
	xTaskResumeAll();
    23a6:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    23aa:	89 81       	ldd	r24, Y+1	; 0x01
    23ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    23ae:	0f 90       	pop	r0
    23b0:	0f 90       	pop	r0
    23b2:	0f 90       	pop	r0
    23b4:	0f 90       	pop	r0
    23b6:	cf 91       	pop	r28
    23b8:	df 91       	pop	r29
    23ba:	08 95       	ret

000023bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    23bc:	df 93       	push	r29
    23be:	cf 93       	push	r28
    23c0:	00 d0       	rcall	.+0      	; 0x23c2 <vPortFree+0x6>
    23c2:	cd b7       	in	r28, 0x3d	; 61
    23c4:	de b7       	in	r29, 0x3e	; 62
    23c6:	9a 83       	std	Y+2, r25	; 0x02
    23c8:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	cf 91       	pop	r28
    23d0:	df 91       	pop	r29
    23d2:	08 95       	ret

000023d4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    23d4:	df 93       	push	r29
    23d6:	cf 93       	push	r28
    23d8:	cd b7       	in	r28, 0x3d	; 61
    23da:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23dc:	10 92 49 01 	sts	0x0149, r1
    23e0:	10 92 48 01 	sts	0x0148, r1
}
    23e4:	cf 91       	pop	r28
    23e6:	df 91       	pop	r29
    23e8:	08 95       	ret

000023ea <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    23ea:	df 93       	push	r29
    23ec:	cf 93       	push	r28
    23ee:	cd b7       	in	r28, 0x3d	; 61
    23f0:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    23f2:	20 91 48 01 	lds	r18, 0x0148
    23f6:	30 91 49 01 	lds	r19, 0x0149
    23fa:	88 e5       	ldi	r24, 0x58	; 88
    23fc:	92 e0       	ldi	r25, 0x02	; 2
    23fe:	82 1b       	sub	r24, r18
    2400:	93 0b       	sbc	r25, r19
}
    2402:	cf 91       	pop	r28
    2404:	df 91       	pop	r29
    2406:	08 95       	ret

00002408 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2408:	df 93       	push	r29
    240a:	cf 93       	push	r28
    240c:	00 d0       	rcall	.+0      	; 0x240e <vListInitialise+0x6>
    240e:	cd b7       	in	r28, 0x3d	; 61
    2410:	de b7       	in	r29, 0x3e	; 62
    2412:	9a 83       	std	Y+2, r25	; 0x02
    2414:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2416:	89 81       	ldd	r24, Y+1	; 0x01
    2418:	9a 81       	ldd	r25, Y+2	; 0x02
    241a:	03 96       	adiw	r24, 0x03	; 3
    241c:	e9 81       	ldd	r30, Y+1	; 0x01
    241e:	fa 81       	ldd	r31, Y+2	; 0x02
    2420:	92 83       	std	Z+2, r25	; 0x02
    2422:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2424:	e9 81       	ldd	r30, Y+1	; 0x01
    2426:	fa 81       	ldd	r31, Y+2	; 0x02
    2428:	8f ef       	ldi	r24, 0xFF	; 255
    242a:	9f ef       	ldi	r25, 0xFF	; 255
    242c:	94 83       	std	Z+4, r25	; 0x04
    242e:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	9a 81       	ldd	r25, Y+2	; 0x02
    2434:	03 96       	adiw	r24, 0x03	; 3
    2436:	e9 81       	ldd	r30, Y+1	; 0x01
    2438:	fa 81       	ldd	r31, Y+2	; 0x02
    243a:	96 83       	std	Z+6, r25	; 0x06
    243c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    243e:	89 81       	ldd	r24, Y+1	; 0x01
    2440:	9a 81       	ldd	r25, Y+2	; 0x02
    2442:	03 96       	adiw	r24, 0x03	; 3
    2444:	e9 81       	ldd	r30, Y+1	; 0x01
    2446:	fa 81       	ldd	r31, Y+2	; 0x02
    2448:	90 87       	std	Z+8, r25	; 0x08
    244a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    244c:	e9 81       	ldd	r30, Y+1	; 0x01
    244e:	fa 81       	ldd	r31, Y+2	; 0x02
    2450:	10 82       	st	Z, r1
}
    2452:	0f 90       	pop	r0
    2454:	0f 90       	pop	r0
    2456:	cf 91       	pop	r28
    2458:	df 91       	pop	r29
    245a:	08 95       	ret

0000245c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    245c:	df 93       	push	r29
    245e:	cf 93       	push	r28
    2460:	00 d0       	rcall	.+0      	; 0x2462 <vListInitialiseItem+0x6>
    2462:	cd b7       	in	r28, 0x3d	; 61
    2464:	de b7       	in	r29, 0x3e	; 62
    2466:	9a 83       	std	Y+2, r25	; 0x02
    2468:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    246a:	e9 81       	ldd	r30, Y+1	; 0x01
    246c:	fa 81       	ldd	r31, Y+2	; 0x02
    246e:	11 86       	std	Z+9, r1	; 0x09
    2470:	10 86       	std	Z+8, r1	; 0x08
}
    2472:	0f 90       	pop	r0
    2474:	0f 90       	pop	r0
    2476:	cf 91       	pop	r28
    2478:	df 91       	pop	r29
    247a:	08 95       	ret

0000247c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    247c:	df 93       	push	r29
    247e:	cf 93       	push	r28
    2480:	00 d0       	rcall	.+0      	; 0x2482 <vListInsertEnd+0x6>
    2482:	00 d0       	rcall	.+0      	; 0x2484 <vListInsertEnd+0x8>
    2484:	00 d0       	rcall	.+0      	; 0x2486 <vListInsertEnd+0xa>
    2486:	cd b7       	in	r28, 0x3d	; 61
    2488:	de b7       	in	r29, 0x3e	; 62
    248a:	9c 83       	std	Y+4, r25	; 0x04
    248c:	8b 83       	std	Y+3, r24	; 0x03
    248e:	7e 83       	std	Y+6, r23	; 0x06
    2490:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2492:	eb 81       	ldd	r30, Y+3	; 0x03
    2494:	fc 81       	ldd	r31, Y+4	; 0x04
    2496:	81 81       	ldd	r24, Z+1	; 0x01
    2498:	92 81       	ldd	r25, Z+2	; 0x02
    249a:	9a 83       	std	Y+2, r25	; 0x02
    249c:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    249e:	e9 81       	ldd	r30, Y+1	; 0x01
    24a0:	fa 81       	ldd	r31, Y+2	; 0x02
    24a2:	82 81       	ldd	r24, Z+2	; 0x02
    24a4:	93 81       	ldd	r25, Z+3	; 0x03
    24a6:	ed 81       	ldd	r30, Y+5	; 0x05
    24a8:	fe 81       	ldd	r31, Y+6	; 0x06
    24aa:	93 83       	std	Z+3, r25	; 0x03
    24ac:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    24ae:	eb 81       	ldd	r30, Y+3	; 0x03
    24b0:	fc 81       	ldd	r31, Y+4	; 0x04
    24b2:	81 81       	ldd	r24, Z+1	; 0x01
    24b4:	92 81       	ldd	r25, Z+2	; 0x02
    24b6:	ed 81       	ldd	r30, Y+5	; 0x05
    24b8:	fe 81       	ldd	r31, Y+6	; 0x06
    24ba:	95 83       	std	Z+5, r25	; 0x05
    24bc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    24be:	e9 81       	ldd	r30, Y+1	; 0x01
    24c0:	fa 81       	ldd	r31, Y+2	; 0x02
    24c2:	02 80       	ldd	r0, Z+2	; 0x02
    24c4:	f3 81       	ldd	r31, Z+3	; 0x03
    24c6:	e0 2d       	mov	r30, r0
    24c8:	8d 81       	ldd	r24, Y+5	; 0x05
    24ca:	9e 81       	ldd	r25, Y+6	; 0x06
    24cc:	95 83       	std	Z+5, r25	; 0x05
    24ce:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    24d0:	8d 81       	ldd	r24, Y+5	; 0x05
    24d2:	9e 81       	ldd	r25, Y+6	; 0x06
    24d4:	e9 81       	ldd	r30, Y+1	; 0x01
    24d6:	fa 81       	ldd	r31, Y+2	; 0x02
    24d8:	93 83       	std	Z+3, r25	; 0x03
    24da:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    24dc:	8d 81       	ldd	r24, Y+5	; 0x05
    24de:	9e 81       	ldd	r25, Y+6	; 0x06
    24e0:	eb 81       	ldd	r30, Y+3	; 0x03
    24e2:	fc 81       	ldd	r31, Y+4	; 0x04
    24e4:	92 83       	std	Z+2, r25	; 0x02
    24e6:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    24e8:	ed 81       	ldd	r30, Y+5	; 0x05
    24ea:	fe 81       	ldd	r31, Y+6	; 0x06
    24ec:	8b 81       	ldd	r24, Y+3	; 0x03
    24ee:	9c 81       	ldd	r25, Y+4	; 0x04
    24f0:	91 87       	std	Z+9, r25	; 0x09
    24f2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    24f4:	eb 81       	ldd	r30, Y+3	; 0x03
    24f6:	fc 81       	ldd	r31, Y+4	; 0x04
    24f8:	80 81       	ld	r24, Z
    24fa:	8f 5f       	subi	r24, 0xFF	; 255
    24fc:	eb 81       	ldd	r30, Y+3	; 0x03
    24fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2500:	80 83       	st	Z, r24
}
    2502:	26 96       	adiw	r28, 0x06	; 6
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	f8 94       	cli
    2508:	de bf       	out	0x3e, r29	; 62
    250a:	0f be       	out	0x3f, r0	; 63
    250c:	cd bf       	out	0x3d, r28	; 61
    250e:	cf 91       	pop	r28
    2510:	df 91       	pop	r29
    2512:	08 95       	ret

00002514 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2514:	df 93       	push	r29
    2516:	cf 93       	push	r28
    2518:	cd b7       	in	r28, 0x3d	; 61
    251a:	de b7       	in	r29, 0x3e	; 62
    251c:	28 97       	sbiw	r28, 0x08	; 8
    251e:	0f b6       	in	r0, 0x3f	; 63
    2520:	f8 94       	cli
    2522:	de bf       	out	0x3e, r29	; 62
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	cd bf       	out	0x3d, r28	; 61
    2528:	9e 83       	std	Y+6, r25	; 0x06
    252a:	8d 83       	std	Y+5, r24	; 0x05
    252c:	78 87       	std	Y+8, r23	; 0x08
    252e:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2530:	ef 81       	ldd	r30, Y+7	; 0x07
    2532:	f8 85       	ldd	r31, Y+8	; 0x08
    2534:	80 81       	ld	r24, Z
    2536:	91 81       	ldd	r25, Z+1	; 0x01
    2538:	9a 83       	std	Y+2, r25	; 0x02
    253a:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	9a 81       	ldd	r25, Y+2	; 0x02
    2540:	2f ef       	ldi	r18, 0xFF	; 255
    2542:	8f 3f       	cpi	r24, 0xFF	; 255
    2544:	92 07       	cpc	r25, r18
    2546:	39 f4       	brne	.+14     	; 0x2556 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2548:	ed 81       	ldd	r30, Y+5	; 0x05
    254a:	fe 81       	ldd	r31, Y+6	; 0x06
    254c:	87 81       	ldd	r24, Z+7	; 0x07
    254e:	90 85       	ldd	r25, Z+8	; 0x08
    2550:	9c 83       	std	Y+4, r25	; 0x04
    2552:	8b 83       	std	Y+3, r24	; 0x03
    2554:	18 c0       	rjmp	.+48     	; 0x2586 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2556:	8d 81       	ldd	r24, Y+5	; 0x05
    2558:	9e 81       	ldd	r25, Y+6	; 0x06
    255a:	03 96       	adiw	r24, 0x03	; 3
    255c:	9c 83       	std	Y+4, r25	; 0x04
    255e:	8b 83       	std	Y+3, r24	; 0x03
    2560:	06 c0       	rjmp	.+12     	; 0x256e <vListInsert+0x5a>
    2562:	eb 81       	ldd	r30, Y+3	; 0x03
    2564:	fc 81       	ldd	r31, Y+4	; 0x04
    2566:	82 81       	ldd	r24, Z+2	; 0x02
    2568:	93 81       	ldd	r25, Z+3	; 0x03
    256a:	9c 83       	std	Y+4, r25	; 0x04
    256c:	8b 83       	std	Y+3, r24	; 0x03
    256e:	eb 81       	ldd	r30, Y+3	; 0x03
    2570:	fc 81       	ldd	r31, Y+4	; 0x04
    2572:	02 80       	ldd	r0, Z+2	; 0x02
    2574:	f3 81       	ldd	r31, Z+3	; 0x03
    2576:	e0 2d       	mov	r30, r0
    2578:	20 81       	ld	r18, Z
    257a:	31 81       	ldd	r19, Z+1	; 0x01
    257c:	89 81       	ldd	r24, Y+1	; 0x01
    257e:	9a 81       	ldd	r25, Y+2	; 0x02
    2580:	82 17       	cp	r24, r18
    2582:	93 07       	cpc	r25, r19
    2584:	70 f7       	brcc	.-36     	; 0x2562 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2586:	eb 81       	ldd	r30, Y+3	; 0x03
    2588:	fc 81       	ldd	r31, Y+4	; 0x04
    258a:	82 81       	ldd	r24, Z+2	; 0x02
    258c:	93 81       	ldd	r25, Z+3	; 0x03
    258e:	ef 81       	ldd	r30, Y+7	; 0x07
    2590:	f8 85       	ldd	r31, Y+8	; 0x08
    2592:	93 83       	std	Z+3, r25	; 0x03
    2594:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2596:	ef 81       	ldd	r30, Y+7	; 0x07
    2598:	f8 85       	ldd	r31, Y+8	; 0x08
    259a:	02 80       	ldd	r0, Z+2	; 0x02
    259c:	f3 81       	ldd	r31, Z+3	; 0x03
    259e:	e0 2d       	mov	r30, r0
    25a0:	8f 81       	ldd	r24, Y+7	; 0x07
    25a2:	98 85       	ldd	r25, Y+8	; 0x08
    25a4:	95 83       	std	Z+5, r25	; 0x05
    25a6:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    25a8:	ef 81       	ldd	r30, Y+7	; 0x07
    25aa:	f8 85       	ldd	r31, Y+8	; 0x08
    25ac:	8b 81       	ldd	r24, Y+3	; 0x03
    25ae:	9c 81       	ldd	r25, Y+4	; 0x04
    25b0:	95 83       	std	Z+5, r25	; 0x05
    25b2:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    25b4:	8f 81       	ldd	r24, Y+7	; 0x07
    25b6:	98 85       	ldd	r25, Y+8	; 0x08
    25b8:	eb 81       	ldd	r30, Y+3	; 0x03
    25ba:	fc 81       	ldd	r31, Y+4	; 0x04
    25bc:	93 83       	std	Z+3, r25	; 0x03
    25be:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    25c0:	ef 81       	ldd	r30, Y+7	; 0x07
    25c2:	f8 85       	ldd	r31, Y+8	; 0x08
    25c4:	8d 81       	ldd	r24, Y+5	; 0x05
    25c6:	9e 81       	ldd	r25, Y+6	; 0x06
    25c8:	91 87       	std	Z+9, r25	; 0x09
    25ca:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    25cc:	ed 81       	ldd	r30, Y+5	; 0x05
    25ce:	fe 81       	ldd	r31, Y+6	; 0x06
    25d0:	80 81       	ld	r24, Z
    25d2:	8f 5f       	subi	r24, 0xFF	; 255
    25d4:	ed 81       	ldd	r30, Y+5	; 0x05
    25d6:	fe 81       	ldd	r31, Y+6	; 0x06
    25d8:	80 83       	st	Z, r24
}
    25da:	28 96       	adiw	r28, 0x08	; 8
    25dc:	0f b6       	in	r0, 0x3f	; 63
    25de:	f8 94       	cli
    25e0:	de bf       	out	0x3e, r29	; 62
    25e2:	0f be       	out	0x3f, r0	; 63
    25e4:	cd bf       	out	0x3d, r28	; 61
    25e6:	cf 91       	pop	r28
    25e8:	df 91       	pop	r29
    25ea:	08 95       	ret

000025ec <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    25ec:	df 93       	push	r29
    25ee:	cf 93       	push	r28
    25f0:	00 d0       	rcall	.+0      	; 0x25f2 <vListRemove+0x6>
    25f2:	00 d0       	rcall	.+0      	; 0x25f4 <vListRemove+0x8>
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	9c 83       	std	Y+4, r25	; 0x04
    25fa:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    25fc:	eb 81       	ldd	r30, Y+3	; 0x03
    25fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2600:	a2 81       	ldd	r26, Z+2	; 0x02
    2602:	b3 81       	ldd	r27, Z+3	; 0x03
    2604:	eb 81       	ldd	r30, Y+3	; 0x03
    2606:	fc 81       	ldd	r31, Y+4	; 0x04
    2608:	84 81       	ldd	r24, Z+4	; 0x04
    260a:	95 81       	ldd	r25, Z+5	; 0x05
    260c:	15 96       	adiw	r26, 0x05	; 5
    260e:	9c 93       	st	X, r25
    2610:	8e 93       	st	-X, r24
    2612:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2614:	eb 81       	ldd	r30, Y+3	; 0x03
    2616:	fc 81       	ldd	r31, Y+4	; 0x04
    2618:	a4 81       	ldd	r26, Z+4	; 0x04
    261a:	b5 81       	ldd	r27, Z+5	; 0x05
    261c:	eb 81       	ldd	r30, Y+3	; 0x03
    261e:	fc 81       	ldd	r31, Y+4	; 0x04
    2620:	82 81       	ldd	r24, Z+2	; 0x02
    2622:	93 81       	ldd	r25, Z+3	; 0x03
    2624:	13 96       	adiw	r26, 0x03	; 3
    2626:	9c 93       	st	X, r25
    2628:	8e 93       	st	-X, r24
    262a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    262c:	eb 81       	ldd	r30, Y+3	; 0x03
    262e:	fc 81       	ldd	r31, Y+4	; 0x04
    2630:	80 85       	ldd	r24, Z+8	; 0x08
    2632:	91 85       	ldd	r25, Z+9	; 0x09
    2634:	9a 83       	std	Y+2, r25	; 0x02
    2636:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2638:	e9 81       	ldd	r30, Y+1	; 0x01
    263a:	fa 81       	ldd	r31, Y+2	; 0x02
    263c:	21 81       	ldd	r18, Z+1	; 0x01
    263e:	32 81       	ldd	r19, Z+2	; 0x02
    2640:	8b 81       	ldd	r24, Y+3	; 0x03
    2642:	9c 81       	ldd	r25, Y+4	; 0x04
    2644:	28 17       	cp	r18, r24
    2646:	39 07       	cpc	r19, r25
    2648:	41 f4       	brne	.+16     	; 0x265a <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    264a:	eb 81       	ldd	r30, Y+3	; 0x03
    264c:	fc 81       	ldd	r31, Y+4	; 0x04
    264e:	84 81       	ldd	r24, Z+4	; 0x04
    2650:	95 81       	ldd	r25, Z+5	; 0x05
    2652:	e9 81       	ldd	r30, Y+1	; 0x01
    2654:	fa 81       	ldd	r31, Y+2	; 0x02
    2656:	92 83       	std	Z+2, r25	; 0x02
    2658:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    265a:	eb 81       	ldd	r30, Y+3	; 0x03
    265c:	fc 81       	ldd	r31, Y+4	; 0x04
    265e:	11 86       	std	Z+9, r1	; 0x09
    2660:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2662:	e9 81       	ldd	r30, Y+1	; 0x01
    2664:	fa 81       	ldd	r31, Y+2	; 0x02
    2666:	80 81       	ld	r24, Z
    2668:	81 50       	subi	r24, 0x01	; 1
    266a:	e9 81       	ldd	r30, Y+1	; 0x01
    266c:	fa 81       	ldd	r31, Y+2	; 0x02
    266e:	80 83       	st	Z, r24
}
    2670:	0f 90       	pop	r0
    2672:	0f 90       	pop	r0
    2674:	0f 90       	pop	r0
    2676:	0f 90       	pop	r0
    2678:	cf 91       	pop	r28
    267a:	df 91       	pop	r29
    267c:	08 95       	ret

0000267e <main>:
#include "PWM.h"
#include"avr/delay.h"


void main(void)
{
    267e:	df 93       	push	r29
    2680:	cf 93       	push	r28
    2682:	cd b7       	in	r28, 0x3d	; 61
    2684:	de b7       	in	r29, 0x3e	; 62
    2686:	c8 59       	subi	r28, 0x98	; 152
    2688:	d0 40       	sbci	r29, 0x00	; 0
    268a:	0f b6       	in	r0, 0x3f	; 63
    268c:	f8 94       	cli
    268e:	de bf       	out	0x3e, r29	; 62
    2690:	0f be       	out	0x3f, r0	; 63
    2692:	cd bf       	out	0x3d, r28	; 61
	xTaskCreate(yaw_controller,"yaw", configMINIMAL_STACK_SIZE, &parameter, 3, NULL);
	xTaskCreate(roll_pitch,"roll&pitch", configMINIMAL_STACK_SIZE, &parameter, 4, NULL);
	xTaskCreate(body_rates,"body_rates", configMINIMAL_STACK_SIZE, &parameter, 5, NULL);

*/
	ARM_Motors();
    2694:	0e 94 bb 0b 	call	0x1776	; 0x1776 <ARM_Motors>
    2698:	ff cf       	rjmp	.-2      	; 0x2698 <main+0x1a>

0000269a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    269a:	df 93       	push	r29
    269c:	cf 93       	push	r28
    269e:	cd b7       	in	r28, 0x3d	; 61
    26a0:	de b7       	in	r29, 0x3e	; 62
    26a2:	28 97       	sbiw	r28, 0x08	; 8
    26a4:	0f b6       	in	r0, 0x3f	; 63
    26a6:	f8 94       	cli
    26a8:	de bf       	out	0x3e, r29	; 62
    26aa:	0f be       	out	0x3f, r0	; 63
    26ac:	cd bf       	out	0x3d, r28	; 61
    26ae:	9c 83       	std	Y+4, r25	; 0x04
    26b0:	8b 83       	std	Y+3, r24	; 0x03
    26b2:	7e 83       	std	Y+6, r23	; 0x06
    26b4:	6d 83       	std	Y+5, r22	; 0x05
    26b6:	58 87       	std	Y+8, r21	; 0x08
    26b8:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    26ba:	eb 81       	ldd	r30, Y+3	; 0x03
    26bc:	fc 81       	ldd	r31, Y+4	; 0x04
    26be:	81 e1       	ldi	r24, 0x11	; 17
    26c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    26c2:	8b 81       	ldd	r24, Y+3	; 0x03
    26c4:	9c 81       	ldd	r25, Y+4	; 0x04
    26c6:	01 97       	sbiw	r24, 0x01	; 1
    26c8:	9c 83       	std	Y+4, r25	; 0x04
    26ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    26cc:	eb 81       	ldd	r30, Y+3	; 0x03
    26ce:	fc 81       	ldd	r31, Y+4	; 0x04
    26d0:	82 e2       	ldi	r24, 0x22	; 34
    26d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    26d4:	8b 81       	ldd	r24, Y+3	; 0x03
    26d6:	9c 81       	ldd	r25, Y+4	; 0x04
    26d8:	01 97       	sbiw	r24, 0x01	; 1
    26da:	9c 83       	std	Y+4, r25	; 0x04
    26dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    26de:	eb 81       	ldd	r30, Y+3	; 0x03
    26e0:	fc 81       	ldd	r31, Y+4	; 0x04
    26e2:	83 e3       	ldi	r24, 0x33	; 51
    26e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    26e6:	8b 81       	ldd	r24, Y+3	; 0x03
    26e8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ea:	01 97       	sbiw	r24, 0x01	; 1
    26ec:	9c 83       	std	Y+4, r25	; 0x04
    26ee:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    26f0:	8d 81       	ldd	r24, Y+5	; 0x05
    26f2:	9e 81       	ldd	r25, Y+6	; 0x06
    26f4:	9a 83       	std	Y+2, r25	; 0x02
    26f6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    26f8:	89 81       	ldd	r24, Y+1	; 0x01
    26fa:	eb 81       	ldd	r30, Y+3	; 0x03
    26fc:	fc 81       	ldd	r31, Y+4	; 0x04
    26fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2700:	8b 81       	ldd	r24, Y+3	; 0x03
    2702:	9c 81       	ldd	r25, Y+4	; 0x04
    2704:	01 97       	sbiw	r24, 0x01	; 1
    2706:	9c 83       	std	Y+4, r25	; 0x04
    2708:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    270a:	89 81       	ldd	r24, Y+1	; 0x01
    270c:	9a 81       	ldd	r25, Y+2	; 0x02
    270e:	89 2f       	mov	r24, r25
    2710:	99 27       	eor	r25, r25
    2712:	9a 83       	std	Y+2, r25	; 0x02
    2714:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2716:	89 81       	ldd	r24, Y+1	; 0x01
    2718:	eb 81       	ldd	r30, Y+3	; 0x03
    271a:	fc 81       	ldd	r31, Y+4	; 0x04
    271c:	80 83       	st	Z, r24
	pxTopOfStack--;
    271e:	8b 81       	ldd	r24, Y+3	; 0x03
    2720:	9c 81       	ldd	r25, Y+4	; 0x04
    2722:	01 97       	sbiw	r24, 0x01	; 1
    2724:	9c 83       	std	Y+4, r25	; 0x04
    2726:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2728:	eb 81       	ldd	r30, Y+3	; 0x03
    272a:	fc 81       	ldd	r31, Y+4	; 0x04
    272c:	10 82       	st	Z, r1
	pxTopOfStack--;
    272e:	8b 81       	ldd	r24, Y+3	; 0x03
    2730:	9c 81       	ldd	r25, Y+4	; 0x04
    2732:	01 97       	sbiw	r24, 0x01	; 1
    2734:	9c 83       	std	Y+4, r25	; 0x04
    2736:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2738:	eb 81       	ldd	r30, Y+3	; 0x03
    273a:	fc 81       	ldd	r31, Y+4	; 0x04
    273c:	80 e8       	ldi	r24, 0x80	; 128
    273e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2740:	8b 81       	ldd	r24, Y+3	; 0x03
    2742:	9c 81       	ldd	r25, Y+4	; 0x04
    2744:	01 97       	sbiw	r24, 0x01	; 1
    2746:	9c 83       	std	Y+4, r25	; 0x04
    2748:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    274a:	eb 81       	ldd	r30, Y+3	; 0x03
    274c:	fc 81       	ldd	r31, Y+4	; 0x04
    274e:	10 82       	st	Z, r1
	pxTopOfStack--;
    2750:	8b 81       	ldd	r24, Y+3	; 0x03
    2752:	9c 81       	ldd	r25, Y+4	; 0x04
    2754:	01 97       	sbiw	r24, 0x01	; 1
    2756:	9c 83       	std	Y+4, r25	; 0x04
    2758:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    275a:	eb 81       	ldd	r30, Y+3	; 0x03
    275c:	fc 81       	ldd	r31, Y+4	; 0x04
    275e:	82 e0       	ldi	r24, 0x02	; 2
    2760:	80 83       	st	Z, r24
	pxTopOfStack--;
    2762:	8b 81       	ldd	r24, Y+3	; 0x03
    2764:	9c 81       	ldd	r25, Y+4	; 0x04
    2766:	01 97       	sbiw	r24, 0x01	; 1
    2768:	9c 83       	std	Y+4, r25	; 0x04
    276a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    276c:	eb 81       	ldd	r30, Y+3	; 0x03
    276e:	fc 81       	ldd	r31, Y+4	; 0x04
    2770:	83 e0       	ldi	r24, 0x03	; 3
    2772:	80 83       	st	Z, r24
	pxTopOfStack--;
    2774:	8b 81       	ldd	r24, Y+3	; 0x03
    2776:	9c 81       	ldd	r25, Y+4	; 0x04
    2778:	01 97       	sbiw	r24, 0x01	; 1
    277a:	9c 83       	std	Y+4, r25	; 0x04
    277c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    277e:	eb 81       	ldd	r30, Y+3	; 0x03
    2780:	fc 81       	ldd	r31, Y+4	; 0x04
    2782:	84 e0       	ldi	r24, 0x04	; 4
    2784:	80 83       	st	Z, r24
	pxTopOfStack--;
    2786:	8b 81       	ldd	r24, Y+3	; 0x03
    2788:	9c 81       	ldd	r25, Y+4	; 0x04
    278a:	01 97       	sbiw	r24, 0x01	; 1
    278c:	9c 83       	std	Y+4, r25	; 0x04
    278e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2790:	eb 81       	ldd	r30, Y+3	; 0x03
    2792:	fc 81       	ldd	r31, Y+4	; 0x04
    2794:	85 e0       	ldi	r24, 0x05	; 5
    2796:	80 83       	st	Z, r24
	pxTopOfStack--;
    2798:	8b 81       	ldd	r24, Y+3	; 0x03
    279a:	9c 81       	ldd	r25, Y+4	; 0x04
    279c:	01 97       	sbiw	r24, 0x01	; 1
    279e:	9c 83       	std	Y+4, r25	; 0x04
    27a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    27a2:	eb 81       	ldd	r30, Y+3	; 0x03
    27a4:	fc 81       	ldd	r31, Y+4	; 0x04
    27a6:	86 e0       	ldi	r24, 0x06	; 6
    27a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    27aa:	8b 81       	ldd	r24, Y+3	; 0x03
    27ac:	9c 81       	ldd	r25, Y+4	; 0x04
    27ae:	01 97       	sbiw	r24, 0x01	; 1
    27b0:	9c 83       	std	Y+4, r25	; 0x04
    27b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    27b4:	eb 81       	ldd	r30, Y+3	; 0x03
    27b6:	fc 81       	ldd	r31, Y+4	; 0x04
    27b8:	87 e0       	ldi	r24, 0x07	; 7
    27ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    27bc:	8b 81       	ldd	r24, Y+3	; 0x03
    27be:	9c 81       	ldd	r25, Y+4	; 0x04
    27c0:	01 97       	sbiw	r24, 0x01	; 1
    27c2:	9c 83       	std	Y+4, r25	; 0x04
    27c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    27c6:	eb 81       	ldd	r30, Y+3	; 0x03
    27c8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ca:	88 e0       	ldi	r24, 0x08	; 8
    27cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    27ce:	8b 81       	ldd	r24, Y+3	; 0x03
    27d0:	9c 81       	ldd	r25, Y+4	; 0x04
    27d2:	01 97       	sbiw	r24, 0x01	; 1
    27d4:	9c 83       	std	Y+4, r25	; 0x04
    27d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    27d8:	eb 81       	ldd	r30, Y+3	; 0x03
    27da:	fc 81       	ldd	r31, Y+4	; 0x04
    27dc:	89 e0       	ldi	r24, 0x09	; 9
    27de:	80 83       	st	Z, r24
	pxTopOfStack--;
    27e0:	8b 81       	ldd	r24, Y+3	; 0x03
    27e2:	9c 81       	ldd	r25, Y+4	; 0x04
    27e4:	01 97       	sbiw	r24, 0x01	; 1
    27e6:	9c 83       	std	Y+4, r25	; 0x04
    27e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    27ea:	eb 81       	ldd	r30, Y+3	; 0x03
    27ec:	fc 81       	ldd	r31, Y+4	; 0x04
    27ee:	80 e1       	ldi	r24, 0x10	; 16
    27f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    27f2:	8b 81       	ldd	r24, Y+3	; 0x03
    27f4:	9c 81       	ldd	r25, Y+4	; 0x04
    27f6:	01 97       	sbiw	r24, 0x01	; 1
    27f8:	9c 83       	std	Y+4, r25	; 0x04
    27fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    27fc:	eb 81       	ldd	r30, Y+3	; 0x03
    27fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2800:	81 e1       	ldi	r24, 0x11	; 17
    2802:	80 83       	st	Z, r24
	pxTopOfStack--;
    2804:	8b 81       	ldd	r24, Y+3	; 0x03
    2806:	9c 81       	ldd	r25, Y+4	; 0x04
    2808:	01 97       	sbiw	r24, 0x01	; 1
    280a:	9c 83       	std	Y+4, r25	; 0x04
    280c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    280e:	eb 81       	ldd	r30, Y+3	; 0x03
    2810:	fc 81       	ldd	r31, Y+4	; 0x04
    2812:	82 e1       	ldi	r24, 0x12	; 18
    2814:	80 83       	st	Z, r24
	pxTopOfStack--;
    2816:	8b 81       	ldd	r24, Y+3	; 0x03
    2818:	9c 81       	ldd	r25, Y+4	; 0x04
    281a:	01 97       	sbiw	r24, 0x01	; 1
    281c:	9c 83       	std	Y+4, r25	; 0x04
    281e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	83 e1       	ldi	r24, 0x13	; 19
    2826:	80 83       	st	Z, r24
	pxTopOfStack--;
    2828:	8b 81       	ldd	r24, Y+3	; 0x03
    282a:	9c 81       	ldd	r25, Y+4	; 0x04
    282c:	01 97       	sbiw	r24, 0x01	; 1
    282e:	9c 83       	std	Y+4, r25	; 0x04
    2830:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2832:	eb 81       	ldd	r30, Y+3	; 0x03
    2834:	fc 81       	ldd	r31, Y+4	; 0x04
    2836:	84 e1       	ldi	r24, 0x14	; 20
    2838:	80 83       	st	Z, r24
	pxTopOfStack--;
    283a:	8b 81       	ldd	r24, Y+3	; 0x03
    283c:	9c 81       	ldd	r25, Y+4	; 0x04
    283e:	01 97       	sbiw	r24, 0x01	; 1
    2840:	9c 83       	std	Y+4, r25	; 0x04
    2842:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2844:	eb 81       	ldd	r30, Y+3	; 0x03
    2846:	fc 81       	ldd	r31, Y+4	; 0x04
    2848:	85 e1       	ldi	r24, 0x15	; 21
    284a:	80 83       	st	Z, r24
	pxTopOfStack--;
    284c:	8b 81       	ldd	r24, Y+3	; 0x03
    284e:	9c 81       	ldd	r25, Y+4	; 0x04
    2850:	01 97       	sbiw	r24, 0x01	; 1
    2852:	9c 83       	std	Y+4, r25	; 0x04
    2854:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2856:	eb 81       	ldd	r30, Y+3	; 0x03
    2858:	fc 81       	ldd	r31, Y+4	; 0x04
    285a:	86 e1       	ldi	r24, 0x16	; 22
    285c:	80 83       	st	Z, r24
	pxTopOfStack--;
    285e:	8b 81       	ldd	r24, Y+3	; 0x03
    2860:	9c 81       	ldd	r25, Y+4	; 0x04
    2862:	01 97       	sbiw	r24, 0x01	; 1
    2864:	9c 83       	std	Y+4, r25	; 0x04
    2866:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2868:	eb 81       	ldd	r30, Y+3	; 0x03
    286a:	fc 81       	ldd	r31, Y+4	; 0x04
    286c:	87 e1       	ldi	r24, 0x17	; 23
    286e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2870:	8b 81       	ldd	r24, Y+3	; 0x03
    2872:	9c 81       	ldd	r25, Y+4	; 0x04
    2874:	01 97       	sbiw	r24, 0x01	; 1
    2876:	9c 83       	std	Y+4, r25	; 0x04
    2878:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    287a:	eb 81       	ldd	r30, Y+3	; 0x03
    287c:	fc 81       	ldd	r31, Y+4	; 0x04
    287e:	88 e1       	ldi	r24, 0x18	; 24
    2880:	80 83       	st	Z, r24
	pxTopOfStack--;
    2882:	8b 81       	ldd	r24, Y+3	; 0x03
    2884:	9c 81       	ldd	r25, Y+4	; 0x04
    2886:	01 97       	sbiw	r24, 0x01	; 1
    2888:	9c 83       	std	Y+4, r25	; 0x04
    288a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    288c:	eb 81       	ldd	r30, Y+3	; 0x03
    288e:	fc 81       	ldd	r31, Y+4	; 0x04
    2890:	89 e1       	ldi	r24, 0x19	; 25
    2892:	80 83       	st	Z, r24
	pxTopOfStack--;
    2894:	8b 81       	ldd	r24, Y+3	; 0x03
    2896:	9c 81       	ldd	r25, Y+4	; 0x04
    2898:	01 97       	sbiw	r24, 0x01	; 1
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    289e:	eb 81       	ldd	r30, Y+3	; 0x03
    28a0:	fc 81       	ldd	r31, Y+4	; 0x04
    28a2:	80 e2       	ldi	r24, 0x20	; 32
    28a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    28a6:	8b 81       	ldd	r24, Y+3	; 0x03
    28a8:	9c 81       	ldd	r25, Y+4	; 0x04
    28aa:	01 97       	sbiw	r24, 0x01	; 1
    28ac:	9c 83       	std	Y+4, r25	; 0x04
    28ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    28b0:	eb 81       	ldd	r30, Y+3	; 0x03
    28b2:	fc 81       	ldd	r31, Y+4	; 0x04
    28b4:	81 e2       	ldi	r24, 0x21	; 33
    28b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    28b8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ba:	9c 81       	ldd	r25, Y+4	; 0x04
    28bc:	01 97       	sbiw	r24, 0x01	; 1
    28be:	9c 83       	std	Y+4, r25	; 0x04
    28c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    28c2:	eb 81       	ldd	r30, Y+3	; 0x03
    28c4:	fc 81       	ldd	r31, Y+4	; 0x04
    28c6:	82 e2       	ldi	r24, 0x22	; 34
    28c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ca:	8b 81       	ldd	r24, Y+3	; 0x03
    28cc:	9c 81       	ldd	r25, Y+4	; 0x04
    28ce:	01 97       	sbiw	r24, 0x01	; 1
    28d0:	9c 83       	std	Y+4, r25	; 0x04
    28d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    28d4:	eb 81       	ldd	r30, Y+3	; 0x03
    28d6:	fc 81       	ldd	r31, Y+4	; 0x04
    28d8:	83 e2       	ldi	r24, 0x23	; 35
    28da:	80 83       	st	Z, r24
	pxTopOfStack--;
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	9c 81       	ldd	r25, Y+4	; 0x04
    28e0:	01 97       	sbiw	r24, 0x01	; 1
    28e2:	9c 83       	std	Y+4, r25	; 0x04
    28e4:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    28e6:	8f 81       	ldd	r24, Y+7	; 0x07
    28e8:	98 85       	ldd	r25, Y+8	; 0x08
    28ea:	9a 83       	std	Y+2, r25	; 0x02
    28ec:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	eb 81       	ldd	r30, Y+3	; 0x03
    28f2:	fc 81       	ldd	r31, Y+4	; 0x04
    28f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    28f6:	8b 81       	ldd	r24, Y+3	; 0x03
    28f8:	9c 81       	ldd	r25, Y+4	; 0x04
    28fa:	01 97       	sbiw	r24, 0x01	; 1
    28fc:	9c 83       	std	Y+4, r25	; 0x04
    28fe:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2900:	89 81       	ldd	r24, Y+1	; 0x01
    2902:	9a 81       	ldd	r25, Y+2	; 0x02
    2904:	89 2f       	mov	r24, r25
    2906:	99 27       	eor	r25, r25
    2908:	9a 83       	std	Y+2, r25	; 0x02
    290a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	eb 81       	ldd	r30, Y+3	; 0x03
    2910:	fc 81       	ldd	r31, Y+4	; 0x04
    2912:	80 83       	st	Z, r24
	pxTopOfStack--;
    2914:	8b 81       	ldd	r24, Y+3	; 0x03
    2916:	9c 81       	ldd	r25, Y+4	; 0x04
    2918:	01 97       	sbiw	r24, 0x01	; 1
    291a:	9c 83       	std	Y+4, r25	; 0x04
    291c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    291e:	eb 81       	ldd	r30, Y+3	; 0x03
    2920:	fc 81       	ldd	r31, Y+4	; 0x04
    2922:	86 e2       	ldi	r24, 0x26	; 38
    2924:	80 83       	st	Z, r24
	pxTopOfStack--;
    2926:	8b 81       	ldd	r24, Y+3	; 0x03
    2928:	9c 81       	ldd	r25, Y+4	; 0x04
    292a:	01 97       	sbiw	r24, 0x01	; 1
    292c:	9c 83       	std	Y+4, r25	; 0x04
    292e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2930:	eb 81       	ldd	r30, Y+3	; 0x03
    2932:	fc 81       	ldd	r31, Y+4	; 0x04
    2934:	87 e2       	ldi	r24, 0x27	; 39
    2936:	80 83       	st	Z, r24
	pxTopOfStack--;
    2938:	8b 81       	ldd	r24, Y+3	; 0x03
    293a:	9c 81       	ldd	r25, Y+4	; 0x04
    293c:	01 97       	sbiw	r24, 0x01	; 1
    293e:	9c 83       	std	Y+4, r25	; 0x04
    2940:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2942:	eb 81       	ldd	r30, Y+3	; 0x03
    2944:	fc 81       	ldd	r31, Y+4	; 0x04
    2946:	88 e2       	ldi	r24, 0x28	; 40
    2948:	80 83       	st	Z, r24
	pxTopOfStack--;
    294a:	8b 81       	ldd	r24, Y+3	; 0x03
    294c:	9c 81       	ldd	r25, Y+4	; 0x04
    294e:	01 97       	sbiw	r24, 0x01	; 1
    2950:	9c 83       	std	Y+4, r25	; 0x04
    2952:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2954:	eb 81       	ldd	r30, Y+3	; 0x03
    2956:	fc 81       	ldd	r31, Y+4	; 0x04
    2958:	89 e2       	ldi	r24, 0x29	; 41
    295a:	80 83       	st	Z, r24
	pxTopOfStack--;
    295c:	8b 81       	ldd	r24, Y+3	; 0x03
    295e:	9c 81       	ldd	r25, Y+4	; 0x04
    2960:	01 97       	sbiw	r24, 0x01	; 1
    2962:	9c 83       	std	Y+4, r25	; 0x04
    2964:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2966:	eb 81       	ldd	r30, Y+3	; 0x03
    2968:	fc 81       	ldd	r31, Y+4	; 0x04
    296a:	80 e3       	ldi	r24, 0x30	; 48
    296c:	80 83       	st	Z, r24
	pxTopOfStack--;
    296e:	8b 81       	ldd	r24, Y+3	; 0x03
    2970:	9c 81       	ldd	r25, Y+4	; 0x04
    2972:	01 97       	sbiw	r24, 0x01	; 1
    2974:	9c 83       	std	Y+4, r25	; 0x04
    2976:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2978:	eb 81       	ldd	r30, Y+3	; 0x03
    297a:	fc 81       	ldd	r31, Y+4	; 0x04
    297c:	81 e3       	ldi	r24, 0x31	; 49
    297e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2980:	8b 81       	ldd	r24, Y+3	; 0x03
    2982:	9c 81       	ldd	r25, Y+4	; 0x04
    2984:	01 97       	sbiw	r24, 0x01	; 1
    2986:	9c 83       	std	Y+4, r25	; 0x04
    2988:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    298a:	8b 81       	ldd	r24, Y+3	; 0x03
    298c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    298e:	28 96       	adiw	r28, 0x08	; 8
    2990:	0f b6       	in	r0, 0x3f	; 63
    2992:	f8 94       	cli
    2994:	de bf       	out	0x3e, r29	; 62
    2996:	0f be       	out	0x3f, r0	; 63
    2998:	cd bf       	out	0x3d, r28	; 61
    299a:	cf 91       	pop	r28
    299c:	df 91       	pop	r29
    299e:	08 95       	ret

000029a0 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    29a0:	df 93       	push	r29
    29a2:	cf 93       	push	r28
    29a4:	cd b7       	in	r28, 0x3d	; 61
    29a6:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    29a8:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    29ac:	a0 91 a2 03 	lds	r26, 0x03A2
    29b0:	b0 91 a3 03 	lds	r27, 0x03A3
    29b4:	cd 91       	ld	r28, X+
    29b6:	cd bf       	out	0x3d, r28	; 61
    29b8:	dd 91       	ld	r29, X+
    29ba:	de bf       	out	0x3e, r29	; 62
    29bc:	ff 91       	pop	r31
    29be:	ef 91       	pop	r30
    29c0:	df 91       	pop	r29
    29c2:	cf 91       	pop	r28
    29c4:	bf 91       	pop	r27
    29c6:	af 91       	pop	r26
    29c8:	9f 91       	pop	r25
    29ca:	8f 91       	pop	r24
    29cc:	7f 91       	pop	r23
    29ce:	6f 91       	pop	r22
    29d0:	5f 91       	pop	r21
    29d2:	4f 91       	pop	r20
    29d4:	3f 91       	pop	r19
    29d6:	2f 91       	pop	r18
    29d8:	1f 91       	pop	r17
    29da:	0f 91       	pop	r16
    29dc:	ff 90       	pop	r15
    29de:	ef 90       	pop	r14
    29e0:	df 90       	pop	r13
    29e2:	cf 90       	pop	r12
    29e4:	bf 90       	pop	r11
    29e6:	af 90       	pop	r10
    29e8:	9f 90       	pop	r9
    29ea:	8f 90       	pop	r8
    29ec:	7f 90       	pop	r7
    29ee:	6f 90       	pop	r6
    29f0:	5f 90       	pop	r5
    29f2:	4f 90       	pop	r4
    29f4:	3f 90       	pop	r3
    29f6:	2f 90       	pop	r2
    29f8:	1f 90       	pop	r1
    29fa:	0f 90       	pop	r0
    29fc:	0f be       	out	0x3f, r0	; 63
    29fe:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2a00:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2a02:	81 e0       	ldi	r24, 0x01	; 1
}
    2a04:	cf 91       	pop	r28
    2a06:	df 91       	pop	r29
    2a08:	08 95       	ret

00002a0a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2a0a:	df 93       	push	r29
    2a0c:	cf 93       	push	r28
    2a0e:	cd b7       	in	r28, 0x3d	; 61
    2a10:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2a12:	cf 91       	pop	r28
    2a14:	df 91       	pop	r29
    2a16:	08 95       	ret

00002a18 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2a18:	0f 92       	push	r0
    2a1a:	0f b6       	in	r0, 0x3f	; 63
    2a1c:	f8 94       	cli
    2a1e:	0f 92       	push	r0
    2a20:	1f 92       	push	r1
    2a22:	11 24       	eor	r1, r1
    2a24:	2f 92       	push	r2
    2a26:	3f 92       	push	r3
    2a28:	4f 92       	push	r4
    2a2a:	5f 92       	push	r5
    2a2c:	6f 92       	push	r6
    2a2e:	7f 92       	push	r7
    2a30:	8f 92       	push	r8
    2a32:	9f 92       	push	r9
    2a34:	af 92       	push	r10
    2a36:	bf 92       	push	r11
    2a38:	cf 92       	push	r12
    2a3a:	df 92       	push	r13
    2a3c:	ef 92       	push	r14
    2a3e:	ff 92       	push	r15
    2a40:	0f 93       	push	r16
    2a42:	1f 93       	push	r17
    2a44:	2f 93       	push	r18
    2a46:	3f 93       	push	r19
    2a48:	4f 93       	push	r20
    2a4a:	5f 93       	push	r21
    2a4c:	6f 93       	push	r22
    2a4e:	7f 93       	push	r23
    2a50:	8f 93       	push	r24
    2a52:	9f 93       	push	r25
    2a54:	af 93       	push	r26
    2a56:	bf 93       	push	r27
    2a58:	cf 93       	push	r28
    2a5a:	df 93       	push	r29
    2a5c:	ef 93       	push	r30
    2a5e:	ff 93       	push	r31
    2a60:	a0 91 a2 03 	lds	r26, 0x03A2
    2a64:	b0 91 a3 03 	lds	r27, 0x03A3
    2a68:	0d b6       	in	r0, 0x3d	; 61
    2a6a:	0d 92       	st	X+, r0
    2a6c:	0e b6       	in	r0, 0x3e	; 62
    2a6e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2a70:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2a74:	a0 91 a2 03 	lds	r26, 0x03A2
    2a78:	b0 91 a3 03 	lds	r27, 0x03A3
    2a7c:	cd 91       	ld	r28, X+
    2a7e:	cd bf       	out	0x3d, r28	; 61
    2a80:	dd 91       	ld	r29, X+
    2a82:	de bf       	out	0x3e, r29	; 62
    2a84:	ff 91       	pop	r31
    2a86:	ef 91       	pop	r30
    2a88:	df 91       	pop	r29
    2a8a:	cf 91       	pop	r28
    2a8c:	bf 91       	pop	r27
    2a8e:	af 91       	pop	r26
    2a90:	9f 91       	pop	r25
    2a92:	8f 91       	pop	r24
    2a94:	7f 91       	pop	r23
    2a96:	6f 91       	pop	r22
    2a98:	5f 91       	pop	r21
    2a9a:	4f 91       	pop	r20
    2a9c:	3f 91       	pop	r19
    2a9e:	2f 91       	pop	r18
    2aa0:	1f 91       	pop	r17
    2aa2:	0f 91       	pop	r16
    2aa4:	ff 90       	pop	r15
    2aa6:	ef 90       	pop	r14
    2aa8:	df 90       	pop	r13
    2aaa:	cf 90       	pop	r12
    2aac:	bf 90       	pop	r11
    2aae:	af 90       	pop	r10
    2ab0:	9f 90       	pop	r9
    2ab2:	8f 90       	pop	r8
    2ab4:	7f 90       	pop	r7
    2ab6:	6f 90       	pop	r6
    2ab8:	5f 90       	pop	r5
    2aba:	4f 90       	pop	r4
    2abc:	3f 90       	pop	r3
    2abe:	2f 90       	pop	r2
    2ac0:	1f 90       	pop	r1
    2ac2:	0f 90       	pop	r0
    2ac4:	0f be       	out	0x3f, r0	; 63
    2ac6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ac8:	08 95       	ret

00002aca <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2aca:	0f 92       	push	r0
    2acc:	0f b6       	in	r0, 0x3f	; 63
    2ace:	f8 94       	cli
    2ad0:	0f 92       	push	r0
    2ad2:	1f 92       	push	r1
    2ad4:	11 24       	eor	r1, r1
    2ad6:	2f 92       	push	r2
    2ad8:	3f 92       	push	r3
    2ada:	4f 92       	push	r4
    2adc:	5f 92       	push	r5
    2ade:	6f 92       	push	r6
    2ae0:	7f 92       	push	r7
    2ae2:	8f 92       	push	r8
    2ae4:	9f 92       	push	r9
    2ae6:	af 92       	push	r10
    2ae8:	bf 92       	push	r11
    2aea:	cf 92       	push	r12
    2aec:	df 92       	push	r13
    2aee:	ef 92       	push	r14
    2af0:	ff 92       	push	r15
    2af2:	0f 93       	push	r16
    2af4:	1f 93       	push	r17
    2af6:	2f 93       	push	r18
    2af8:	3f 93       	push	r19
    2afa:	4f 93       	push	r20
    2afc:	5f 93       	push	r21
    2afe:	6f 93       	push	r22
    2b00:	7f 93       	push	r23
    2b02:	8f 93       	push	r24
    2b04:	9f 93       	push	r25
    2b06:	af 93       	push	r26
    2b08:	bf 93       	push	r27
    2b0a:	cf 93       	push	r28
    2b0c:	df 93       	push	r29
    2b0e:	ef 93       	push	r30
    2b10:	ff 93       	push	r31
    2b12:	a0 91 a2 03 	lds	r26, 0x03A2
    2b16:	b0 91 a3 03 	lds	r27, 0x03A3
    2b1a:	0d b6       	in	r0, 0x3d	; 61
    2b1c:	0d 92       	st	X+, r0
    2b1e:	0e b6       	in	r0, 0x3e	; 62
    2b20:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2b22:	0e 94 a7 1d 	call	0x3b4e	; 0x3b4e <vTaskIncrementTick>
	vTaskSwitchContext();
    2b26:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2b2a:	a0 91 a2 03 	lds	r26, 0x03A2
    2b2e:	b0 91 a3 03 	lds	r27, 0x03A3
    2b32:	cd 91       	ld	r28, X+
    2b34:	cd bf       	out	0x3d, r28	; 61
    2b36:	dd 91       	ld	r29, X+
    2b38:	de bf       	out	0x3e, r29	; 62
    2b3a:	ff 91       	pop	r31
    2b3c:	ef 91       	pop	r30
    2b3e:	df 91       	pop	r29
    2b40:	cf 91       	pop	r28
    2b42:	bf 91       	pop	r27
    2b44:	af 91       	pop	r26
    2b46:	9f 91       	pop	r25
    2b48:	8f 91       	pop	r24
    2b4a:	7f 91       	pop	r23
    2b4c:	6f 91       	pop	r22
    2b4e:	5f 91       	pop	r21
    2b50:	4f 91       	pop	r20
    2b52:	3f 91       	pop	r19
    2b54:	2f 91       	pop	r18
    2b56:	1f 91       	pop	r17
    2b58:	0f 91       	pop	r16
    2b5a:	ff 90       	pop	r15
    2b5c:	ef 90       	pop	r14
    2b5e:	df 90       	pop	r13
    2b60:	cf 90       	pop	r12
    2b62:	bf 90       	pop	r11
    2b64:	af 90       	pop	r10
    2b66:	9f 90       	pop	r9
    2b68:	8f 90       	pop	r8
    2b6a:	7f 90       	pop	r7
    2b6c:	6f 90       	pop	r6
    2b6e:	5f 90       	pop	r5
    2b70:	4f 90       	pop	r4
    2b72:	3f 90       	pop	r3
    2b74:	2f 90       	pop	r2
    2b76:	1f 90       	pop	r1
    2b78:	0f 90       	pop	r0
    2b7a:	0f be       	out	0x3f, r0	; 63
    2b7c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2b7e:	08 95       	ret

00002b80 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2b80:	df 93       	push	r29
    2b82:	cf 93       	push	r28
    2b84:	00 d0       	rcall	.+0      	; 0x2b86 <prvSetupTimerInterrupt+0x6>
    2b86:	00 d0       	rcall	.+0      	; 0x2b88 <prvSetupTimerInterrupt+0x8>
    2b88:	00 d0       	rcall	.+0      	; 0x2b8a <prvSetupTimerInterrupt+0xa>
    2b8a:	cd b7       	in	r28, 0x3d	; 61
    2b8c:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2b8e:	80 ee       	ldi	r24, 0xE0	; 224
    2b90:	9e e2       	ldi	r25, 0x2E	; 46
    2b92:	a0 e0       	ldi	r26, 0x00	; 0
    2b94:	b0 e0       	ldi	r27, 0x00	; 0
    2b96:	8b 83       	std	Y+3, r24	; 0x03
    2b98:	9c 83       	std	Y+4, r25	; 0x04
    2b9a:	ad 83       	std	Y+5, r26	; 0x05
    2b9c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2b9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba2:	ad 81       	ldd	r26, Y+5	; 0x05
    2ba4:	be 81       	ldd	r27, Y+6	; 0x06
    2ba6:	68 94       	set
    2ba8:	15 f8       	bld	r1, 5
    2baa:	b6 95       	lsr	r27
    2bac:	a7 95       	ror	r26
    2bae:	97 95       	ror	r25
    2bb0:	87 95       	ror	r24
    2bb2:	16 94       	lsr	r1
    2bb4:	d1 f7       	brne	.-12     	; 0x2baa <prvSetupTimerInterrupt+0x2a>
    2bb6:	8b 83       	std	Y+3, r24	; 0x03
    2bb8:	9c 83       	std	Y+4, r25	; 0x04
    2bba:	ad 83       	std	Y+5, r26	; 0x05
    2bbc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    2bbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2bc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc2:	ad 81       	ldd	r26, Y+5	; 0x05
    2bc4:	be 81       	ldd	r27, Y+6	; 0x06
    2bc6:	01 97       	sbiw	r24, 0x01	; 1
    2bc8:	a1 09       	sbc	r26, r1
    2bca:	b1 09       	sbc	r27, r1
    2bcc:	8b 83       	std	Y+3, r24	; 0x03
    2bce:	9c 83       	std	Y+4, r25	; 0x04
    2bd0:	ad 83       	std	Y+5, r26	; 0x05
    2bd2:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2bd4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd6:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2bda:	9c 81       	ldd	r25, Y+4	; 0x04
    2bdc:	ad 81       	ldd	r26, Y+5	; 0x05
    2bde:	be 81       	ldd	r27, Y+6	; 0x06
    2be0:	89 2f       	mov	r24, r25
    2be2:	9a 2f       	mov	r25, r26
    2be4:	ab 2f       	mov	r26, r27
    2be6:	bb 27       	eor	r27, r27
    2be8:	8b 83       	std	Y+3, r24	; 0x03
    2bea:	9c 83       	std	Y+4, r25	; 0x04
    2bec:	ad 83       	std	Y+5, r26	; 0x05
    2bee:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2bf0:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf2:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2bf4:	eb e4       	ldi	r30, 0x4B	; 75
    2bf6:	f0 e0       	ldi	r31, 0x00	; 0
    2bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfa:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2bfc:	ea e4       	ldi	r30, 0x4A	; 74
    2bfe:	f0 e0       	ldi	r31, 0x00	; 0
    2c00:	89 81       	ldd	r24, Y+1	; 0x01
    2c02:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2c04:	8b e0       	ldi	r24, 0x0B	; 11
    2c06:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2c08:	ee e4       	ldi	r30, 0x4E	; 78
    2c0a:	f0 e0       	ldi	r31, 0x00	; 0
    2c0c:	89 81       	ldd	r24, Y+1	; 0x01
    2c0e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2c10:	e7 e5       	ldi	r30, 0x57	; 87
    2c12:	f0 e0       	ldi	r31, 0x00	; 0
    2c14:	80 81       	ld	r24, Z
    2c16:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2c18:	89 81       	ldd	r24, Y+1	; 0x01
    2c1a:	80 61       	ori	r24, 0x10	; 16
    2c1c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2c1e:	e7 e5       	ldi	r30, 0x57	; 87
    2c20:	f0 e0       	ldi	r31, 0x00	; 0
    2c22:	89 81       	ldd	r24, Y+1	; 0x01
    2c24:	80 83       	st	Z, r24
}
    2c26:	26 96       	adiw	r28, 0x06	; 6
    2c28:	0f b6       	in	r0, 0x3f	; 63
    2c2a:	f8 94       	cli
    2c2c:	de bf       	out	0x3e, r29	; 62
    2c2e:	0f be       	out	0x3f, r0	; 63
    2c30:	cd bf       	out	0x3d, r28	; 61
    2c32:	cf 91       	pop	r28
    2c34:	df 91       	pop	r29
    2c36:	08 95       	ret

00002c38 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2c38:	0e 94 65 15 	call	0x2aca	; 0x2aca <vPortYieldFromTick>
		asm volatile ( "reti" );
    2c3c:	18 95       	reti

00002c3e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2c3e:	df 93       	push	r29
    2c40:	cf 93       	push	r28
    2c42:	cd b7       	in	r28, 0x3d	; 61
    2c44:	de b7       	in	r29, 0x3e	; 62
    2c46:	28 97       	sbiw	r28, 0x08	; 8
    2c48:	0f b6       	in	r0, 0x3f	; 63
    2c4a:	f8 94       	cli
    2c4c:	de bf       	out	0x3e, r29	; 62
    2c4e:	0f be       	out	0x3f, r0	; 63
    2c50:	cd bf       	out	0x3d, r28	; 61
    2c52:	8f 83       	std	Y+7, r24	; 0x07
    2c54:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2c56:	1a 82       	std	Y+2, r1	; 0x02
    2c58:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2c5a:	8f 81       	ldd	r24, Y+7	; 0x07
    2c5c:	88 23       	and	r24, r24
    2c5e:	09 f4       	brne	.+2      	; 0x2c62 <xQueueCreate+0x24>
    2c60:	8c c0       	rjmp	.+280    	; 0x2d7a <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2c62:	8f e1       	ldi	r24, 0x1F	; 31
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	0e 94 98 11 	call	0x2330	; 0x2330 <pvPortMalloc>
    2c6a:	9e 83       	std	Y+6, r25	; 0x06
    2c6c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2c6e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c70:	9e 81       	ldd	r25, Y+6	; 0x06
    2c72:	00 97       	sbiw	r24, 0x00	; 0
    2c74:	09 f4       	brne	.+2      	; 0x2c78 <xQueueCreate+0x3a>
    2c76:	81 c0       	rjmp	.+258    	; 0x2d7a <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2c78:	8f 81       	ldd	r24, Y+7	; 0x07
    2c7a:	28 2f       	mov	r18, r24
    2c7c:	30 e0       	ldi	r19, 0x00	; 0
    2c7e:	88 85       	ldd	r24, Y+8	; 0x08
    2c80:	88 2f       	mov	r24, r24
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	ac 01       	movw	r20, r24
    2c86:	24 9f       	mul	r18, r20
    2c88:	c0 01       	movw	r24, r0
    2c8a:	25 9f       	mul	r18, r21
    2c8c:	90 0d       	add	r25, r0
    2c8e:	34 9f       	mul	r19, r20
    2c90:	90 0d       	add	r25, r0
    2c92:	11 24       	eor	r1, r1
    2c94:	01 96       	adiw	r24, 0x01	; 1
    2c96:	9c 83       	std	Y+4, r25	; 0x04
    2c98:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9e:	0e 94 98 11 	call	0x2330	; 0x2330 <pvPortMalloc>
    2ca2:	ed 81       	ldd	r30, Y+5	; 0x05
    2ca4:	fe 81       	ldd	r31, Y+6	; 0x06
    2ca6:	91 83       	std	Z+1, r25	; 0x01
    2ca8:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2caa:	ed 81       	ldd	r30, Y+5	; 0x05
    2cac:	fe 81       	ldd	r31, Y+6	; 0x06
    2cae:	80 81       	ld	r24, Z
    2cb0:	91 81       	ldd	r25, Z+1	; 0x01
    2cb2:	00 97       	sbiw	r24, 0x00	; 0
    2cb4:	09 f4       	brne	.+2      	; 0x2cb8 <xQueueCreate+0x7a>
    2cb6:	5d c0       	rjmp	.+186    	; 0x2d72 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2cb8:	ed 81       	ldd	r30, Y+5	; 0x05
    2cba:	fe 81       	ldd	r31, Y+6	; 0x06
    2cbc:	40 81       	ld	r20, Z
    2cbe:	51 81       	ldd	r21, Z+1	; 0x01
    2cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    2cc2:	28 2f       	mov	r18, r24
    2cc4:	30 e0       	ldi	r19, 0x00	; 0
    2cc6:	88 85       	ldd	r24, Y+8	; 0x08
    2cc8:	88 2f       	mov	r24, r24
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	bc 01       	movw	r22, r24
    2cce:	26 9f       	mul	r18, r22
    2cd0:	c0 01       	movw	r24, r0
    2cd2:	27 9f       	mul	r18, r23
    2cd4:	90 0d       	add	r25, r0
    2cd6:	36 9f       	mul	r19, r22
    2cd8:	90 0d       	add	r25, r0
    2cda:	11 24       	eor	r1, r1
    2cdc:	84 0f       	add	r24, r20
    2cde:	95 1f       	adc	r25, r21
    2ce0:	ed 81       	ldd	r30, Y+5	; 0x05
    2ce2:	fe 81       	ldd	r31, Y+6	; 0x06
    2ce4:	93 83       	std	Z+3, r25	; 0x03
    2ce6:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2ce8:	ed 81       	ldd	r30, Y+5	; 0x05
    2cea:	fe 81       	ldd	r31, Y+6	; 0x06
    2cec:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2cee:	ed 81       	ldd	r30, Y+5	; 0x05
    2cf0:	fe 81       	ldd	r31, Y+6	; 0x06
    2cf2:	80 81       	ld	r24, Z
    2cf4:	91 81       	ldd	r25, Z+1	; 0x01
    2cf6:	ed 81       	ldd	r30, Y+5	; 0x05
    2cf8:	fe 81       	ldd	r31, Y+6	; 0x06
    2cfa:	95 83       	std	Z+5, r25	; 0x05
    2cfc:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2cfe:	ed 81       	ldd	r30, Y+5	; 0x05
    2d00:	fe 81       	ldd	r31, Y+6	; 0x06
    2d02:	40 81       	ld	r20, Z
    2d04:	51 81       	ldd	r21, Z+1	; 0x01
    2d06:	8f 81       	ldd	r24, Y+7	; 0x07
    2d08:	88 2f       	mov	r24, r24
    2d0a:	90 e0       	ldi	r25, 0x00	; 0
    2d0c:	9c 01       	movw	r18, r24
    2d0e:	21 50       	subi	r18, 0x01	; 1
    2d10:	30 40       	sbci	r19, 0x00	; 0
    2d12:	88 85       	ldd	r24, Y+8	; 0x08
    2d14:	88 2f       	mov	r24, r24
    2d16:	90 e0       	ldi	r25, 0x00	; 0
    2d18:	bc 01       	movw	r22, r24
    2d1a:	26 9f       	mul	r18, r22
    2d1c:	c0 01       	movw	r24, r0
    2d1e:	27 9f       	mul	r18, r23
    2d20:	90 0d       	add	r25, r0
    2d22:	36 9f       	mul	r19, r22
    2d24:	90 0d       	add	r25, r0
    2d26:	11 24       	eor	r1, r1
    2d28:	84 0f       	add	r24, r20
    2d2a:	95 1f       	adc	r25, r21
    2d2c:	ed 81       	ldd	r30, Y+5	; 0x05
    2d2e:	fe 81       	ldd	r31, Y+6	; 0x06
    2d30:	97 83       	std	Z+7, r25	; 0x07
    2d32:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2d34:	ed 81       	ldd	r30, Y+5	; 0x05
    2d36:	fe 81       	ldd	r31, Y+6	; 0x06
    2d38:	8f 81       	ldd	r24, Y+7	; 0x07
    2d3a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2d3c:	ed 81       	ldd	r30, Y+5	; 0x05
    2d3e:	fe 81       	ldd	r31, Y+6	; 0x06
    2d40:	88 85       	ldd	r24, Y+8	; 0x08
    2d42:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2d44:	ed 81       	ldd	r30, Y+5	; 0x05
    2d46:	fe 81       	ldd	r31, Y+6	; 0x06
    2d48:	8f ef       	ldi	r24, 0xFF	; 255
    2d4a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2d4c:	ed 81       	ldd	r30, Y+5	; 0x05
    2d4e:	fe 81       	ldd	r31, Y+6	; 0x06
    2d50:	8f ef       	ldi	r24, 0xFF	; 255
    2d52:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2d54:	8d 81       	ldd	r24, Y+5	; 0x05
    2d56:	9e 81       	ldd	r25, Y+6	; 0x06
    2d58:	08 96       	adiw	r24, 0x08	; 8
    2d5a:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2d5e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d60:	9e 81       	ldd	r25, Y+6	; 0x06
    2d62:	41 96       	adiw	r24, 0x11	; 17
    2d64:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2d68:	8d 81       	ldd	r24, Y+5	; 0x05
    2d6a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d6c:	9a 83       	std	Y+2, r25	; 0x02
    2d6e:	89 83       	std	Y+1, r24	; 0x01
    2d70:	04 c0       	rjmp	.+8      	; 0x2d7a <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2d72:	8d 81       	ldd	r24, Y+5	; 0x05
    2d74:	9e 81       	ldd	r25, Y+6	; 0x06
    2d76:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2d7a:	89 81       	ldd	r24, Y+1	; 0x01
    2d7c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d7e:	28 96       	adiw	r28, 0x08	; 8
    2d80:	0f b6       	in	r0, 0x3f	; 63
    2d82:	f8 94       	cli
    2d84:	de bf       	out	0x3e, r29	; 62
    2d86:	0f be       	out	0x3f, r0	; 63
    2d88:	cd bf       	out	0x3d, r28	; 61
    2d8a:	cf 91       	pop	r28
    2d8c:	df 91       	pop	r29
    2d8e:	08 95       	ret

00002d90 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2d90:	df 93       	push	r29
    2d92:	cf 93       	push	r28
    2d94:	cd b7       	in	r28, 0x3d	; 61
    2d96:	de b7       	in	r29, 0x3e	; 62
    2d98:	2c 97       	sbiw	r28, 0x0c	; 12
    2d9a:	0f b6       	in	r0, 0x3f	; 63
    2d9c:	f8 94       	cli
    2d9e:	de bf       	out	0x3e, r29	; 62
    2da0:	0f be       	out	0x3f, r0	; 63
    2da2:	cd bf       	out	0x3d, r28	; 61
    2da4:	9e 83       	std	Y+6, r25	; 0x06
    2da6:	8d 83       	std	Y+5, r24	; 0x05
    2da8:	78 87       	std	Y+8, r23	; 0x08
    2daa:	6f 83       	std	Y+7, r22	; 0x07
    2dac:	5a 87       	std	Y+10, r21	; 0x0a
    2dae:	49 87       	std	Y+9, r20	; 0x09
    2db0:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2db2:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2db4:	0f b6       	in	r0, 0x3f	; 63
    2db6:	f8 94       	cli
    2db8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2dba:	ed 81       	ldd	r30, Y+5	; 0x05
    2dbc:	fe 81       	ldd	r31, Y+6	; 0x06
    2dbe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2dc0:	ed 81       	ldd	r30, Y+5	; 0x05
    2dc2:	fe 81       	ldd	r31, Y+6	; 0x06
    2dc4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2dc6:	98 17       	cp	r25, r24
    2dc8:	d8 f4       	brcc	.+54     	; 0x2e00 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2dca:	8d 81       	ldd	r24, Y+5	; 0x05
    2dcc:	9e 81       	ldd	r25, Y+6	; 0x06
    2dce:	2f 81       	ldd	r18, Y+7	; 0x07
    2dd0:	38 85       	ldd	r19, Y+8	; 0x08
    2dd2:	b9 01       	movw	r22, r18
    2dd4:	4b 85       	ldd	r20, Y+11	; 0x0b
    2dd6:	0e 94 03 19 	call	0x3206	; 0x3206 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2dda:	ed 81       	ldd	r30, Y+5	; 0x05
    2ddc:	fe 81       	ldd	r31, Y+6	; 0x06
    2dde:	81 89       	ldd	r24, Z+17	; 0x11
    2de0:	88 23       	and	r24, r24
    2de2:	49 f0       	breq	.+18     	; 0x2df6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2de4:	8d 81       	ldd	r24, Y+5	; 0x05
    2de6:	9e 81       	ldd	r25, Y+6	; 0x06
    2de8:	41 96       	adiw	r24, 0x11	; 17
    2dea:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    2dee:	81 30       	cpi	r24, 0x01	; 1
    2df0:	11 f4       	brne	.+4      	; 0x2df6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2df2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2df6:	0f 90       	pop	r0
    2df8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2dfa:	81 e0       	ldi	r24, 0x01	; 1
    2dfc:	8c 87       	std	Y+12, r24	; 0x0c
    2dfe:	5c c0       	rjmp	.+184    	; 0x2eb8 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2e00:	89 85       	ldd	r24, Y+9	; 0x09
    2e02:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e04:	00 97       	sbiw	r24, 0x00	; 0
    2e06:	21 f4       	brne	.+8      	; 0x2e10 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2e08:	0f 90       	pop	r0
    2e0a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2e0c:	1c 86       	std	Y+12, r1	; 0x0c
    2e0e:	54 c0       	rjmp	.+168    	; 0x2eb8 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	88 23       	and	r24, r24
    2e14:	31 f4       	brne	.+12     	; 0x2e22 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2e16:	ce 01       	movw	r24, r28
    2e18:	02 96       	adiw	r24, 0x02	; 2
    2e1a:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2e22:	0f 90       	pop	r0
    2e24:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2e26:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2e2a:	0f b6       	in	r0, 0x3f	; 63
    2e2c:	f8 94       	cli
    2e2e:	0f 92       	push	r0
    2e30:	ed 81       	ldd	r30, Y+5	; 0x05
    2e32:	fe 81       	ldd	r31, Y+6	; 0x06
    2e34:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e36:	8f 3f       	cpi	r24, 0xFF	; 255
    2e38:	19 f4       	brne	.+6      	; 0x2e40 <xQueueGenericSend+0xb0>
    2e3a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e3c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e3e:	15 8e       	std	Z+29, r1	; 0x1d
    2e40:	ed 81       	ldd	r30, Y+5	; 0x05
    2e42:	fe 81       	ldd	r31, Y+6	; 0x06
    2e44:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e46:	8f 3f       	cpi	r24, 0xFF	; 255
    2e48:	19 f4       	brne	.+6      	; 0x2e50 <xQueueGenericSend+0xc0>
    2e4a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e4c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e4e:	16 8e       	std	Z+30, r1	; 0x1e
    2e50:	0f 90       	pop	r0
    2e52:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e54:	ce 01       	movw	r24, r28
    2e56:	02 96       	adiw	r24, 0x02	; 2
    2e58:	9e 01       	movw	r18, r28
    2e5a:	27 5f       	subi	r18, 0xF7	; 247
    2e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e5e:	b9 01       	movw	r22, r18
    2e60:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <xTaskCheckForTimeOut>
    2e64:	88 23       	and	r24, r24
    2e66:	09 f5       	brne	.+66     	; 0x2eaa <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2e68:	8d 81       	ldd	r24, Y+5	; 0x05
    2e6a:	9e 81       	ldd	r25, Y+6	; 0x06
    2e6c:	0e 94 67 1a 	call	0x34ce	; 0x34ce <prvIsQueueFull>
    2e70:	88 23       	and	r24, r24
    2e72:	a1 f0       	breq	.+40     	; 0x2e9c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2e74:	8d 81       	ldd	r24, Y+5	; 0x05
    2e76:	9e 81       	ldd	r25, Y+6	; 0x06
    2e78:	08 96       	adiw	r24, 0x08	; 8
    2e7a:	29 85       	ldd	r18, Y+9	; 0x09
    2e7c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2e7e:	b9 01       	movw	r22, r18
    2e80:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2e84:	8d 81       	ldd	r24, Y+5	; 0x05
    2e86:	9e 81       	ldd	r25, Y+6	; 0x06
    2e88:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2e8c:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    2e90:	88 23       	and	r24, r24
    2e92:	09 f0       	breq	.+2      	; 0x2e96 <xQueueGenericSend+0x106>
    2e94:	8f cf       	rjmp	.-226    	; 0x2db4 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2e96:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
    2e9a:	8c cf       	rjmp	.-232    	; 0x2db4 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2e9c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e9e:	9e 81       	ldd	r25, Y+6	; 0x06
    2ea0:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2ea4:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    2ea8:	85 cf       	rjmp	.-246    	; 0x2db4 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    2eac:	9e 81       	ldd	r25, Y+6	; 0x06
    2eae:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2eb2:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2eb6:	1c 86       	std	Y+12, r1	; 0x0c
    2eb8:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    2eba:	2c 96       	adiw	r28, 0x0c	; 12
    2ebc:	0f b6       	in	r0, 0x3f	; 63
    2ebe:	f8 94       	cli
    2ec0:	de bf       	out	0x3e, r29	; 62
    2ec2:	0f be       	out	0x3f, r0	; 63
    2ec4:	cd bf       	out	0x3d, r28	; 61
    2ec6:	cf 91       	pop	r28
    2ec8:	df 91       	pop	r29
    2eca:	08 95       	ret

00002ecc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2ecc:	df 93       	push	r29
    2ece:	cf 93       	push	r28
    2ed0:	cd b7       	in	r28, 0x3d	; 61
    2ed2:	de b7       	in	r29, 0x3e	; 62
    2ed4:	29 97       	sbiw	r28, 0x09	; 9
    2ed6:	0f b6       	in	r0, 0x3f	; 63
    2ed8:	f8 94       	cli
    2eda:	de bf       	out	0x3e, r29	; 62
    2edc:	0f be       	out	0x3f, r0	; 63
    2ede:	cd bf       	out	0x3d, r28	; 61
    2ee0:	9c 83       	std	Y+4, r25	; 0x04
    2ee2:	8b 83       	std	Y+3, r24	; 0x03
    2ee4:	7e 83       	std	Y+6, r23	; 0x06
    2ee6:	6d 83       	std	Y+5, r22	; 0x05
    2ee8:	58 87       	std	Y+8, r21	; 0x08
    2eea:	4f 83       	std	Y+7, r20	; 0x07
    2eec:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2eee:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ef6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef8:	fc 81       	ldd	r31, Y+4	; 0x04
    2efa:	83 8d       	ldd	r24, Z+27	; 0x1b
    2efc:	98 17       	cp	r25, r24
    2efe:	40 f5       	brcc	.+80     	; 0x2f50 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f00:	8b 81       	ldd	r24, Y+3	; 0x03
    2f02:	9c 81       	ldd	r25, Y+4	; 0x04
    2f04:	2d 81       	ldd	r18, Y+5	; 0x05
    2f06:	3e 81       	ldd	r19, Y+6	; 0x06
    2f08:	b9 01       	movw	r22, r18
    2f0a:	49 85       	ldd	r20, Y+9	; 0x09
    2f0c:	0e 94 03 19 	call	0x3206	; 0x3206 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2f10:	eb 81       	ldd	r30, Y+3	; 0x03
    2f12:	fc 81       	ldd	r31, Y+4	; 0x04
    2f14:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f16:	8f 3f       	cpi	r24, 0xFF	; 255
    2f18:	89 f4       	brne	.+34     	; 0x2f3c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f1e:	81 89       	ldd	r24, Z+17	; 0x11
    2f20:	88 23       	and	r24, r24
    2f22:	99 f0       	breq	.+38     	; 0x2f4a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f24:	8b 81       	ldd	r24, Y+3	; 0x03
    2f26:	9c 81       	ldd	r25, Y+4	; 0x04
    2f28:	41 96       	adiw	r24, 0x11	; 17
    2f2a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    2f2e:	88 23       	and	r24, r24
    2f30:	61 f0       	breq	.+24     	; 0x2f4a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2f32:	ef 81       	ldd	r30, Y+7	; 0x07
    2f34:	f8 85       	ldd	r31, Y+8	; 0x08
    2f36:	81 e0       	ldi	r24, 0x01	; 1
    2f38:	80 83       	st	Z, r24
    2f3a:	07 c0       	rjmp	.+14     	; 0x2f4a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f40:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f42:	8f 5f       	subi	r24, 0xFF	; 255
    2f44:	eb 81       	ldd	r30, Y+3	; 0x03
    2f46:	fc 81       	ldd	r31, Y+4	; 0x04
    2f48:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2f4a:	81 e0       	ldi	r24, 0x01	; 1
    2f4c:	8a 83       	std	Y+2, r24	; 0x02
    2f4e:	01 c0       	rjmp	.+2      	; 0x2f52 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2f50:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2f52:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2f54:	29 96       	adiw	r28, 0x09	; 9
    2f56:	0f b6       	in	r0, 0x3f	; 63
    2f58:	f8 94       	cli
    2f5a:	de bf       	out	0x3e, r29	; 62
    2f5c:	0f be       	out	0x3f, r0	; 63
    2f5e:	cd bf       	out	0x3d, r28	; 61
    2f60:	cf 91       	pop	r28
    2f62:	df 91       	pop	r29
    2f64:	08 95       	ret

00002f66 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2f66:	df 93       	push	r29
    2f68:	cf 93       	push	r28
    2f6a:	cd b7       	in	r28, 0x3d	; 61
    2f6c:	de b7       	in	r29, 0x3e	; 62
    2f6e:	2e 97       	sbiw	r28, 0x0e	; 14
    2f70:	0f b6       	in	r0, 0x3f	; 63
    2f72:	f8 94       	cli
    2f74:	de bf       	out	0x3e, r29	; 62
    2f76:	0f be       	out	0x3f, r0	; 63
    2f78:	cd bf       	out	0x3d, r28	; 61
    2f7a:	98 87       	std	Y+8, r25	; 0x08
    2f7c:	8f 83       	std	Y+7, r24	; 0x07
    2f7e:	7a 87       	std	Y+10, r23	; 0x0a
    2f80:	69 87       	std	Y+9, r22	; 0x09
    2f82:	5c 87       	std	Y+12, r21	; 0x0c
    2f84:	4b 87       	std	Y+11, r20	; 0x0b
    2f86:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2f88:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2f8a:	0f b6       	in	r0, 0x3f	; 63
    2f8c:	f8 94       	cli
    2f8e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2f90:	ef 81       	ldd	r30, Y+7	; 0x07
    2f92:	f8 85       	ldd	r31, Y+8	; 0x08
    2f94:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f96:	88 23       	and	r24, r24
    2f98:	09 f4       	brne	.+2      	; 0x2f9c <xQueueGenericReceive+0x36>
    2f9a:	3f c0       	rjmp	.+126    	; 0x301a <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2f9c:	ef 81       	ldd	r30, Y+7	; 0x07
    2f9e:	f8 85       	ldd	r31, Y+8	; 0x08
    2fa0:	86 81       	ldd	r24, Z+6	; 0x06
    2fa2:	97 81       	ldd	r25, Z+7	; 0x07
    2fa4:	9a 83       	std	Y+2, r25	; 0x02
    2fa6:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2fa8:	8f 81       	ldd	r24, Y+7	; 0x07
    2faa:	98 85       	ldd	r25, Y+8	; 0x08
    2fac:	29 85       	ldd	r18, Y+9	; 0x09
    2fae:	3a 85       	ldd	r19, Y+10	; 0x0a
    2fb0:	b9 01       	movw	r22, r18
    2fb2:	0e 94 98 19 	call	0x3330	; 0x3330 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2fb6:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fb8:	88 23       	and	r24, r24
    2fba:	b1 f4       	brne	.+44     	; 0x2fe8 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2fbc:	ef 81       	ldd	r30, Y+7	; 0x07
    2fbe:	f8 85       	ldd	r31, Y+8	; 0x08
    2fc0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fc2:	81 50       	subi	r24, 0x01	; 1
    2fc4:	ef 81       	ldd	r30, Y+7	; 0x07
    2fc6:	f8 85       	ldd	r31, Y+8	; 0x08
    2fc8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2fca:	ef 81       	ldd	r30, Y+7	; 0x07
    2fcc:	f8 85       	ldd	r31, Y+8	; 0x08
    2fce:	80 85       	ldd	r24, Z+8	; 0x08
    2fd0:	88 23       	and	r24, r24
    2fd2:	f1 f0       	breq	.+60     	; 0x3010 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2fd4:	8f 81       	ldd	r24, Y+7	; 0x07
    2fd6:	98 85       	ldd	r25, Y+8	; 0x08
    2fd8:	08 96       	adiw	r24, 0x08	; 8
    2fda:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    2fde:	81 30       	cpi	r24, 0x01	; 1
    2fe0:	b9 f4       	brne	.+46     	; 0x3010 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    2fe2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
    2fe6:	14 c0       	rjmp	.+40     	; 0x3010 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2fe8:	ef 81       	ldd	r30, Y+7	; 0x07
    2fea:	f8 85       	ldd	r31, Y+8	; 0x08
    2fec:	89 81       	ldd	r24, Y+1	; 0x01
    2fee:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff0:	97 83       	std	Z+7, r25	; 0x07
    2ff2:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ff4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ff6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ff8:	81 89       	ldd	r24, Z+17	; 0x11
    2ffa:	88 23       	and	r24, r24
    2ffc:	49 f0       	breq	.+18     	; 0x3010 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ffe:	8f 81       	ldd	r24, Y+7	; 0x07
    3000:	98 85       	ldd	r25, Y+8	; 0x08
    3002:	41 96       	adiw	r24, 0x11	; 17
    3004:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    3008:	88 23       	and	r24, r24
    300a:	11 f0       	breq	.+4      	; 0x3010 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    300c:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3010:	0f 90       	pop	r0
    3012:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3014:	81 e0       	ldi	r24, 0x01	; 1
    3016:	8e 87       	std	Y+14, r24	; 0x0e
    3018:	5c c0       	rjmp	.+184    	; 0x30d2 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    301a:	8b 85       	ldd	r24, Y+11	; 0x0b
    301c:	9c 85       	ldd	r25, Y+12	; 0x0c
    301e:	00 97       	sbiw	r24, 0x00	; 0
    3020:	21 f4       	brne	.+8      	; 0x302a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3022:	0f 90       	pop	r0
    3024:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3026:	1e 86       	std	Y+14, r1	; 0x0e
    3028:	54 c0       	rjmp	.+168    	; 0x30d2 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    302a:	8b 81       	ldd	r24, Y+3	; 0x03
    302c:	88 23       	and	r24, r24
    302e:	31 f4       	brne	.+12     	; 0x303c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3030:	ce 01       	movw	r24, r28
    3032:	04 96       	adiw	r24, 0x04	; 4
    3034:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    303c:	0f 90       	pop	r0
    303e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3040:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3044:	0f b6       	in	r0, 0x3f	; 63
    3046:	f8 94       	cli
    3048:	0f 92       	push	r0
    304a:	ef 81       	ldd	r30, Y+7	; 0x07
    304c:	f8 85       	ldd	r31, Y+8	; 0x08
    304e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3050:	8f 3f       	cpi	r24, 0xFF	; 255
    3052:	19 f4       	brne	.+6      	; 0x305a <xQueueGenericReceive+0xf4>
    3054:	ef 81       	ldd	r30, Y+7	; 0x07
    3056:	f8 85       	ldd	r31, Y+8	; 0x08
    3058:	15 8e       	std	Z+29, r1	; 0x1d
    305a:	ef 81       	ldd	r30, Y+7	; 0x07
    305c:	f8 85       	ldd	r31, Y+8	; 0x08
    305e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3060:	8f 3f       	cpi	r24, 0xFF	; 255
    3062:	19 f4       	brne	.+6      	; 0x306a <xQueueGenericReceive+0x104>
    3064:	ef 81       	ldd	r30, Y+7	; 0x07
    3066:	f8 85       	ldd	r31, Y+8	; 0x08
    3068:	16 8e       	std	Z+30, r1	; 0x1e
    306a:	0f 90       	pop	r0
    306c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    306e:	ce 01       	movw	r24, r28
    3070:	04 96       	adiw	r24, 0x04	; 4
    3072:	9e 01       	movw	r18, r28
    3074:	25 5f       	subi	r18, 0xF5	; 245
    3076:	3f 4f       	sbci	r19, 0xFF	; 255
    3078:	b9 01       	movw	r22, r18
    307a:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <xTaskCheckForTimeOut>
    307e:	88 23       	and	r24, r24
    3080:	09 f5       	brne	.+66     	; 0x30c4 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3082:	8f 81       	ldd	r24, Y+7	; 0x07
    3084:	98 85       	ldd	r25, Y+8	; 0x08
    3086:	0e 94 34 1a 	call	0x3468	; 0x3468 <prvIsQueueEmpty>
    308a:	88 23       	and	r24, r24
    308c:	a1 f0       	breq	.+40     	; 0x30b6 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    308e:	8f 81       	ldd	r24, Y+7	; 0x07
    3090:	98 85       	ldd	r25, Y+8	; 0x08
    3092:	41 96       	adiw	r24, 0x11	; 17
    3094:	2b 85       	ldd	r18, Y+11	; 0x0b
    3096:	3c 85       	ldd	r19, Y+12	; 0x0c
    3098:	b9 01       	movw	r22, r18
    309a:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    309e:	8f 81       	ldd	r24, Y+7	; 0x07
    30a0:	98 85       	ldd	r25, Y+8	; 0x08
    30a2:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    30a6:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    30aa:	88 23       	and	r24, r24
    30ac:	09 f0       	breq	.+2      	; 0x30b0 <xQueueGenericReceive+0x14a>
    30ae:	6d cf       	rjmp	.-294    	; 0x2f8a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    30b0:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
    30b4:	6a cf       	rjmp	.-300    	; 0x2f8a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    30b6:	8f 81       	ldd	r24, Y+7	; 0x07
    30b8:	98 85       	ldd	r25, Y+8	; 0x08
    30ba:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    30be:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    30c2:	63 cf       	rjmp	.-314    	; 0x2f8a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    30c4:	8f 81       	ldd	r24, Y+7	; 0x07
    30c6:	98 85       	ldd	r25, Y+8	; 0x08
    30c8:	0e 94 e0 19 	call	0x33c0	; 0x33c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    30cc:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    30d0:	1e 86       	std	Y+14, r1	; 0x0e
    30d2:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    30d4:	2e 96       	adiw	r28, 0x0e	; 14
    30d6:	0f b6       	in	r0, 0x3f	; 63
    30d8:	f8 94       	cli
    30da:	de bf       	out	0x3e, r29	; 62
    30dc:	0f be       	out	0x3f, r0	; 63
    30de:	cd bf       	out	0x3d, r28	; 61
    30e0:	cf 91       	pop	r28
    30e2:	df 91       	pop	r29
    30e4:	08 95       	ret

000030e6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    30e6:	df 93       	push	r29
    30e8:	cf 93       	push	r28
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	28 97       	sbiw	r28, 0x08	; 8
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	f8 94       	cli
    30f4:	de bf       	out	0x3e, r29	; 62
    30f6:	0f be       	out	0x3f, r0	; 63
    30f8:	cd bf       	out	0x3d, r28	; 61
    30fa:	9c 83       	std	Y+4, r25	; 0x04
    30fc:	8b 83       	std	Y+3, r24	; 0x03
    30fe:	7e 83       	std	Y+6, r23	; 0x06
    3100:	6d 83       	std	Y+5, r22	; 0x05
    3102:	58 87       	std	Y+8, r21	; 0x08
    3104:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3106:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3108:	eb 81       	ldd	r30, Y+3	; 0x03
    310a:	fc 81       	ldd	r31, Y+4	; 0x04
    310c:	82 8d       	ldd	r24, Z+26	; 0x1a
    310e:	88 23       	and	r24, r24
    3110:	71 f1       	breq	.+92     	; 0x316e <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3112:	8b 81       	ldd	r24, Y+3	; 0x03
    3114:	9c 81       	ldd	r25, Y+4	; 0x04
    3116:	2d 81       	ldd	r18, Y+5	; 0x05
    3118:	3e 81       	ldd	r19, Y+6	; 0x06
    311a:	b9 01       	movw	r22, r18
    311c:	0e 94 98 19 	call	0x3330	; 0x3330 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3120:	eb 81       	ldd	r30, Y+3	; 0x03
    3122:	fc 81       	ldd	r31, Y+4	; 0x04
    3124:	82 8d       	ldd	r24, Z+26	; 0x1a
    3126:	81 50       	subi	r24, 0x01	; 1
    3128:	eb 81       	ldd	r30, Y+3	; 0x03
    312a:	fc 81       	ldd	r31, Y+4	; 0x04
    312c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    312e:	eb 81       	ldd	r30, Y+3	; 0x03
    3130:	fc 81       	ldd	r31, Y+4	; 0x04
    3132:	85 8d       	ldd	r24, Z+29	; 0x1d
    3134:	8f 3f       	cpi	r24, 0xFF	; 255
    3136:	89 f4       	brne	.+34     	; 0x315a <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3138:	eb 81       	ldd	r30, Y+3	; 0x03
    313a:	fc 81       	ldd	r31, Y+4	; 0x04
    313c:	80 85       	ldd	r24, Z+8	; 0x08
    313e:	88 23       	and	r24, r24
    3140:	99 f0       	breq	.+38     	; 0x3168 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3142:	8b 81       	ldd	r24, Y+3	; 0x03
    3144:	9c 81       	ldd	r25, Y+4	; 0x04
    3146:	08 96       	adiw	r24, 0x08	; 8
    3148:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    314c:	88 23       	and	r24, r24
    314e:	61 f0       	breq	.+24     	; 0x3168 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3150:	ef 81       	ldd	r30, Y+7	; 0x07
    3152:	f8 85       	ldd	r31, Y+8	; 0x08
    3154:	81 e0       	ldi	r24, 0x01	; 1
    3156:	80 83       	st	Z, r24
    3158:	07 c0       	rjmp	.+14     	; 0x3168 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    315a:	eb 81       	ldd	r30, Y+3	; 0x03
    315c:	fc 81       	ldd	r31, Y+4	; 0x04
    315e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3160:	8f 5f       	subi	r24, 0xFF	; 255
    3162:	eb 81       	ldd	r30, Y+3	; 0x03
    3164:	fc 81       	ldd	r31, Y+4	; 0x04
    3166:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	8a 83       	std	Y+2, r24	; 0x02
    316c:	01 c0       	rjmp	.+2      	; 0x3170 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    316e:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3170:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3172:	28 96       	adiw	r28, 0x08	; 8
    3174:	0f b6       	in	r0, 0x3f	; 63
    3176:	f8 94       	cli
    3178:	de bf       	out	0x3e, r29	; 62
    317a:	0f be       	out	0x3f, r0	; 63
    317c:	cd bf       	out	0x3d, r28	; 61
    317e:	cf 91       	pop	r28
    3180:	df 91       	pop	r29
    3182:	08 95       	ret

00003184 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3184:	df 93       	push	r29
    3186:	cf 93       	push	r28
    3188:	00 d0       	rcall	.+0      	; 0x318a <uxQueueMessagesWaiting+0x6>
    318a:	0f 92       	push	r0
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	9b 83       	std	Y+3, r25	; 0x03
    3192:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3194:	0f b6       	in	r0, 0x3f	; 63
    3196:	f8 94       	cli
    3198:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    319a:	ea 81       	ldd	r30, Y+2	; 0x02
    319c:	fb 81       	ldd	r31, Y+3	; 0x03
    319e:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    31a2:	0f 90       	pop	r0
    31a4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    31a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    31a8:	0f 90       	pop	r0
    31aa:	0f 90       	pop	r0
    31ac:	0f 90       	pop	r0
    31ae:	cf 91       	pop	r28
    31b0:	df 91       	pop	r29
    31b2:	08 95       	ret

000031b4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    31b4:	df 93       	push	r29
    31b6:	cf 93       	push	r28
    31b8:	00 d0       	rcall	.+0      	; 0x31ba <uxQueueMessagesWaitingFromISR+0x6>
    31ba:	0f 92       	push	r0
    31bc:	cd b7       	in	r28, 0x3d	; 61
    31be:	de b7       	in	r29, 0x3e	; 62
    31c0:	9b 83       	std	Y+3, r25	; 0x03
    31c2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    31c4:	ea 81       	ldd	r30, Y+2	; 0x02
    31c6:	fb 81       	ldd	r31, Y+3	; 0x03
    31c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    31ca:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    31cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    31ce:	0f 90       	pop	r0
    31d0:	0f 90       	pop	r0
    31d2:	0f 90       	pop	r0
    31d4:	cf 91       	pop	r28
    31d6:	df 91       	pop	r29
    31d8:	08 95       	ret

000031da <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    31da:	df 93       	push	r29
    31dc:	cf 93       	push	r28
    31de:	00 d0       	rcall	.+0      	; 0x31e0 <vQueueDelete+0x6>
    31e0:	cd b7       	in	r28, 0x3d	; 61
    31e2:	de b7       	in	r29, 0x3e	; 62
    31e4:	9a 83       	std	Y+2, r25	; 0x02
    31e6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    31e8:	e9 81       	ldd	r30, Y+1	; 0x01
    31ea:	fa 81       	ldd	r31, Y+2	; 0x02
    31ec:	80 81       	ld	r24, Z
    31ee:	91 81       	ldd	r25, Z+1	; 0x01
    31f0:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
	vPortFree( pxQueue );
    31f4:	89 81       	ldd	r24, Y+1	; 0x01
    31f6:	9a 81       	ldd	r25, Y+2	; 0x02
    31f8:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
}
    31fc:	0f 90       	pop	r0
    31fe:	0f 90       	pop	r0
    3200:	cf 91       	pop	r28
    3202:	df 91       	pop	r29
    3204:	08 95       	ret

00003206 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3206:	df 93       	push	r29
    3208:	cf 93       	push	r28
    320a:	00 d0       	rcall	.+0      	; 0x320c <prvCopyDataToQueue+0x6>
    320c:	00 d0       	rcall	.+0      	; 0x320e <prvCopyDataToQueue+0x8>
    320e:	0f 92       	push	r0
    3210:	cd b7       	in	r28, 0x3d	; 61
    3212:	de b7       	in	r29, 0x3e	; 62
    3214:	9a 83       	std	Y+2, r25	; 0x02
    3216:	89 83       	std	Y+1, r24	; 0x01
    3218:	7c 83       	std	Y+4, r23	; 0x04
    321a:	6b 83       	std	Y+3, r22	; 0x03
    321c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    321e:	e9 81       	ldd	r30, Y+1	; 0x01
    3220:	fa 81       	ldd	r31, Y+2	; 0x02
    3222:	84 8d       	ldd	r24, Z+28	; 0x1c
    3224:	88 23       	and	r24, r24
    3226:	09 f4       	brne	.+2      	; 0x322a <prvCopyDataToQueue+0x24>
    3228:	74 c0       	rjmp	.+232    	; 0x3312 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    322a:	8d 81       	ldd	r24, Y+5	; 0x05
    322c:	88 23       	and	r24, r24
    322e:	99 f5       	brne	.+102    	; 0x3296 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3230:	e9 81       	ldd	r30, Y+1	; 0x01
    3232:	fa 81       	ldd	r31, Y+2	; 0x02
    3234:	64 81       	ldd	r22, Z+4	; 0x04
    3236:	75 81       	ldd	r23, Z+5	; 0x05
    3238:	e9 81       	ldd	r30, Y+1	; 0x01
    323a:	fa 81       	ldd	r31, Y+2	; 0x02
    323c:	84 8d       	ldd	r24, Z+28	; 0x1c
    323e:	48 2f       	mov	r20, r24
    3240:	50 e0       	ldi	r21, 0x00	; 0
    3242:	2b 81       	ldd	r18, Y+3	; 0x03
    3244:	3c 81       	ldd	r19, Y+4	; 0x04
    3246:	cb 01       	movw	r24, r22
    3248:	b9 01       	movw	r22, r18
    324a:	0e 94 29 24 	call	0x4852	; 0x4852 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    324e:	e9 81       	ldd	r30, Y+1	; 0x01
    3250:	fa 81       	ldd	r31, Y+2	; 0x02
    3252:	24 81       	ldd	r18, Z+4	; 0x04
    3254:	35 81       	ldd	r19, Z+5	; 0x05
    3256:	e9 81       	ldd	r30, Y+1	; 0x01
    3258:	fa 81       	ldd	r31, Y+2	; 0x02
    325a:	84 8d       	ldd	r24, Z+28	; 0x1c
    325c:	88 2f       	mov	r24, r24
    325e:	90 e0       	ldi	r25, 0x00	; 0
    3260:	82 0f       	add	r24, r18
    3262:	93 1f       	adc	r25, r19
    3264:	e9 81       	ldd	r30, Y+1	; 0x01
    3266:	fa 81       	ldd	r31, Y+2	; 0x02
    3268:	95 83       	std	Z+5, r25	; 0x05
    326a:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    326c:	e9 81       	ldd	r30, Y+1	; 0x01
    326e:	fa 81       	ldd	r31, Y+2	; 0x02
    3270:	24 81       	ldd	r18, Z+4	; 0x04
    3272:	35 81       	ldd	r19, Z+5	; 0x05
    3274:	e9 81       	ldd	r30, Y+1	; 0x01
    3276:	fa 81       	ldd	r31, Y+2	; 0x02
    3278:	82 81       	ldd	r24, Z+2	; 0x02
    327a:	93 81       	ldd	r25, Z+3	; 0x03
    327c:	28 17       	cp	r18, r24
    327e:	39 07       	cpc	r19, r25
    3280:	08 f4       	brcc	.+2      	; 0x3284 <prvCopyDataToQueue+0x7e>
    3282:	47 c0       	rjmp	.+142    	; 0x3312 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3284:	e9 81       	ldd	r30, Y+1	; 0x01
    3286:	fa 81       	ldd	r31, Y+2	; 0x02
    3288:	80 81       	ld	r24, Z
    328a:	91 81       	ldd	r25, Z+1	; 0x01
    328c:	e9 81       	ldd	r30, Y+1	; 0x01
    328e:	fa 81       	ldd	r31, Y+2	; 0x02
    3290:	95 83       	std	Z+5, r25	; 0x05
    3292:	84 83       	std	Z+4, r24	; 0x04
    3294:	3e c0       	rjmp	.+124    	; 0x3312 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3296:	e9 81       	ldd	r30, Y+1	; 0x01
    3298:	fa 81       	ldd	r31, Y+2	; 0x02
    329a:	66 81       	ldd	r22, Z+6	; 0x06
    329c:	77 81       	ldd	r23, Z+7	; 0x07
    329e:	e9 81       	ldd	r30, Y+1	; 0x01
    32a0:	fa 81       	ldd	r31, Y+2	; 0x02
    32a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    32a4:	48 2f       	mov	r20, r24
    32a6:	50 e0       	ldi	r21, 0x00	; 0
    32a8:	2b 81       	ldd	r18, Y+3	; 0x03
    32aa:	3c 81       	ldd	r19, Y+4	; 0x04
    32ac:	cb 01       	movw	r24, r22
    32ae:	b9 01       	movw	r22, r18
    32b0:	0e 94 29 24 	call	0x4852	; 0x4852 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    32b4:	e9 81       	ldd	r30, Y+1	; 0x01
    32b6:	fa 81       	ldd	r31, Y+2	; 0x02
    32b8:	26 81       	ldd	r18, Z+6	; 0x06
    32ba:	37 81       	ldd	r19, Z+7	; 0x07
    32bc:	e9 81       	ldd	r30, Y+1	; 0x01
    32be:	fa 81       	ldd	r31, Y+2	; 0x02
    32c0:	84 8d       	ldd	r24, Z+28	; 0x1c
    32c2:	88 2f       	mov	r24, r24
    32c4:	90 e0       	ldi	r25, 0x00	; 0
    32c6:	90 95       	com	r25
    32c8:	81 95       	neg	r24
    32ca:	9f 4f       	sbci	r25, 0xFF	; 255
    32cc:	82 0f       	add	r24, r18
    32ce:	93 1f       	adc	r25, r19
    32d0:	e9 81       	ldd	r30, Y+1	; 0x01
    32d2:	fa 81       	ldd	r31, Y+2	; 0x02
    32d4:	97 83       	std	Z+7, r25	; 0x07
    32d6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    32d8:	e9 81       	ldd	r30, Y+1	; 0x01
    32da:	fa 81       	ldd	r31, Y+2	; 0x02
    32dc:	26 81       	ldd	r18, Z+6	; 0x06
    32de:	37 81       	ldd	r19, Z+7	; 0x07
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	80 81       	ld	r24, Z
    32e6:	91 81       	ldd	r25, Z+1	; 0x01
    32e8:	28 17       	cp	r18, r24
    32ea:	39 07       	cpc	r19, r25
    32ec:	90 f4       	brcc	.+36     	; 0x3312 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    32ee:	e9 81       	ldd	r30, Y+1	; 0x01
    32f0:	fa 81       	ldd	r31, Y+2	; 0x02
    32f2:	22 81       	ldd	r18, Z+2	; 0x02
    32f4:	33 81       	ldd	r19, Z+3	; 0x03
    32f6:	e9 81       	ldd	r30, Y+1	; 0x01
    32f8:	fa 81       	ldd	r31, Y+2	; 0x02
    32fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    32fc:	88 2f       	mov	r24, r24
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	90 95       	com	r25
    3302:	81 95       	neg	r24
    3304:	9f 4f       	sbci	r25, 0xFF	; 255
    3306:	82 0f       	add	r24, r18
    3308:	93 1f       	adc	r25, r19
    330a:	e9 81       	ldd	r30, Y+1	; 0x01
    330c:	fa 81       	ldd	r31, Y+2	; 0x02
    330e:	97 83       	std	Z+7, r25	; 0x07
    3310:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3312:	e9 81       	ldd	r30, Y+1	; 0x01
    3314:	fa 81       	ldd	r31, Y+2	; 0x02
    3316:	82 8d       	ldd	r24, Z+26	; 0x1a
    3318:	8f 5f       	subi	r24, 0xFF	; 255
    331a:	e9 81       	ldd	r30, Y+1	; 0x01
    331c:	fa 81       	ldd	r31, Y+2	; 0x02
    331e:	82 8f       	std	Z+26, r24	; 0x1a
}
    3320:	0f 90       	pop	r0
    3322:	0f 90       	pop	r0
    3324:	0f 90       	pop	r0
    3326:	0f 90       	pop	r0
    3328:	0f 90       	pop	r0
    332a:	cf 91       	pop	r28
    332c:	df 91       	pop	r29
    332e:	08 95       	ret

00003330 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3330:	df 93       	push	r29
    3332:	cf 93       	push	r28
    3334:	00 d0       	rcall	.+0      	; 0x3336 <prvCopyDataFromQueue+0x6>
    3336:	00 d0       	rcall	.+0      	; 0x3338 <prvCopyDataFromQueue+0x8>
    3338:	cd b7       	in	r28, 0x3d	; 61
    333a:	de b7       	in	r29, 0x3e	; 62
    333c:	9a 83       	std	Y+2, r25	; 0x02
    333e:	89 83       	std	Y+1, r24	; 0x01
    3340:	7c 83       	std	Y+4, r23	; 0x04
    3342:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	80 81       	ld	r24, Z
    334a:	91 81       	ldd	r25, Z+1	; 0x01
    334c:	00 97       	sbiw	r24, 0x00	; 0
    334e:	89 f1       	breq	.+98     	; 0x33b2 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3350:	e9 81       	ldd	r30, Y+1	; 0x01
    3352:	fa 81       	ldd	r31, Y+2	; 0x02
    3354:	26 81       	ldd	r18, Z+6	; 0x06
    3356:	37 81       	ldd	r19, Z+7	; 0x07
    3358:	e9 81       	ldd	r30, Y+1	; 0x01
    335a:	fa 81       	ldd	r31, Y+2	; 0x02
    335c:	84 8d       	ldd	r24, Z+28	; 0x1c
    335e:	88 2f       	mov	r24, r24
    3360:	90 e0       	ldi	r25, 0x00	; 0
    3362:	82 0f       	add	r24, r18
    3364:	93 1f       	adc	r25, r19
    3366:	e9 81       	ldd	r30, Y+1	; 0x01
    3368:	fa 81       	ldd	r31, Y+2	; 0x02
    336a:	97 83       	std	Z+7, r25	; 0x07
    336c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    336e:	e9 81       	ldd	r30, Y+1	; 0x01
    3370:	fa 81       	ldd	r31, Y+2	; 0x02
    3372:	26 81       	ldd	r18, Z+6	; 0x06
    3374:	37 81       	ldd	r19, Z+7	; 0x07
    3376:	e9 81       	ldd	r30, Y+1	; 0x01
    3378:	fa 81       	ldd	r31, Y+2	; 0x02
    337a:	82 81       	ldd	r24, Z+2	; 0x02
    337c:	93 81       	ldd	r25, Z+3	; 0x03
    337e:	28 17       	cp	r18, r24
    3380:	39 07       	cpc	r19, r25
    3382:	40 f0       	brcs	.+16     	; 0x3394 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3384:	e9 81       	ldd	r30, Y+1	; 0x01
    3386:	fa 81       	ldd	r31, Y+2	; 0x02
    3388:	80 81       	ld	r24, Z
    338a:	91 81       	ldd	r25, Z+1	; 0x01
    338c:	e9 81       	ldd	r30, Y+1	; 0x01
    338e:	fa 81       	ldd	r31, Y+2	; 0x02
    3390:	97 83       	std	Z+7, r25	; 0x07
    3392:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3394:	e9 81       	ldd	r30, Y+1	; 0x01
    3396:	fa 81       	ldd	r31, Y+2	; 0x02
    3398:	46 81       	ldd	r20, Z+6	; 0x06
    339a:	57 81       	ldd	r21, Z+7	; 0x07
    339c:	e9 81       	ldd	r30, Y+1	; 0x01
    339e:	fa 81       	ldd	r31, Y+2	; 0x02
    33a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    33a2:	28 2f       	mov	r18, r24
    33a4:	30 e0       	ldi	r19, 0x00	; 0
    33a6:	8b 81       	ldd	r24, Y+3	; 0x03
    33a8:	9c 81       	ldd	r25, Y+4	; 0x04
    33aa:	ba 01       	movw	r22, r20
    33ac:	a9 01       	movw	r20, r18
    33ae:	0e 94 29 24 	call	0x4852	; 0x4852 <memcpy>
	}
}
    33b2:	0f 90       	pop	r0
    33b4:	0f 90       	pop	r0
    33b6:	0f 90       	pop	r0
    33b8:	0f 90       	pop	r0
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    33c0:	df 93       	push	r29
    33c2:	cf 93       	push	r28
    33c4:	00 d0       	rcall	.+0      	; 0x33c6 <prvUnlockQueue+0x6>
    33c6:	cd b7       	in	r28, 0x3d	; 61
    33c8:	de b7       	in	r29, 0x3e	; 62
    33ca:	9a 83       	std	Y+2, r25	; 0x02
    33cc:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    33ce:	0f b6       	in	r0, 0x3f	; 63
    33d0:	f8 94       	cli
    33d2:	0f 92       	push	r0
    33d4:	15 c0       	rjmp	.+42     	; 0x3400 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    33d6:	e9 81       	ldd	r30, Y+1	; 0x01
    33d8:	fa 81       	ldd	r31, Y+2	; 0x02
    33da:	81 89       	ldd	r24, Z+17	; 0x11
    33dc:	88 23       	and	r24, r24
    33de:	a9 f0       	breq	.+42     	; 0x340a <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    33e0:	89 81       	ldd	r24, Y+1	; 0x01
    33e2:	9a 81       	ldd	r25, Y+2	; 0x02
    33e4:	41 96       	adiw	r24, 0x11	; 17
    33e6:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    33ea:	88 23       	and	r24, r24
    33ec:	11 f0       	breq	.+4      	; 0x33f2 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    33ee:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    33f2:	e9 81       	ldd	r30, Y+1	; 0x01
    33f4:	fa 81       	ldd	r31, Y+2	; 0x02
    33f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    33f8:	81 50       	subi	r24, 0x01	; 1
    33fa:	e9 81       	ldd	r30, Y+1	; 0x01
    33fc:	fa 81       	ldd	r31, Y+2	; 0x02
    33fe:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3400:	e9 81       	ldd	r30, Y+1	; 0x01
    3402:	fa 81       	ldd	r31, Y+2	; 0x02
    3404:	86 8d       	ldd	r24, Z+30	; 0x1e
    3406:	18 16       	cp	r1, r24
    3408:	34 f3       	brlt	.-52     	; 0x33d6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    340a:	e9 81       	ldd	r30, Y+1	; 0x01
    340c:	fa 81       	ldd	r31, Y+2	; 0x02
    340e:	8f ef       	ldi	r24, 0xFF	; 255
    3410:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3412:	0f 90       	pop	r0
    3414:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3416:	0f b6       	in	r0, 0x3f	; 63
    3418:	f8 94       	cli
    341a:	0f 92       	push	r0
    341c:	15 c0       	rjmp	.+42     	; 0x3448 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    341e:	e9 81       	ldd	r30, Y+1	; 0x01
    3420:	fa 81       	ldd	r31, Y+2	; 0x02
    3422:	80 85       	ldd	r24, Z+8	; 0x08
    3424:	88 23       	and	r24, r24
    3426:	a9 f0       	breq	.+42     	; 0x3452 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3428:	89 81       	ldd	r24, Y+1	; 0x01
    342a:	9a 81       	ldd	r25, Y+2	; 0x02
    342c:	08 96       	adiw	r24, 0x08	; 8
    342e:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <xTaskRemoveFromEventList>
    3432:	88 23       	and	r24, r24
    3434:	11 f0       	breq	.+4      	; 0x343a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3436:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    343a:	e9 81       	ldd	r30, Y+1	; 0x01
    343c:	fa 81       	ldd	r31, Y+2	; 0x02
    343e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3440:	81 50       	subi	r24, 0x01	; 1
    3442:	e9 81       	ldd	r30, Y+1	; 0x01
    3444:	fa 81       	ldd	r31, Y+2	; 0x02
    3446:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3448:	e9 81       	ldd	r30, Y+1	; 0x01
    344a:	fa 81       	ldd	r31, Y+2	; 0x02
    344c:	85 8d       	ldd	r24, Z+29	; 0x1d
    344e:	18 16       	cp	r1, r24
    3450:	34 f3       	brlt	.-52     	; 0x341e <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3452:	e9 81       	ldd	r30, Y+1	; 0x01
    3454:	fa 81       	ldd	r31, Y+2	; 0x02
    3456:	8f ef       	ldi	r24, 0xFF	; 255
    3458:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    345a:	0f 90       	pop	r0
    345c:	0f be       	out	0x3f, r0	; 63
}
    345e:	0f 90       	pop	r0
    3460:	0f 90       	pop	r0
    3462:	cf 91       	pop	r28
    3464:	df 91       	pop	r29
    3466:	08 95       	ret

00003468 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3468:	df 93       	push	r29
    346a:	cf 93       	push	r28
    346c:	00 d0       	rcall	.+0      	; 0x346e <prvIsQueueEmpty+0x6>
    346e:	0f 92       	push	r0
    3470:	cd b7       	in	r28, 0x3d	; 61
    3472:	de b7       	in	r29, 0x3e	; 62
    3474:	9b 83       	std	Y+3, r25	; 0x03
    3476:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3478:	0f b6       	in	r0, 0x3f	; 63
    347a:	f8 94       	cli
    347c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    347e:	ea 81       	ldd	r30, Y+2	; 0x02
    3480:	fb 81       	ldd	r31, Y+3	; 0x03
    3482:	82 8d       	ldd	r24, Z+26	; 0x1a
    3484:	19 82       	std	Y+1, r1	; 0x01
    3486:	88 23       	and	r24, r24
    3488:	11 f4       	brne	.+4      	; 0x348e <prvIsQueueEmpty+0x26>
    348a:	81 e0       	ldi	r24, 0x01	; 1
    348c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    348e:	0f 90       	pop	r0
    3490:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3492:	89 81       	ldd	r24, Y+1	; 0x01
}
    3494:	0f 90       	pop	r0
    3496:	0f 90       	pop	r0
    3498:	0f 90       	pop	r0
    349a:	cf 91       	pop	r28
    349c:	df 91       	pop	r29
    349e:	08 95       	ret

000034a0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    34a0:	df 93       	push	r29
    34a2:	cf 93       	push	r28
    34a4:	00 d0       	rcall	.+0      	; 0x34a6 <xQueueIsQueueEmptyFromISR+0x6>
    34a6:	0f 92       	push	r0
    34a8:	cd b7       	in	r28, 0x3d	; 61
    34aa:	de b7       	in	r29, 0x3e	; 62
    34ac:	9b 83       	std	Y+3, r25	; 0x03
    34ae:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    34b0:	ea 81       	ldd	r30, Y+2	; 0x02
    34b2:	fb 81       	ldd	r31, Y+3	; 0x03
    34b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    34b6:	19 82       	std	Y+1, r1	; 0x01
    34b8:	88 23       	and	r24, r24
    34ba:	11 f4       	brne	.+4      	; 0x34c0 <xQueueIsQueueEmptyFromISR+0x20>
    34bc:	81 e0       	ldi	r24, 0x01	; 1
    34be:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
}
    34c2:	0f 90       	pop	r0
    34c4:	0f 90       	pop	r0
    34c6:	0f 90       	pop	r0
    34c8:	cf 91       	pop	r28
    34ca:	df 91       	pop	r29
    34cc:	08 95       	ret

000034ce <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    34ce:	df 93       	push	r29
    34d0:	cf 93       	push	r28
    34d2:	00 d0       	rcall	.+0      	; 0x34d4 <prvIsQueueFull+0x6>
    34d4:	0f 92       	push	r0
    34d6:	cd b7       	in	r28, 0x3d	; 61
    34d8:	de b7       	in	r29, 0x3e	; 62
    34da:	9b 83       	std	Y+3, r25	; 0x03
    34dc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    34de:	0f b6       	in	r0, 0x3f	; 63
    34e0:	f8 94       	cli
    34e2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    34e4:	ea 81       	ldd	r30, Y+2	; 0x02
    34e6:	fb 81       	ldd	r31, Y+3	; 0x03
    34e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    34ea:	ea 81       	ldd	r30, Y+2	; 0x02
    34ec:	fb 81       	ldd	r31, Y+3	; 0x03
    34ee:	83 8d       	ldd	r24, Z+27	; 0x1b
    34f0:	19 82       	std	Y+1, r1	; 0x01
    34f2:	98 17       	cp	r25, r24
    34f4:	11 f4       	brne	.+4      	; 0x34fa <prvIsQueueFull+0x2c>
    34f6:	81 e0       	ldi	r24, 0x01	; 1
    34f8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    34fa:	0f 90       	pop	r0
    34fc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    34fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    3500:	0f 90       	pop	r0
    3502:	0f 90       	pop	r0
    3504:	0f 90       	pop	r0
    3506:	cf 91       	pop	r28
    3508:	df 91       	pop	r29
    350a:	08 95       	ret

0000350c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    350c:	df 93       	push	r29
    350e:	cf 93       	push	r28
    3510:	00 d0       	rcall	.+0      	; 0x3512 <xQueueIsQueueFullFromISR+0x6>
    3512:	0f 92       	push	r0
    3514:	cd b7       	in	r28, 0x3d	; 61
    3516:	de b7       	in	r29, 0x3e	; 62
    3518:	9b 83       	std	Y+3, r25	; 0x03
    351a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    351c:	ea 81       	ldd	r30, Y+2	; 0x02
    351e:	fb 81       	ldd	r31, Y+3	; 0x03
    3520:	92 8d       	ldd	r25, Z+26	; 0x1a
    3522:	ea 81       	ldd	r30, Y+2	; 0x02
    3524:	fb 81       	ldd	r31, Y+3	; 0x03
    3526:	83 8d       	ldd	r24, Z+27	; 0x1b
    3528:	19 82       	std	Y+1, r1	; 0x01
    352a:	98 17       	cp	r25, r24
    352c:	11 f4       	brne	.+4      	; 0x3532 <xQueueIsQueueFullFromISR+0x26>
    352e:	81 e0       	ldi	r24, 0x01	; 1
    3530:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3532:	89 81       	ldd	r24, Y+1	; 0x01
}
    3534:	0f 90       	pop	r0
    3536:	0f 90       	pop	r0
    3538:	0f 90       	pop	r0
    353a:	cf 91       	pop	r28
    353c:	df 91       	pop	r29
    353e:	08 95       	ret

00003540 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3540:	af 92       	push	r10
    3542:	bf 92       	push	r11
    3544:	cf 92       	push	r12
    3546:	df 92       	push	r13
    3548:	ef 92       	push	r14
    354a:	ff 92       	push	r15
    354c:	0f 93       	push	r16
    354e:	1f 93       	push	r17
    3550:	df 93       	push	r29
    3552:	cf 93       	push	r28
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	64 97       	sbiw	r28, 0x14	; 20
    355a:	0f b6       	in	r0, 0x3f	; 63
    355c:	f8 94       	cli
    355e:	de bf       	out	0x3e, r29	; 62
    3560:	0f be       	out	0x3f, r0	; 63
    3562:	cd bf       	out	0x3d, r28	; 61
    3564:	9f 83       	std	Y+7, r25	; 0x07
    3566:	8e 83       	std	Y+6, r24	; 0x06
    3568:	79 87       	std	Y+9, r23	; 0x09
    356a:	68 87       	std	Y+8, r22	; 0x08
    356c:	5b 87       	std	Y+11, r21	; 0x0b
    356e:	4a 87       	std	Y+10, r20	; 0x0a
    3570:	3d 87       	std	Y+13, r19	; 0x0d
    3572:	2c 87       	std	Y+12, r18	; 0x0c
    3574:	0e 87       	std	Y+14, r16	; 0x0e
    3576:	f8 8a       	std	Y+16, r15	; 0x10
    3578:	ef 86       	std	Y+15, r14	; 0x0f
    357a:	da 8a       	std	Y+18, r13	; 0x12
    357c:	c9 8a       	std	Y+17, r12	; 0x11
    357e:	bc 8a       	std	Y+20, r11	; 0x14
    3580:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3582:	8a 85       	ldd	r24, Y+10	; 0x0a
    3584:	9b 85       	ldd	r25, Y+11	; 0x0b
    3586:	29 89       	ldd	r18, Y+17	; 0x11
    3588:	3a 89       	ldd	r19, Y+18	; 0x12
    358a:	b9 01       	movw	r22, r18
    358c:	0e 94 25 21 	call	0x424a	; 0x424a <prvAllocateTCBAndStack>
    3590:	9c 83       	std	Y+4, r25	; 0x04
    3592:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3594:	8b 81       	ldd	r24, Y+3	; 0x03
    3596:	9c 81       	ldd	r25, Y+4	; 0x04
    3598:	00 97       	sbiw	r24, 0x00	; 0
    359a:	09 f4       	brne	.+2      	; 0x359e <xTaskGenericCreate+0x5e>
    359c:	99 c0       	rjmp	.+306    	; 0x36d0 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    359e:	eb 81       	ldd	r30, Y+3	; 0x03
    35a0:	fc 81       	ldd	r31, Y+4	; 0x04
    35a2:	27 89       	ldd	r18, Z+23	; 0x17
    35a4:	30 8d       	ldd	r19, Z+24	; 0x18
    35a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    35a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    35aa:	01 97       	sbiw	r24, 0x01	; 1
    35ac:	82 0f       	add	r24, r18
    35ae:	93 1f       	adc	r25, r19
    35b0:	9a 83       	std	Y+2, r25	; 0x02
    35b2:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    35b4:	8b 81       	ldd	r24, Y+3	; 0x03
    35b6:	9c 81       	ldd	r25, Y+4	; 0x04
    35b8:	28 85       	ldd	r18, Y+8	; 0x08
    35ba:	39 85       	ldd	r19, Y+9	; 0x09
    35bc:	eb 89       	ldd	r30, Y+19	; 0x13
    35be:	fc 89       	ldd	r31, Y+20	; 0x14
    35c0:	aa 85       	ldd	r26, Y+10	; 0x0a
    35c2:	bb 85       	ldd	r27, Y+11	; 0x0b
    35c4:	b9 01       	movw	r22, r18
    35c6:	4e 85       	ldd	r20, Y+14	; 0x0e
    35c8:	9f 01       	movw	r18, r30
    35ca:	8d 01       	movw	r16, r26
    35cc:	0e 94 0a 20 	call	0x4014	; 0x4014 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    35d0:	89 81       	ldd	r24, Y+1	; 0x01
    35d2:	9a 81       	ldd	r25, Y+2	; 0x02
    35d4:	2e 81       	ldd	r18, Y+6	; 0x06
    35d6:	3f 81       	ldd	r19, Y+7	; 0x07
    35d8:	4c 85       	ldd	r20, Y+12	; 0x0c
    35da:	5d 85       	ldd	r21, Y+13	; 0x0d
    35dc:	b9 01       	movw	r22, r18
    35de:	0e 94 4d 13 	call	0x269a	; 0x269a <pxPortInitialiseStack>
    35e2:	eb 81       	ldd	r30, Y+3	; 0x03
    35e4:	fc 81       	ldd	r31, Y+4	; 0x04
    35e6:	91 83       	std	Z+1, r25	; 0x01
    35e8:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    35ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    35ec:	98 89       	ldd	r25, Y+16	; 0x10
    35ee:	00 97       	sbiw	r24, 0x00	; 0
    35f0:	31 f0       	breq	.+12     	; 0x35fe <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    35f2:	ef 85       	ldd	r30, Y+15	; 0x0f
    35f4:	f8 89       	ldd	r31, Y+16	; 0x10
    35f6:	8b 81       	ldd	r24, Y+3	; 0x03
    35f8:	9c 81       	ldd	r25, Y+4	; 0x04
    35fa:	91 83       	std	Z+1, r25	; 0x01
    35fc:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    35fe:	0f b6       	in	r0, 0x3f	; 63
    3600:	f8 94       	cli
    3602:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3604:	80 91 a5 03 	lds	r24, 0x03A5
    3608:	8f 5f       	subi	r24, 0xFF	; 255
    360a:	80 93 a5 03 	sts	0x03A5, r24
			if( pxCurrentTCB == NULL )
    360e:	80 91 a2 03 	lds	r24, 0x03A2
    3612:	90 91 a3 03 	lds	r25, 0x03A3
    3616:	00 97       	sbiw	r24, 0x00	; 0
    3618:	69 f4       	brne	.+26     	; 0x3634 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    361a:	8b 81       	ldd	r24, Y+3	; 0x03
    361c:	9c 81       	ldd	r25, Y+4	; 0x04
    361e:	90 93 a3 03 	sts	0x03A3, r25
    3622:	80 93 a2 03 	sts	0x03A2, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3626:	80 91 a5 03 	lds	r24, 0x03A5
    362a:	81 30       	cpi	r24, 0x01	; 1
    362c:	a9 f4       	brne	.+42     	; 0x3658 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    362e:	0e 94 61 20 	call	0x40c2	; 0x40c2 <prvInitialiseTaskLists>
    3632:	12 c0       	rjmp	.+36     	; 0x3658 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3634:	80 91 aa 03 	lds	r24, 0x03AA
    3638:	88 23       	and	r24, r24
    363a:	71 f4       	brne	.+28     	; 0x3658 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    363c:	e0 91 a2 03 	lds	r30, 0x03A2
    3640:	f0 91 a3 03 	lds	r31, 0x03A3
    3644:	96 89       	ldd	r25, Z+22	; 0x16
    3646:	8e 85       	ldd	r24, Y+14	; 0x0e
    3648:	89 17       	cp	r24, r25
    364a:	30 f0       	brcs	.+12     	; 0x3658 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    364c:	8b 81       	ldd	r24, Y+3	; 0x03
    364e:	9c 81       	ldd	r25, Y+4	; 0x04
    3650:	90 93 a3 03 	sts	0x03A3, r25
    3654:	80 93 a2 03 	sts	0x03A2, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3658:	eb 81       	ldd	r30, Y+3	; 0x03
    365a:	fc 81       	ldd	r31, Y+4	; 0x04
    365c:	96 89       	ldd	r25, Z+22	; 0x16
    365e:	80 91 a8 03 	lds	r24, 0x03A8
    3662:	89 17       	cp	r24, r25
    3664:	28 f4       	brcc	.+10     	; 0x3670 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3666:	eb 81       	ldd	r30, Y+3	; 0x03
    3668:	fc 81       	ldd	r31, Y+4	; 0x04
    366a:	86 89       	ldd	r24, Z+22	; 0x16
    366c:	80 93 a8 03 	sts	0x03A8, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3670:	80 91 af 03 	lds	r24, 0x03AF
    3674:	8f 5f       	subi	r24, 0xFF	; 255
    3676:	80 93 af 03 	sts	0x03AF, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    367a:	eb 81       	ldd	r30, Y+3	; 0x03
    367c:	fc 81       	ldd	r31, Y+4	; 0x04
    367e:	96 89       	ldd	r25, Z+22	; 0x16
    3680:	80 91 a9 03 	lds	r24, 0x03A9
    3684:	89 17       	cp	r24, r25
    3686:	28 f4       	brcc	.+10     	; 0x3692 <xTaskGenericCreate+0x152>
    3688:	eb 81       	ldd	r30, Y+3	; 0x03
    368a:	fc 81       	ldd	r31, Y+4	; 0x04
    368c:	86 89       	ldd	r24, Z+22	; 0x16
    368e:	80 93 a9 03 	sts	0x03A9, r24
    3692:	eb 81       	ldd	r30, Y+3	; 0x03
    3694:	fc 81       	ldd	r31, Y+4	; 0x04
    3696:	86 89       	ldd	r24, Z+22	; 0x16
    3698:	28 2f       	mov	r18, r24
    369a:	30 e0       	ldi	r19, 0x00	; 0
    369c:	c9 01       	movw	r24, r18
    369e:	88 0f       	add	r24, r24
    36a0:	99 1f       	adc	r25, r25
    36a2:	88 0f       	add	r24, r24
    36a4:	99 1f       	adc	r25, r25
    36a6:	88 0f       	add	r24, r24
    36a8:	99 1f       	adc	r25, r25
    36aa:	82 0f       	add	r24, r18
    36ac:	93 1f       	adc	r25, r19
    36ae:	ac 01       	movw	r20, r24
    36b0:	40 55       	subi	r20, 0x50	; 80
    36b2:	5c 4f       	sbci	r21, 0xFC	; 252
    36b4:	8b 81       	ldd	r24, Y+3	; 0x03
    36b6:	9c 81       	ldd	r25, Y+4	; 0x04
    36b8:	9c 01       	movw	r18, r24
    36ba:	2e 5f       	subi	r18, 0xFE	; 254
    36bc:	3f 4f       	sbci	r19, 0xFF	; 255
    36be:	ca 01       	movw	r24, r20
    36c0:	b9 01       	movw	r22, r18
    36c2:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>

			xReturn = pdPASS;
    36c6:	81 e0       	ldi	r24, 0x01	; 1
    36c8:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    36ca:	0f 90       	pop	r0
    36cc:	0f be       	out	0x3f, r0	; 63
    36ce:	02 c0       	rjmp	.+4      	; 0x36d4 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    36d0:	8f ef       	ldi	r24, 0xFF	; 255
    36d2:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    36d4:	8d 81       	ldd	r24, Y+5	; 0x05
    36d6:	81 30       	cpi	r24, 0x01	; 1
    36d8:	71 f4       	brne	.+28     	; 0x36f6 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    36da:	80 91 aa 03 	lds	r24, 0x03AA
    36de:	88 23       	and	r24, r24
    36e0:	51 f0       	breq	.+20     	; 0x36f6 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    36e2:	e0 91 a2 03 	lds	r30, 0x03A2
    36e6:	f0 91 a3 03 	lds	r31, 0x03A3
    36ea:	96 89       	ldd	r25, Z+22	; 0x16
    36ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    36ee:	98 17       	cp	r25, r24
    36f0:	10 f4       	brcc	.+4      	; 0x36f6 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    36f2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
			}
		}
	}

	return xReturn;
    36f6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    36f8:	64 96       	adiw	r28, 0x14	; 20
    36fa:	0f b6       	in	r0, 0x3f	; 63
    36fc:	f8 94       	cli
    36fe:	de bf       	out	0x3e, r29	; 62
    3700:	0f be       	out	0x3f, r0	; 63
    3702:	cd bf       	out	0x3d, r28	; 61
    3704:	cf 91       	pop	r28
    3706:	df 91       	pop	r29
    3708:	1f 91       	pop	r17
    370a:	0f 91       	pop	r16
    370c:	ff 90       	pop	r15
    370e:	ef 90       	pop	r14
    3710:	df 90       	pop	r13
    3712:	cf 90       	pop	r12
    3714:	bf 90       	pop	r11
    3716:	af 90       	pop	r10
    3718:	08 95       	ret

0000371a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    371a:	df 93       	push	r29
    371c:	cf 93       	push	r28
    371e:	00 d0       	rcall	.+0      	; 0x3720 <vTaskDelete+0x6>
    3720:	00 d0       	rcall	.+0      	; 0x3722 <vTaskDelete+0x8>
    3722:	00 d0       	rcall	.+0      	; 0x3724 <vTaskDelete+0xa>
    3724:	cd b7       	in	r28, 0x3d	; 61
    3726:	de b7       	in	r29, 0x3e	; 62
    3728:	9c 83       	std	Y+4, r25	; 0x04
    372a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    372c:	0f b6       	in	r0, 0x3f	; 63
    372e:	f8 94       	cli
    3730:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3732:	20 91 a2 03 	lds	r18, 0x03A2
    3736:	30 91 a3 03 	lds	r19, 0x03A3
    373a:	8b 81       	ldd	r24, Y+3	; 0x03
    373c:	9c 81       	ldd	r25, Y+4	; 0x04
    373e:	82 17       	cp	r24, r18
    3740:	93 07       	cpc	r25, r19
    3742:	11 f4       	brne	.+4      	; 0x3748 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3744:	1c 82       	std	Y+4, r1	; 0x04
    3746:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3748:	8b 81       	ldd	r24, Y+3	; 0x03
    374a:	9c 81       	ldd	r25, Y+4	; 0x04
    374c:	00 97       	sbiw	r24, 0x00	; 0
    374e:	39 f4       	brne	.+14     	; 0x375e <vTaskDelete+0x44>
    3750:	80 91 a2 03 	lds	r24, 0x03A2
    3754:	90 91 a3 03 	lds	r25, 0x03A3
    3758:	9e 83       	std	Y+6, r25	; 0x06
    375a:	8d 83       	std	Y+5, r24	; 0x05
    375c:	04 c0       	rjmp	.+8      	; 0x3766 <vTaskDelete+0x4c>
    375e:	8b 81       	ldd	r24, Y+3	; 0x03
    3760:	9c 81       	ldd	r25, Y+4	; 0x04
    3762:	9e 83       	std	Y+6, r25	; 0x06
    3764:	8d 83       	std	Y+5, r24	; 0x05
    3766:	8d 81       	ldd	r24, Y+5	; 0x05
    3768:	9e 81       	ldd	r25, Y+6	; 0x06
    376a:	9a 83       	std	Y+2, r25	; 0x02
    376c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	9a 81       	ldd	r25, Y+2	; 0x02
    3772:	02 96       	adiw	r24, 0x02	; 2
    3774:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    3778:	e9 81       	ldd	r30, Y+1	; 0x01
    377a:	fa 81       	ldd	r31, Y+2	; 0x02
    377c:	84 89       	ldd	r24, Z+20	; 0x14
    377e:	95 89       	ldd	r25, Z+21	; 0x15
    3780:	00 97       	sbiw	r24, 0x00	; 0
    3782:	29 f0       	breq	.+10     	; 0x378e <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	9a 81       	ldd	r25, Y+2	; 0x02
    3788:	0c 96       	adiw	r24, 0x0c	; 12
    378a:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    378e:	89 81       	ldd	r24, Y+1	; 0x01
    3790:	9a 81       	ldd	r25, Y+2	; 0x02
    3792:	9c 01       	movw	r18, r24
    3794:	2e 5f       	subi	r18, 0xFE	; 254
    3796:	3f 4f       	sbci	r19, 0xFF	; 255
    3798:	8a ee       	ldi	r24, 0xEA	; 234
    379a:	93 e0       	ldi	r25, 0x03	; 3
    379c:	b9 01       	movw	r22, r18
    379e:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    37a2:	80 91 a4 03 	lds	r24, 0x03A4
    37a6:	8f 5f       	subi	r24, 0xFF	; 255
    37a8:	80 93 a4 03 	sts	0x03A4, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    37ac:	80 91 af 03 	lds	r24, 0x03AF
    37b0:	8f 5f       	subi	r24, 0xFF	; 255
    37b2:	80 93 af 03 	sts	0x03AF, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    37b6:	0f 90       	pop	r0
    37b8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    37ba:	80 91 aa 03 	lds	r24, 0x03AA
    37be:	88 23       	and	r24, r24
    37c0:	31 f0       	breq	.+12     	; 0x37ce <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    37c2:	8b 81       	ldd	r24, Y+3	; 0x03
    37c4:	9c 81       	ldd	r25, Y+4	; 0x04
    37c6:	00 97       	sbiw	r24, 0x00	; 0
    37c8:	11 f4       	brne	.+4      	; 0x37ce <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    37ca:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
			}
		}
	}
    37ce:	26 96       	adiw	r28, 0x06	; 6
    37d0:	0f b6       	in	r0, 0x3f	; 63
    37d2:	f8 94       	cli
    37d4:	de bf       	out	0x3e, r29	; 62
    37d6:	0f be       	out	0x3f, r0	; 63
    37d8:	cd bf       	out	0x3d, r28	; 61
    37da:	cf 91       	pop	r28
    37dc:	df 91       	pop	r29
    37de:	08 95       	ret

000037e0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    37e0:	df 93       	push	r29
    37e2:	cf 93       	push	r28
    37e4:	cd b7       	in	r28, 0x3d	; 61
    37e6:	de b7       	in	r29, 0x3e	; 62
    37e8:	28 97       	sbiw	r28, 0x08	; 8
    37ea:	0f b6       	in	r0, 0x3f	; 63
    37ec:	f8 94       	cli
    37ee:	de bf       	out	0x3e, r29	; 62
    37f0:	0f be       	out	0x3f, r0	; 63
    37f2:	cd bf       	out	0x3d, r28	; 61
    37f4:	9e 83       	std	Y+6, r25	; 0x06
    37f6:	8d 83       	std	Y+5, r24	; 0x05
    37f8:	78 87       	std	Y+8, r23	; 0x08
    37fa:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    37fc:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    37fe:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3802:	ed 81       	ldd	r30, Y+5	; 0x05
    3804:	fe 81       	ldd	r31, Y+6	; 0x06
    3806:	20 81       	ld	r18, Z
    3808:	31 81       	ldd	r19, Z+1	; 0x01
    380a:	8f 81       	ldd	r24, Y+7	; 0x07
    380c:	98 85       	ldd	r25, Y+8	; 0x08
    380e:	82 0f       	add	r24, r18
    3810:	93 1f       	adc	r25, r19
    3812:	9c 83       	std	Y+4, r25	; 0x04
    3814:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3816:	ed 81       	ldd	r30, Y+5	; 0x05
    3818:	fe 81       	ldd	r31, Y+6	; 0x06
    381a:	20 81       	ld	r18, Z
    381c:	31 81       	ldd	r19, Z+1	; 0x01
    381e:	80 91 a6 03 	lds	r24, 0x03A6
    3822:	90 91 a7 03 	lds	r25, 0x03A7
    3826:	82 17       	cp	r24, r18
    3828:	93 07       	cpc	r25, r19
    382a:	a8 f4       	brcc	.+42     	; 0x3856 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    382c:	ed 81       	ldd	r30, Y+5	; 0x05
    382e:	fe 81       	ldd	r31, Y+6	; 0x06
    3830:	20 81       	ld	r18, Z
    3832:	31 81       	ldd	r19, Z+1	; 0x01
    3834:	8b 81       	ldd	r24, Y+3	; 0x03
    3836:	9c 81       	ldd	r25, Y+4	; 0x04
    3838:	82 17       	cp	r24, r18
    383a:	93 07       	cpc	r25, r19
    383c:	00 f5       	brcc	.+64     	; 0x387e <vTaskDelayUntil+0x9e>
    383e:	20 91 a6 03 	lds	r18, 0x03A6
    3842:	30 91 a7 03 	lds	r19, 0x03A7
    3846:	8b 81       	ldd	r24, Y+3	; 0x03
    3848:	9c 81       	ldd	r25, Y+4	; 0x04
    384a:	28 17       	cp	r18, r24
    384c:	39 07       	cpc	r19, r25
    384e:	b8 f4       	brcc	.+46     	; 0x387e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3850:	81 e0       	ldi	r24, 0x01	; 1
    3852:	89 83       	std	Y+1, r24	; 0x01
    3854:	14 c0       	rjmp	.+40     	; 0x387e <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3856:	ed 81       	ldd	r30, Y+5	; 0x05
    3858:	fe 81       	ldd	r31, Y+6	; 0x06
    385a:	20 81       	ld	r18, Z
    385c:	31 81       	ldd	r19, Z+1	; 0x01
    385e:	8b 81       	ldd	r24, Y+3	; 0x03
    3860:	9c 81       	ldd	r25, Y+4	; 0x04
    3862:	82 17       	cp	r24, r18
    3864:	93 07       	cpc	r25, r19
    3866:	48 f0       	brcs	.+18     	; 0x387a <vTaskDelayUntil+0x9a>
    3868:	20 91 a6 03 	lds	r18, 0x03A6
    386c:	30 91 a7 03 	lds	r19, 0x03A7
    3870:	8b 81       	ldd	r24, Y+3	; 0x03
    3872:	9c 81       	ldd	r25, Y+4	; 0x04
    3874:	28 17       	cp	r18, r24
    3876:	39 07       	cpc	r19, r25
    3878:	10 f4       	brcc	.+4      	; 0x387e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    387a:	81 e0       	ldi	r24, 0x01	; 1
    387c:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    387e:	ed 81       	ldd	r30, Y+5	; 0x05
    3880:	fe 81       	ldd	r31, Y+6	; 0x06
    3882:	8b 81       	ldd	r24, Y+3	; 0x03
    3884:	9c 81       	ldd	r25, Y+4	; 0x04
    3886:	91 83       	std	Z+1, r25	; 0x01
    3888:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    388a:	89 81       	ldd	r24, Y+1	; 0x01
    388c:	88 23       	and	r24, r24
    388e:	59 f0       	breq	.+22     	; 0x38a6 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3890:	80 91 a2 03 	lds	r24, 0x03A2
    3894:	90 91 a3 03 	lds	r25, 0x03A3
    3898:	02 96       	adiw	r24, 0x02	; 2
    389a:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    389e:	8b 81       	ldd	r24, Y+3	; 0x03
    38a0:	9c 81       	ldd	r25, Y+4	; 0x04
    38a2:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    38a6:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    38aa:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    38ac:	8a 81       	ldd	r24, Y+2	; 0x02
    38ae:	88 23       	and	r24, r24
    38b0:	11 f4       	brne	.+4      	; 0x38b6 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    38b2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
		}
	}
    38b6:	28 96       	adiw	r28, 0x08	; 8
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	de bf       	out	0x3e, r29	; 62
    38be:	0f be       	out	0x3f, r0	; 63
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	cf 91       	pop	r28
    38c4:	df 91       	pop	r29
    38c6:	08 95       	ret

000038c8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    38c8:	df 93       	push	r29
    38ca:	cf 93       	push	r28
    38cc:	00 d0       	rcall	.+0      	; 0x38ce <vTaskDelay+0x6>
    38ce:	00 d0       	rcall	.+0      	; 0x38d0 <vTaskDelay+0x8>
    38d0:	0f 92       	push	r0
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62
    38d6:	9d 83       	std	Y+5, r25	; 0x05
    38d8:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    38da:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    38dc:	8c 81       	ldd	r24, Y+4	; 0x04
    38de:	9d 81       	ldd	r25, Y+5	; 0x05
    38e0:	00 97       	sbiw	r24, 0x00	; 0
    38e2:	d1 f0       	breq	.+52     	; 0x3918 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    38e4:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    38e8:	20 91 a6 03 	lds	r18, 0x03A6
    38ec:	30 91 a7 03 	lds	r19, 0x03A7
    38f0:	8c 81       	ldd	r24, Y+4	; 0x04
    38f2:	9d 81       	ldd	r25, Y+5	; 0x05
    38f4:	82 0f       	add	r24, r18
    38f6:	93 1f       	adc	r25, r19
    38f8:	9b 83       	std	Y+3, r25	; 0x03
    38fa:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    38fc:	80 91 a2 03 	lds	r24, 0x03A2
    3900:	90 91 a3 03 	lds	r25, 0x03A3
    3904:	02 96       	adiw	r24, 0x02	; 2
    3906:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    390a:	8a 81       	ldd	r24, Y+2	; 0x02
    390c:	9b 81       	ldd	r25, Y+3	; 0x03
    390e:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3912:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>
    3916:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3918:	89 81       	ldd	r24, Y+1	; 0x01
    391a:	88 23       	and	r24, r24
    391c:	11 f4       	brne	.+4      	; 0x3922 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    391e:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
		}
	}
    3922:	0f 90       	pop	r0
    3924:	0f 90       	pop	r0
    3926:	0f 90       	pop	r0
    3928:	0f 90       	pop	r0
    392a:	0f 90       	pop	r0
    392c:	cf 91       	pop	r28
    392e:	df 91       	pop	r29
    3930:	08 95       	ret

00003932 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3932:	af 92       	push	r10
    3934:	bf 92       	push	r11
    3936:	cf 92       	push	r12
    3938:	df 92       	push	r13
    393a:	ef 92       	push	r14
    393c:	ff 92       	push	r15
    393e:	0f 93       	push	r16
    3940:	df 93       	push	r29
    3942:	cf 93       	push	r28
    3944:	0f 92       	push	r0
    3946:	cd b7       	in	r28, 0x3d	; 61
    3948:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    394a:	20 e0       	ldi	r18, 0x00	; 0
    394c:	31 e0       	ldi	r19, 0x01	; 1
    394e:	80 e0       	ldi	r24, 0x00	; 0
    3950:	90 e2       	ldi	r25, 0x20	; 32
    3952:	b9 01       	movw	r22, r18
    3954:	45 e5       	ldi	r20, 0x55	; 85
    3956:	50 e0       	ldi	r21, 0x00	; 0
    3958:	20 e0       	ldi	r18, 0x00	; 0
    395a:	30 e0       	ldi	r19, 0x00	; 0
    395c:	00 e0       	ldi	r16, 0x00	; 0
    395e:	ee 24       	eor	r14, r14
    3960:	ff 24       	eor	r15, r15
    3962:	cc 24       	eor	r12, r12
    3964:	dd 24       	eor	r13, r13
    3966:	aa 24       	eor	r10, r10
    3968:	bb 24       	eor	r11, r11
    396a:	0e 94 a0 1a 	call	0x3540	; 0x3540 <xTaskGenericCreate>
    396e:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	81 30       	cpi	r24, 0x01	; 1
    3974:	51 f4       	brne	.+20     	; 0x398a <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3976:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3978:	81 e0       	ldi	r24, 0x01	; 1
    397a:	80 93 aa 03 	sts	0x03AA, r24
		xTickCount = ( portTickType ) 0U;
    397e:	10 92 a7 03 	sts	0x03A7, r1
    3982:	10 92 a6 03 	sts	0x03A6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3986:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    398a:	0f 90       	pop	r0
    398c:	cf 91       	pop	r28
    398e:	df 91       	pop	r29
    3990:	0f 91       	pop	r16
    3992:	ff 90       	pop	r15
    3994:	ef 90       	pop	r14
    3996:	df 90       	pop	r13
    3998:	cf 90       	pop	r12
    399a:	bf 90       	pop	r11
    399c:	af 90       	pop	r10
    399e:	08 95       	ret

000039a0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    39a0:	df 93       	push	r29
    39a2:	cf 93       	push	r28
    39a4:	cd b7       	in	r28, 0x3d	; 61
    39a6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    39a8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    39aa:	10 92 aa 03 	sts	0x03AA, r1
	vPortEndScheduler();
    39ae:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <vPortEndScheduler>
}
    39b2:	cf 91       	pop	r28
    39b4:	df 91       	pop	r29
    39b6:	08 95       	ret

000039b8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    39b8:	df 93       	push	r29
    39ba:	cf 93       	push	r28
    39bc:	cd b7       	in	r28, 0x3d	; 61
    39be:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    39c0:	80 91 ab 03 	lds	r24, 0x03AB
    39c4:	8f 5f       	subi	r24, 0xFF	; 255
    39c6:	80 93 ab 03 	sts	0x03AB, r24
}
    39ca:	cf 91       	pop	r28
    39cc:	df 91       	pop	r29
    39ce:	08 95       	ret

000039d0 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    39d0:	df 93       	push	r29
    39d2:	cf 93       	push	r28
    39d4:	00 d0       	rcall	.+0      	; 0x39d6 <xTaskResumeAll+0x6>
    39d6:	00 d0       	rcall	.+0      	; 0x39d8 <xTaskResumeAll+0x8>
    39d8:	cd b7       	in	r28, 0x3d	; 61
    39da:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    39dc:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    39de:	0f b6       	in	r0, 0x3f	; 63
    39e0:	f8 94       	cli
    39e2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    39e4:	80 91 ab 03 	lds	r24, 0x03AB
    39e8:	81 50       	subi	r24, 0x01	; 1
    39ea:	80 93 ab 03 	sts	0x03AB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    39ee:	80 91 ab 03 	lds	r24, 0x03AB
    39f2:	88 23       	and	r24, r24
    39f4:	09 f0       	breq	.+2      	; 0x39f8 <xTaskResumeAll+0x28>
    39f6:	6c c0       	rjmp	.+216    	; 0x3ad0 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    39f8:	80 91 a5 03 	lds	r24, 0x03A5
    39fc:	88 23       	and	r24, r24
    39fe:	09 f4       	brne	.+2      	; 0x3a02 <xTaskResumeAll+0x32>
    3a00:	67 c0       	rjmp	.+206    	; 0x3ad0 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3a02:	19 82       	std	Y+1, r1	; 0x01
    3a04:	41 c0       	rjmp	.+130    	; 0x3a88 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3a06:	e0 91 e6 03 	lds	r30, 0x03E6
    3a0a:	f0 91 e7 03 	lds	r31, 0x03E7
    3a0e:	86 81       	ldd	r24, Z+6	; 0x06
    3a10:	97 81       	ldd	r25, Z+7	; 0x07
    3a12:	9c 83       	std	Y+4, r25	; 0x04
    3a14:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3a16:	8b 81       	ldd	r24, Y+3	; 0x03
    3a18:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1a:	0c 96       	adiw	r24, 0x0c	; 12
    3a1c:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3a20:	8b 81       	ldd	r24, Y+3	; 0x03
    3a22:	9c 81       	ldd	r25, Y+4	; 0x04
    3a24:	02 96       	adiw	r24, 0x02	; 2
    3a26:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3a2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a2e:	96 89       	ldd	r25, Z+22	; 0x16
    3a30:	80 91 a9 03 	lds	r24, 0x03A9
    3a34:	89 17       	cp	r24, r25
    3a36:	28 f4       	brcc	.+10     	; 0x3a42 <xTaskResumeAll+0x72>
    3a38:	eb 81       	ldd	r30, Y+3	; 0x03
    3a3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a3c:	86 89       	ldd	r24, Z+22	; 0x16
    3a3e:	80 93 a9 03 	sts	0x03A9, r24
    3a42:	eb 81       	ldd	r30, Y+3	; 0x03
    3a44:	fc 81       	ldd	r31, Y+4	; 0x04
    3a46:	86 89       	ldd	r24, Z+22	; 0x16
    3a48:	28 2f       	mov	r18, r24
    3a4a:	30 e0       	ldi	r19, 0x00	; 0
    3a4c:	c9 01       	movw	r24, r18
    3a4e:	88 0f       	add	r24, r24
    3a50:	99 1f       	adc	r25, r25
    3a52:	88 0f       	add	r24, r24
    3a54:	99 1f       	adc	r25, r25
    3a56:	88 0f       	add	r24, r24
    3a58:	99 1f       	adc	r25, r25
    3a5a:	82 0f       	add	r24, r18
    3a5c:	93 1f       	adc	r25, r19
    3a5e:	80 55       	subi	r24, 0x50	; 80
    3a60:	9c 4f       	sbci	r25, 0xFC	; 252
    3a62:	2b 81       	ldd	r18, Y+3	; 0x03
    3a64:	3c 81       	ldd	r19, Y+4	; 0x04
    3a66:	2e 5f       	subi	r18, 0xFE	; 254
    3a68:	3f 4f       	sbci	r19, 0xFF	; 255
    3a6a:	b9 01       	movw	r22, r18
    3a6c:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3a70:	eb 81       	ldd	r30, Y+3	; 0x03
    3a72:	fc 81       	ldd	r31, Y+4	; 0x04
    3a74:	96 89       	ldd	r25, Z+22	; 0x16
    3a76:	e0 91 a2 03 	lds	r30, 0x03A2
    3a7a:	f0 91 a3 03 	lds	r31, 0x03A3
    3a7e:	86 89       	ldd	r24, Z+22	; 0x16
    3a80:	98 17       	cp	r25, r24
    3a82:	10 f0       	brcs	.+4      	; 0x3a88 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3a84:	81 e0       	ldi	r24, 0x01	; 1
    3a86:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3a88:	80 91 e1 03 	lds	r24, 0x03E1
    3a8c:	88 23       	and	r24, r24
    3a8e:	09 f0       	breq	.+2      	; 0x3a92 <xTaskResumeAll+0xc2>
    3a90:	ba cf       	rjmp	.-140    	; 0x3a06 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3a92:	80 91 ac 03 	lds	r24, 0x03AC
    3a96:	88 23       	and	r24, r24
    3a98:	71 f0       	breq	.+28     	; 0x3ab6 <xTaskResumeAll+0xe6>
    3a9a:	07 c0       	rjmp	.+14     	; 0x3aaa <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3a9c:	0e 94 a7 1d 	call	0x3b4e	; 0x3b4e <vTaskIncrementTick>
						--uxMissedTicks;
    3aa0:	80 91 ac 03 	lds	r24, 0x03AC
    3aa4:	81 50       	subi	r24, 0x01	; 1
    3aa6:	80 93 ac 03 	sts	0x03AC, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3aaa:	80 91 ac 03 	lds	r24, 0x03AC
    3aae:	88 23       	and	r24, r24
    3ab0:	a9 f7       	brne	.-22     	; 0x3a9c <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    3ab2:	81 e0       	ldi	r24, 0x01	; 1
    3ab4:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    3ab6:	89 81       	ldd	r24, Y+1	; 0x01
    3ab8:	81 30       	cpi	r24, 0x01	; 1
    3aba:	21 f0       	breq	.+8      	; 0x3ac4 <xTaskResumeAll+0xf4>
    3abc:	80 91 ad 03 	lds	r24, 0x03AD
    3ac0:	81 30       	cpi	r24, 0x01	; 1
    3ac2:	31 f4       	brne	.+12     	; 0x3ad0 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    3ac4:	81 e0       	ldi	r24, 0x01	; 1
    3ac6:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    3ac8:	10 92 ad 03 	sts	0x03AD, r1
					portYIELD_WITHIN_API();
    3acc:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    3ad0:	0f 90       	pop	r0
    3ad2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3ad4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3ad6:	0f 90       	pop	r0
    3ad8:	0f 90       	pop	r0
    3ada:	0f 90       	pop	r0
    3adc:	0f 90       	pop	r0
    3ade:	cf 91       	pop	r28
    3ae0:	df 91       	pop	r29
    3ae2:	08 95       	ret

00003ae4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3ae4:	df 93       	push	r29
    3ae6:	cf 93       	push	r28
    3ae8:	00 d0       	rcall	.+0      	; 0x3aea <xTaskGetTickCount+0x6>
    3aea:	cd b7       	in	r28, 0x3d	; 61
    3aec:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3aee:	0f b6       	in	r0, 0x3f	; 63
    3af0:	f8 94       	cli
    3af2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3af4:	80 91 a6 03 	lds	r24, 0x03A6
    3af8:	90 91 a7 03 	lds	r25, 0x03A7
    3afc:	9a 83       	std	Y+2, r25	; 0x02
    3afe:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3b00:	0f 90       	pop	r0
    3b02:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3b04:	89 81       	ldd	r24, Y+1	; 0x01
    3b06:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3b08:	0f 90       	pop	r0
    3b0a:	0f 90       	pop	r0
    3b0c:	cf 91       	pop	r28
    3b0e:	df 91       	pop	r29
    3b10:	08 95       	ret

00003b12 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3b12:	df 93       	push	r29
    3b14:	cf 93       	push	r28
    3b16:	00 d0       	rcall	.+0      	; 0x3b18 <xTaskGetTickCountFromISR+0x6>
    3b18:	0f 92       	push	r0
    3b1a:	cd b7       	in	r28, 0x3d	; 61
    3b1c:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3b1e:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3b20:	80 91 a6 03 	lds	r24, 0x03A6
    3b24:	90 91 a7 03 	lds	r25, 0x03A7
    3b28:	9b 83       	std	Y+3, r25	; 0x03
    3b2a:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b2e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3b30:	0f 90       	pop	r0
    3b32:	0f 90       	pop	r0
    3b34:	0f 90       	pop	r0
    3b36:	cf 91       	pop	r28
    3b38:	df 91       	pop	r29
    3b3a:	08 95       	ret

00003b3c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3b3c:	df 93       	push	r29
    3b3e:	cf 93       	push	r28
    3b40:	cd b7       	in	r28, 0x3d	; 61
    3b42:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3b44:	80 91 a5 03 	lds	r24, 0x03A5
}
    3b48:	cf 91       	pop	r28
    3b4a:	df 91       	pop	r29
    3b4c:	08 95       	ret

00003b4e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3b4e:	df 93       	push	r29
    3b50:	cf 93       	push	r28
    3b52:	00 d0       	rcall	.+0      	; 0x3b54 <vTaskIncrementTick+0x6>
    3b54:	00 d0       	rcall	.+0      	; 0x3b56 <vTaskIncrementTick+0x8>
    3b56:	00 d0       	rcall	.+0      	; 0x3b58 <vTaskIncrementTick+0xa>
    3b58:	cd b7       	in	r28, 0x3d	; 61
    3b5a:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3b5c:	80 91 ab 03 	lds	r24, 0x03AB
    3b60:	88 23       	and	r24, r24
    3b62:	09 f0       	breq	.+2      	; 0x3b66 <vTaskIncrementTick+0x18>
    3b64:	bb c0       	rjmp	.+374    	; 0x3cdc <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3b66:	80 91 a6 03 	lds	r24, 0x03A6
    3b6a:	90 91 a7 03 	lds	r25, 0x03A7
    3b6e:	01 96       	adiw	r24, 0x01	; 1
    3b70:	90 93 a7 03 	sts	0x03A7, r25
    3b74:	80 93 a6 03 	sts	0x03A6, r24
		if( xTickCount == ( portTickType ) 0U )
    3b78:	80 91 a6 03 	lds	r24, 0x03A6
    3b7c:	90 91 a7 03 	lds	r25, 0x03A7
    3b80:	00 97       	sbiw	r24, 0x00	; 0
    3b82:	d1 f5       	brne	.+116    	; 0x3bf8 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3b84:	80 91 dd 03 	lds	r24, 0x03DD
    3b88:	90 91 de 03 	lds	r25, 0x03DE
    3b8c:	9c 83       	std	Y+4, r25	; 0x04
    3b8e:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3b90:	80 91 df 03 	lds	r24, 0x03DF
    3b94:	90 91 e0 03 	lds	r25, 0x03E0
    3b98:	90 93 de 03 	sts	0x03DE, r25
    3b9c:	80 93 dd 03 	sts	0x03DD, r24
			pxOverflowDelayedTaskList = pxTemp;
    3ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ba4:	90 93 e0 03 	sts	0x03E0, r25
    3ba8:	80 93 df 03 	sts	0x03DF, r24
			xNumOfOverflows++;
    3bac:	80 91 ae 03 	lds	r24, 0x03AE
    3bb0:	8f 5f       	subi	r24, 0xFF	; 255
    3bb2:	80 93 ae 03 	sts	0x03AE, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3bb6:	e0 91 dd 03 	lds	r30, 0x03DD
    3bba:	f0 91 de 03 	lds	r31, 0x03DE
    3bbe:	80 81       	ld	r24, Z
    3bc0:	88 23       	and	r24, r24
    3bc2:	39 f4       	brne	.+14     	; 0x3bd2 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    3bc4:	8f ef       	ldi	r24, 0xFF	; 255
    3bc6:	9f ef       	ldi	r25, 0xFF	; 255
    3bc8:	90 93 0d 01 	sts	0x010D, r25
    3bcc:	80 93 0c 01 	sts	0x010C, r24
    3bd0:	13 c0       	rjmp	.+38     	; 0x3bf8 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3bd2:	e0 91 dd 03 	lds	r30, 0x03DD
    3bd6:	f0 91 de 03 	lds	r31, 0x03DE
    3bda:	05 80       	ldd	r0, Z+5	; 0x05
    3bdc:	f6 81       	ldd	r31, Z+6	; 0x06
    3bde:	e0 2d       	mov	r30, r0
    3be0:	86 81       	ldd	r24, Z+6	; 0x06
    3be2:	97 81       	ldd	r25, Z+7	; 0x07
    3be4:	9e 83       	std	Y+6, r25	; 0x06
    3be6:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3be8:	ed 81       	ldd	r30, Y+5	; 0x05
    3bea:	fe 81       	ldd	r31, Y+6	; 0x06
    3bec:	82 81       	ldd	r24, Z+2	; 0x02
    3bee:	93 81       	ldd	r25, Z+3	; 0x03
    3bf0:	90 93 0d 01 	sts	0x010D, r25
    3bf4:	80 93 0c 01 	sts	0x010C, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    3bf8:	20 91 a6 03 	lds	r18, 0x03A6
    3bfc:	30 91 a7 03 	lds	r19, 0x03A7
    3c00:	80 91 0c 01 	lds	r24, 0x010C
    3c04:	90 91 0d 01 	lds	r25, 0x010D
    3c08:	28 17       	cp	r18, r24
    3c0a:	39 07       	cpc	r19, r25
    3c0c:	08 f4       	brcc	.+2      	; 0x3c10 <vTaskIncrementTick+0xc2>
    3c0e:	6b c0       	rjmp	.+214    	; 0x3ce6 <vTaskIncrementTick+0x198>
    3c10:	e0 91 dd 03 	lds	r30, 0x03DD
    3c14:	f0 91 de 03 	lds	r31, 0x03DE
    3c18:	80 81       	ld	r24, Z
    3c1a:	88 23       	and	r24, r24
    3c1c:	39 f4       	brne	.+14     	; 0x3c2c <vTaskIncrementTick+0xde>
    3c1e:	8f ef       	ldi	r24, 0xFF	; 255
    3c20:	9f ef       	ldi	r25, 0xFF	; 255
    3c22:	90 93 0d 01 	sts	0x010D, r25
    3c26:	80 93 0c 01 	sts	0x010C, r24
    3c2a:	5d c0       	rjmp	.+186    	; 0x3ce6 <vTaskIncrementTick+0x198>
    3c2c:	e0 91 dd 03 	lds	r30, 0x03DD
    3c30:	f0 91 de 03 	lds	r31, 0x03DE
    3c34:	05 80       	ldd	r0, Z+5	; 0x05
    3c36:	f6 81       	ldd	r31, Z+6	; 0x06
    3c38:	e0 2d       	mov	r30, r0
    3c3a:	86 81       	ldd	r24, Z+6	; 0x06
    3c3c:	97 81       	ldd	r25, Z+7	; 0x07
    3c3e:	9e 83       	std	Y+6, r25	; 0x06
    3c40:	8d 83       	std	Y+5, r24	; 0x05
    3c42:	ed 81       	ldd	r30, Y+5	; 0x05
    3c44:	fe 81       	ldd	r31, Y+6	; 0x06
    3c46:	82 81       	ldd	r24, Z+2	; 0x02
    3c48:	93 81       	ldd	r25, Z+3	; 0x03
    3c4a:	9a 83       	std	Y+2, r25	; 0x02
    3c4c:	89 83       	std	Y+1, r24	; 0x01
    3c4e:	20 91 a6 03 	lds	r18, 0x03A6
    3c52:	30 91 a7 03 	lds	r19, 0x03A7
    3c56:	89 81       	ldd	r24, Y+1	; 0x01
    3c58:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5a:	28 17       	cp	r18, r24
    3c5c:	39 07       	cpc	r19, r25
    3c5e:	38 f4       	brcc	.+14     	; 0x3c6e <vTaskIncrementTick+0x120>
    3c60:	89 81       	ldd	r24, Y+1	; 0x01
    3c62:	9a 81       	ldd	r25, Y+2	; 0x02
    3c64:	90 93 0d 01 	sts	0x010D, r25
    3c68:	80 93 0c 01 	sts	0x010C, r24
    3c6c:	3c c0       	rjmp	.+120    	; 0x3ce6 <vTaskIncrementTick+0x198>
    3c6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3c70:	9e 81       	ldd	r25, Y+6	; 0x06
    3c72:	02 96       	adiw	r24, 0x02	; 2
    3c74:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
    3c78:	ed 81       	ldd	r30, Y+5	; 0x05
    3c7a:	fe 81       	ldd	r31, Y+6	; 0x06
    3c7c:	84 89       	ldd	r24, Z+20	; 0x14
    3c7e:	95 89       	ldd	r25, Z+21	; 0x15
    3c80:	00 97       	sbiw	r24, 0x00	; 0
    3c82:	29 f0       	breq	.+10     	; 0x3c8e <vTaskIncrementTick+0x140>
    3c84:	8d 81       	ldd	r24, Y+5	; 0x05
    3c86:	9e 81       	ldd	r25, Y+6	; 0x06
    3c88:	0c 96       	adiw	r24, 0x0c	; 12
    3c8a:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
    3c8e:	ed 81       	ldd	r30, Y+5	; 0x05
    3c90:	fe 81       	ldd	r31, Y+6	; 0x06
    3c92:	96 89       	ldd	r25, Z+22	; 0x16
    3c94:	80 91 a9 03 	lds	r24, 0x03A9
    3c98:	89 17       	cp	r24, r25
    3c9a:	28 f4       	brcc	.+10     	; 0x3ca6 <vTaskIncrementTick+0x158>
    3c9c:	ed 81       	ldd	r30, Y+5	; 0x05
    3c9e:	fe 81       	ldd	r31, Y+6	; 0x06
    3ca0:	86 89       	ldd	r24, Z+22	; 0x16
    3ca2:	80 93 a9 03 	sts	0x03A9, r24
    3ca6:	ed 81       	ldd	r30, Y+5	; 0x05
    3ca8:	fe 81       	ldd	r31, Y+6	; 0x06
    3caa:	86 89       	ldd	r24, Z+22	; 0x16
    3cac:	28 2f       	mov	r18, r24
    3cae:	30 e0       	ldi	r19, 0x00	; 0
    3cb0:	c9 01       	movw	r24, r18
    3cb2:	88 0f       	add	r24, r24
    3cb4:	99 1f       	adc	r25, r25
    3cb6:	88 0f       	add	r24, r24
    3cb8:	99 1f       	adc	r25, r25
    3cba:	88 0f       	add	r24, r24
    3cbc:	99 1f       	adc	r25, r25
    3cbe:	82 0f       	add	r24, r18
    3cc0:	93 1f       	adc	r25, r19
    3cc2:	ac 01       	movw	r20, r24
    3cc4:	40 55       	subi	r20, 0x50	; 80
    3cc6:	5c 4f       	sbci	r21, 0xFC	; 252
    3cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    3cca:	9e 81       	ldd	r25, Y+6	; 0x06
    3ccc:	9c 01       	movw	r18, r24
    3cce:	2e 5f       	subi	r18, 0xFE	; 254
    3cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3cd2:	ca 01       	movw	r24, r20
    3cd4:	b9 01       	movw	r22, r18
    3cd6:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>
    3cda:	9a cf       	rjmp	.-204    	; 0x3c10 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3cdc:	80 91 ac 03 	lds	r24, 0x03AC
    3ce0:	8f 5f       	subi	r24, 0xFF	; 255
    3ce2:	80 93 ac 03 	sts	0x03AC, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3ce6:	26 96       	adiw	r28, 0x06	; 6
    3ce8:	0f b6       	in	r0, 0x3f	; 63
    3cea:	f8 94       	cli
    3cec:	de bf       	out	0x3e, r29	; 62
    3cee:	0f be       	out	0x3f, r0	; 63
    3cf0:	cd bf       	out	0x3d, r28	; 61
    3cf2:	cf 91       	pop	r28
    3cf4:	df 91       	pop	r29
    3cf6:	08 95       	ret

00003cf8 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3cf8:	df 93       	push	r29
    3cfa:	cf 93       	push	r28
    3cfc:	00 d0       	rcall	.+0      	; 0x3cfe <vTaskSwitchContext+0x6>
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3d02:	80 91 ab 03 	lds	r24, 0x03AB
    3d06:	88 23       	and	r24, r24
    3d08:	49 f0       	breq	.+18     	; 0x3d1c <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3d0a:	81 e0       	ldi	r24, 0x01	; 1
    3d0c:	80 93 ad 03 	sts	0x03AD, r24
    3d10:	54 c0       	rjmp	.+168    	; 0x3dba <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3d12:	80 91 a9 03 	lds	r24, 0x03A9
    3d16:	81 50       	subi	r24, 0x01	; 1
    3d18:	80 93 a9 03 	sts	0x03A9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3d1c:	80 91 a9 03 	lds	r24, 0x03A9
    3d20:	28 2f       	mov	r18, r24
    3d22:	30 e0       	ldi	r19, 0x00	; 0
    3d24:	c9 01       	movw	r24, r18
    3d26:	88 0f       	add	r24, r24
    3d28:	99 1f       	adc	r25, r25
    3d2a:	88 0f       	add	r24, r24
    3d2c:	99 1f       	adc	r25, r25
    3d2e:	88 0f       	add	r24, r24
    3d30:	99 1f       	adc	r25, r25
    3d32:	82 0f       	add	r24, r18
    3d34:	93 1f       	adc	r25, r19
    3d36:	fc 01       	movw	r30, r24
    3d38:	e0 55       	subi	r30, 0x50	; 80
    3d3a:	fc 4f       	sbci	r31, 0xFC	; 252
    3d3c:	80 81       	ld	r24, Z
    3d3e:	88 23       	and	r24, r24
    3d40:	41 f3       	breq	.-48     	; 0x3d12 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3d42:	80 91 a9 03 	lds	r24, 0x03A9
    3d46:	28 2f       	mov	r18, r24
    3d48:	30 e0       	ldi	r19, 0x00	; 0
    3d4a:	c9 01       	movw	r24, r18
    3d4c:	88 0f       	add	r24, r24
    3d4e:	99 1f       	adc	r25, r25
    3d50:	88 0f       	add	r24, r24
    3d52:	99 1f       	adc	r25, r25
    3d54:	88 0f       	add	r24, r24
    3d56:	99 1f       	adc	r25, r25
    3d58:	82 0f       	add	r24, r18
    3d5a:	93 1f       	adc	r25, r19
    3d5c:	80 55       	subi	r24, 0x50	; 80
    3d5e:	9c 4f       	sbci	r25, 0xFC	; 252
    3d60:	9a 83       	std	Y+2, r25	; 0x02
    3d62:	89 83       	std	Y+1, r24	; 0x01
    3d64:	e9 81       	ldd	r30, Y+1	; 0x01
    3d66:	fa 81       	ldd	r31, Y+2	; 0x02
    3d68:	01 80       	ldd	r0, Z+1	; 0x01
    3d6a:	f2 81       	ldd	r31, Z+2	; 0x02
    3d6c:	e0 2d       	mov	r30, r0
    3d6e:	82 81       	ldd	r24, Z+2	; 0x02
    3d70:	93 81       	ldd	r25, Z+3	; 0x03
    3d72:	e9 81       	ldd	r30, Y+1	; 0x01
    3d74:	fa 81       	ldd	r31, Y+2	; 0x02
    3d76:	92 83       	std	Z+2, r25	; 0x02
    3d78:	81 83       	std	Z+1, r24	; 0x01
    3d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d7e:	21 81       	ldd	r18, Z+1	; 0x01
    3d80:	32 81       	ldd	r19, Z+2	; 0x02
    3d82:	89 81       	ldd	r24, Y+1	; 0x01
    3d84:	9a 81       	ldd	r25, Y+2	; 0x02
    3d86:	03 96       	adiw	r24, 0x03	; 3
    3d88:	28 17       	cp	r18, r24
    3d8a:	39 07       	cpc	r19, r25
    3d8c:	59 f4       	brne	.+22     	; 0x3da4 <vTaskSwitchContext+0xac>
    3d8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d90:	fa 81       	ldd	r31, Y+2	; 0x02
    3d92:	01 80       	ldd	r0, Z+1	; 0x01
    3d94:	f2 81       	ldd	r31, Z+2	; 0x02
    3d96:	e0 2d       	mov	r30, r0
    3d98:	82 81       	ldd	r24, Z+2	; 0x02
    3d9a:	93 81       	ldd	r25, Z+3	; 0x03
    3d9c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d9e:	fa 81       	ldd	r31, Y+2	; 0x02
    3da0:	92 83       	std	Z+2, r25	; 0x02
    3da2:	81 83       	std	Z+1, r24	; 0x01
    3da4:	e9 81       	ldd	r30, Y+1	; 0x01
    3da6:	fa 81       	ldd	r31, Y+2	; 0x02
    3da8:	01 80       	ldd	r0, Z+1	; 0x01
    3daa:	f2 81       	ldd	r31, Z+2	; 0x02
    3dac:	e0 2d       	mov	r30, r0
    3dae:	86 81       	ldd	r24, Z+6	; 0x06
    3db0:	97 81       	ldd	r25, Z+7	; 0x07
    3db2:	90 93 a3 03 	sts	0x03A3, r25
    3db6:	80 93 a2 03 	sts	0x03A2, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	cf 91       	pop	r28
    3dc0:	df 91       	pop	r29
    3dc2:	08 95       	ret

00003dc4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3dc4:	df 93       	push	r29
    3dc6:	cf 93       	push	r28
    3dc8:	00 d0       	rcall	.+0      	; 0x3dca <vTaskPlaceOnEventList+0x6>
    3dca:	00 d0       	rcall	.+0      	; 0x3dcc <vTaskPlaceOnEventList+0x8>
    3dcc:	00 d0       	rcall	.+0      	; 0x3dce <vTaskPlaceOnEventList+0xa>
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
    3dd2:	9c 83       	std	Y+4, r25	; 0x04
    3dd4:	8b 83       	std	Y+3, r24	; 0x03
    3dd6:	7e 83       	std	Y+6, r23	; 0x06
    3dd8:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3dda:	4b 81       	ldd	r20, Y+3	; 0x03
    3ddc:	5c 81       	ldd	r21, Y+4	; 0x04
    3dde:	80 91 a2 03 	lds	r24, 0x03A2
    3de2:	90 91 a3 03 	lds	r25, 0x03A3
    3de6:	9c 01       	movw	r18, r24
    3de8:	24 5f       	subi	r18, 0xF4	; 244
    3dea:	3f 4f       	sbci	r19, 0xFF	; 255
    3dec:	ca 01       	movw	r24, r20
    3dee:	b9 01       	movw	r22, r18
    3df0:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3df4:	80 91 a2 03 	lds	r24, 0x03A2
    3df8:	90 91 a3 03 	lds	r25, 0x03A3
    3dfc:	02 96       	adiw	r24, 0x02	; 2
    3dfe:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3e02:	20 91 a6 03 	lds	r18, 0x03A6
    3e06:	30 91 a7 03 	lds	r19, 0x03A7
    3e0a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e0c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e0e:	82 0f       	add	r24, r18
    3e10:	93 1f       	adc	r25, r19
    3e12:	9a 83       	std	Y+2, r25	; 0x02
    3e14:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3e16:	89 81       	ldd	r24, Y+1	; 0x01
    3e18:	9a 81       	ldd	r25, Y+2	; 0x02
    3e1a:	0e 94 dc 20 	call	0x41b8	; 0x41b8 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3e1e:	26 96       	adiw	r28, 0x06	; 6
    3e20:	0f b6       	in	r0, 0x3f	; 63
    3e22:	f8 94       	cli
    3e24:	de bf       	out	0x3e, r29	; 62
    3e26:	0f be       	out	0x3f, r0	; 63
    3e28:	cd bf       	out	0x3d, r28	; 61
    3e2a:	cf 91       	pop	r28
    3e2c:	df 91       	pop	r29
    3e2e:	08 95       	ret

00003e30 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3e30:	df 93       	push	r29
    3e32:	cf 93       	push	r28
    3e34:	00 d0       	rcall	.+0      	; 0x3e36 <xTaskRemoveFromEventList+0x6>
    3e36:	00 d0       	rcall	.+0      	; 0x3e38 <xTaskRemoveFromEventList+0x8>
    3e38:	0f 92       	push	r0
    3e3a:	cd b7       	in	r28, 0x3d	; 61
    3e3c:	de b7       	in	r29, 0x3e	; 62
    3e3e:	9d 83       	std	Y+5, r25	; 0x05
    3e40:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3e42:	ec 81       	ldd	r30, Y+4	; 0x04
    3e44:	fd 81       	ldd	r31, Y+5	; 0x05
    3e46:	05 80       	ldd	r0, Z+5	; 0x05
    3e48:	f6 81       	ldd	r31, Z+6	; 0x06
    3e4a:	e0 2d       	mov	r30, r0
    3e4c:	86 81       	ldd	r24, Z+6	; 0x06
    3e4e:	97 81       	ldd	r25, Z+7	; 0x07
    3e50:	9b 83       	std	Y+3, r25	; 0x03
    3e52:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3e54:	8a 81       	ldd	r24, Y+2	; 0x02
    3e56:	9b 81       	ldd	r25, Y+3	; 0x03
    3e58:	0c 96       	adiw	r24, 0x0c	; 12
    3e5a:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3e5e:	80 91 ab 03 	lds	r24, 0x03AB
    3e62:	88 23       	and	r24, r24
    3e64:	61 f5       	brne	.+88     	; 0x3ebe <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3e66:	8a 81       	ldd	r24, Y+2	; 0x02
    3e68:	9b 81       	ldd	r25, Y+3	; 0x03
    3e6a:	02 96       	adiw	r24, 0x02	; 2
    3e6c:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3e70:	ea 81       	ldd	r30, Y+2	; 0x02
    3e72:	fb 81       	ldd	r31, Y+3	; 0x03
    3e74:	96 89       	ldd	r25, Z+22	; 0x16
    3e76:	80 91 a9 03 	lds	r24, 0x03A9
    3e7a:	89 17       	cp	r24, r25
    3e7c:	28 f4       	brcc	.+10     	; 0x3e88 <xTaskRemoveFromEventList+0x58>
    3e7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3e80:	fb 81       	ldd	r31, Y+3	; 0x03
    3e82:	86 89       	ldd	r24, Z+22	; 0x16
    3e84:	80 93 a9 03 	sts	0x03A9, r24
    3e88:	ea 81       	ldd	r30, Y+2	; 0x02
    3e8a:	fb 81       	ldd	r31, Y+3	; 0x03
    3e8c:	86 89       	ldd	r24, Z+22	; 0x16
    3e8e:	28 2f       	mov	r18, r24
    3e90:	30 e0       	ldi	r19, 0x00	; 0
    3e92:	c9 01       	movw	r24, r18
    3e94:	88 0f       	add	r24, r24
    3e96:	99 1f       	adc	r25, r25
    3e98:	88 0f       	add	r24, r24
    3e9a:	99 1f       	adc	r25, r25
    3e9c:	88 0f       	add	r24, r24
    3e9e:	99 1f       	adc	r25, r25
    3ea0:	82 0f       	add	r24, r18
    3ea2:	93 1f       	adc	r25, r19
    3ea4:	ac 01       	movw	r20, r24
    3ea6:	40 55       	subi	r20, 0x50	; 80
    3ea8:	5c 4f       	sbci	r21, 0xFC	; 252
    3eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3eac:	9b 81       	ldd	r25, Y+3	; 0x03
    3eae:	9c 01       	movw	r18, r24
    3eb0:	2e 5f       	subi	r18, 0xFE	; 254
    3eb2:	3f 4f       	sbci	r19, 0xFF	; 255
    3eb4:	ca 01       	movw	r24, r20
    3eb6:	b9 01       	movw	r22, r18
    3eb8:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>
    3ebc:	0a c0       	rjmp	.+20     	; 0x3ed2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3ebe:	8a 81       	ldd	r24, Y+2	; 0x02
    3ec0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ec2:	9c 01       	movw	r18, r24
    3ec4:	24 5f       	subi	r18, 0xF4	; 244
    3ec6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ec8:	81 ee       	ldi	r24, 0xE1	; 225
    3eca:	93 e0       	ldi	r25, 0x03	; 3
    3ecc:	b9 01       	movw	r22, r18
    3ece:	0e 94 3e 12 	call	0x247c	; 0x247c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3ed2:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed4:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed6:	96 89       	ldd	r25, Z+22	; 0x16
    3ed8:	e0 91 a2 03 	lds	r30, 0x03A2
    3edc:	f0 91 a3 03 	lds	r31, 0x03A3
    3ee0:	86 89       	ldd	r24, Z+22	; 0x16
    3ee2:	98 17       	cp	r25, r24
    3ee4:	18 f0       	brcs	.+6      	; 0x3eec <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3ee6:	81 e0       	ldi	r24, 0x01	; 1
    3ee8:	89 83       	std	Y+1, r24	; 0x01
    3eea:	01 c0       	rjmp	.+2      	; 0x3eee <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3eec:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3eee:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ef0:	0f 90       	pop	r0
    3ef2:	0f 90       	pop	r0
    3ef4:	0f 90       	pop	r0
    3ef6:	0f 90       	pop	r0
    3ef8:	0f 90       	pop	r0
    3efa:	cf 91       	pop	r28
    3efc:	df 91       	pop	r29
    3efe:	08 95       	ret

00003f00 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    3f00:	df 93       	push	r29
    3f02:	cf 93       	push	r28
    3f04:	00 d0       	rcall	.+0      	; 0x3f06 <vTaskSetTimeOutState+0x6>
    3f06:	cd b7       	in	r28, 0x3d	; 61
    3f08:	de b7       	in	r29, 0x3e	; 62
    3f0a:	9a 83       	std	Y+2, r25	; 0x02
    3f0c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3f0e:	80 91 ae 03 	lds	r24, 0x03AE
    3f12:	e9 81       	ldd	r30, Y+1	; 0x01
    3f14:	fa 81       	ldd	r31, Y+2	; 0x02
    3f16:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3f18:	80 91 a6 03 	lds	r24, 0x03A6
    3f1c:	90 91 a7 03 	lds	r25, 0x03A7
    3f20:	e9 81       	ldd	r30, Y+1	; 0x01
    3f22:	fa 81       	ldd	r31, Y+2	; 0x02
    3f24:	92 83       	std	Z+2, r25	; 0x02
    3f26:	81 83       	std	Z+1, r24	; 0x01
}
    3f28:	0f 90       	pop	r0
    3f2a:	0f 90       	pop	r0
    3f2c:	cf 91       	pop	r28
    3f2e:	df 91       	pop	r29
    3f30:	08 95       	ret

00003f32 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3f32:	df 93       	push	r29
    3f34:	cf 93       	push	r28
    3f36:	00 d0       	rcall	.+0      	; 0x3f38 <xTaskCheckForTimeOut+0x6>
    3f38:	00 d0       	rcall	.+0      	; 0x3f3a <xTaskCheckForTimeOut+0x8>
    3f3a:	0f 92       	push	r0
    3f3c:	cd b7       	in	r28, 0x3d	; 61
    3f3e:	de b7       	in	r29, 0x3e	; 62
    3f40:	9b 83       	std	Y+3, r25	; 0x03
    3f42:	8a 83       	std	Y+2, r24	; 0x02
    3f44:	7d 83       	std	Y+5, r23	; 0x05
    3f46:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3f48:	0f b6       	in	r0, 0x3f	; 63
    3f4a:	f8 94       	cli
    3f4c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3f4e:	ea 81       	ldd	r30, Y+2	; 0x02
    3f50:	fb 81       	ldd	r31, Y+3	; 0x03
    3f52:	90 81       	ld	r25, Z
    3f54:	80 91 ae 03 	lds	r24, 0x03AE
    3f58:	98 17       	cp	r25, r24
    3f5a:	71 f0       	breq	.+28     	; 0x3f78 <xTaskCheckForTimeOut+0x46>
    3f5c:	ea 81       	ldd	r30, Y+2	; 0x02
    3f5e:	fb 81       	ldd	r31, Y+3	; 0x03
    3f60:	21 81       	ldd	r18, Z+1	; 0x01
    3f62:	32 81       	ldd	r19, Z+2	; 0x02
    3f64:	80 91 a6 03 	lds	r24, 0x03A6
    3f68:	90 91 a7 03 	lds	r25, 0x03A7
    3f6c:	82 17       	cp	r24, r18
    3f6e:	93 07       	cpc	r25, r19
    3f70:	18 f0       	brcs	.+6      	; 0x3f78 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3f72:	81 e0       	ldi	r24, 0x01	; 1
    3f74:	89 83       	std	Y+1, r24	; 0x01
    3f76:	2f c0       	rjmp	.+94     	; 0x3fd6 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3f78:	20 91 a6 03 	lds	r18, 0x03A6
    3f7c:	30 91 a7 03 	lds	r19, 0x03A7
    3f80:	ea 81       	ldd	r30, Y+2	; 0x02
    3f82:	fb 81       	ldd	r31, Y+3	; 0x03
    3f84:	81 81       	ldd	r24, Z+1	; 0x01
    3f86:	92 81       	ldd	r25, Z+2	; 0x02
    3f88:	28 1b       	sub	r18, r24
    3f8a:	39 0b       	sbc	r19, r25
    3f8c:	ec 81       	ldd	r30, Y+4	; 0x04
    3f8e:	fd 81       	ldd	r31, Y+5	; 0x05
    3f90:	80 81       	ld	r24, Z
    3f92:	91 81       	ldd	r25, Z+1	; 0x01
    3f94:	28 17       	cp	r18, r24
    3f96:	39 07       	cpc	r19, r25
    3f98:	e0 f4       	brcc	.+56     	; 0x3fd2 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3f9a:	ec 81       	ldd	r30, Y+4	; 0x04
    3f9c:	fd 81       	ldd	r31, Y+5	; 0x05
    3f9e:	40 81       	ld	r20, Z
    3fa0:	51 81       	ldd	r21, Z+1	; 0x01
    3fa2:	ea 81       	ldd	r30, Y+2	; 0x02
    3fa4:	fb 81       	ldd	r31, Y+3	; 0x03
    3fa6:	21 81       	ldd	r18, Z+1	; 0x01
    3fa8:	32 81       	ldd	r19, Z+2	; 0x02
    3faa:	80 91 a6 03 	lds	r24, 0x03A6
    3fae:	90 91 a7 03 	lds	r25, 0x03A7
    3fb2:	b9 01       	movw	r22, r18
    3fb4:	68 1b       	sub	r22, r24
    3fb6:	79 0b       	sbc	r23, r25
    3fb8:	cb 01       	movw	r24, r22
    3fba:	84 0f       	add	r24, r20
    3fbc:	95 1f       	adc	r25, r21
    3fbe:	ec 81       	ldd	r30, Y+4	; 0x04
    3fc0:	fd 81       	ldd	r31, Y+5	; 0x05
    3fc2:	91 83       	std	Z+1, r25	; 0x01
    3fc4:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3fca:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3fce:	19 82       	std	Y+1, r1	; 0x01
    3fd0:	02 c0       	rjmp	.+4      	; 0x3fd6 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    3fd2:	81 e0       	ldi	r24, 0x01	; 1
    3fd4:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3fd6:	0f 90       	pop	r0
    3fd8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3fda:	89 81       	ldd	r24, Y+1	; 0x01
}
    3fdc:	0f 90       	pop	r0
    3fde:	0f 90       	pop	r0
    3fe0:	0f 90       	pop	r0
    3fe2:	0f 90       	pop	r0
    3fe4:	0f 90       	pop	r0
    3fe6:	cf 91       	pop	r28
    3fe8:	df 91       	pop	r29
    3fea:	08 95       	ret

00003fec <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3fec:	df 93       	push	r29
    3fee:	cf 93       	push	r28
    3ff0:	cd b7       	in	r28, 0x3d	; 61
    3ff2:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3ff4:	81 e0       	ldi	r24, 0x01	; 1
    3ff6:	80 93 ad 03 	sts	0x03AD, r24
}
    3ffa:	cf 91       	pop	r28
    3ffc:	df 91       	pop	r29
    3ffe:	08 95       	ret

00004000 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4000:	df 93       	push	r29
    4002:	cf 93       	push	r28
    4004:	00 d0       	rcall	.+0      	; 0x4006 <prvIdleTask+0x6>
    4006:	cd b7       	in	r28, 0x3d	; 61
    4008:	de b7       	in	r29, 0x3e	; 62
    400a:	9a 83       	std	Y+2, r25	; 0x02
    400c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    400e:	0e 94 9e 20 	call	0x413c	; 0x413c <prvCheckTasksWaitingTermination>
    4012:	fd cf       	rjmp	.-6      	; 0x400e <prvIdleTask+0xe>

00004014 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4014:	0f 93       	push	r16
    4016:	1f 93       	push	r17
    4018:	df 93       	push	r29
    401a:	cf 93       	push	r28
    401c:	cd b7       	in	r28, 0x3d	; 61
    401e:	de b7       	in	r29, 0x3e	; 62
    4020:	29 97       	sbiw	r28, 0x09	; 9
    4022:	0f b6       	in	r0, 0x3f	; 63
    4024:	f8 94       	cli
    4026:	de bf       	out	0x3e, r29	; 62
    4028:	0f be       	out	0x3f, r0	; 63
    402a:	cd bf       	out	0x3d, r28	; 61
    402c:	9a 83       	std	Y+2, r25	; 0x02
    402e:	89 83       	std	Y+1, r24	; 0x01
    4030:	7c 83       	std	Y+4, r23	; 0x04
    4032:	6b 83       	std	Y+3, r22	; 0x03
    4034:	4d 83       	std	Y+5, r20	; 0x05
    4036:	3f 83       	std	Y+7, r19	; 0x07
    4038:	2e 83       	std	Y+6, r18	; 0x06
    403a:	19 87       	std	Y+9, r17	; 0x09
    403c:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    403e:	89 81       	ldd	r24, Y+1	; 0x01
    4040:	9a 81       	ldd	r25, Y+2	; 0x02
    4042:	49 96       	adiw	r24, 0x19	; 25
    4044:	2b 81       	ldd	r18, Y+3	; 0x03
    4046:	3c 81       	ldd	r19, Y+4	; 0x04
    4048:	b9 01       	movw	r22, r18
    404a:	44 e1       	ldi	r20, 0x14	; 20
    404c:	50 e0       	ldi	r21, 0x00	; 0
    404e:	0e 94 39 24 	call	0x4872	; 0x4872 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	14 a6       	std	Z+44, r1	; 0x2c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4058:	8d 81       	ldd	r24, Y+5	; 0x05
    405a:	83 30       	cpi	r24, 0x03	; 3
    405c:	10 f0       	brcs	.+4      	; 0x4062 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    405e:	82 e0       	ldi	r24, 0x02	; 2
    4060:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4062:	e9 81       	ldd	r30, Y+1	; 0x01
    4064:	fa 81       	ldd	r31, Y+2	; 0x02
    4066:	8d 81       	ldd	r24, Y+5	; 0x05
    4068:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    406a:	89 81       	ldd	r24, Y+1	; 0x01
    406c:	9a 81       	ldd	r25, Y+2	; 0x02
    406e:	02 96       	adiw	r24, 0x02	; 2
    4070:	0e 94 2e 12 	call	0x245c	; 0x245c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4074:	89 81       	ldd	r24, Y+1	; 0x01
    4076:	9a 81       	ldd	r25, Y+2	; 0x02
    4078:	0c 96       	adiw	r24, 0x0c	; 12
    407a:	0e 94 2e 12 	call	0x245c	; 0x245c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    407e:	e9 81       	ldd	r30, Y+1	; 0x01
    4080:	fa 81       	ldd	r31, Y+2	; 0x02
    4082:	89 81       	ldd	r24, Y+1	; 0x01
    4084:	9a 81       	ldd	r25, Y+2	; 0x02
    4086:	91 87       	std	Z+9, r25	; 0x09
    4088:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    408a:	8d 81       	ldd	r24, Y+5	; 0x05
    408c:	28 2f       	mov	r18, r24
    408e:	30 e0       	ldi	r19, 0x00	; 0
    4090:	83 e0       	ldi	r24, 0x03	; 3
    4092:	90 e0       	ldi	r25, 0x00	; 0
    4094:	82 1b       	sub	r24, r18
    4096:	93 0b       	sbc	r25, r19
    4098:	e9 81       	ldd	r30, Y+1	; 0x01
    409a:	fa 81       	ldd	r31, Y+2	; 0x02
    409c:	95 87       	std	Z+13, r25	; 0x0d
    409e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    40a0:	e9 81       	ldd	r30, Y+1	; 0x01
    40a2:	fa 81       	ldd	r31, Y+2	; 0x02
    40a4:	89 81       	ldd	r24, Y+1	; 0x01
    40a6:	9a 81       	ldd	r25, Y+2	; 0x02
    40a8:	93 8b       	std	Z+19, r25	; 0x13
    40aa:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    40ac:	29 96       	adiw	r28, 0x09	; 9
    40ae:	0f b6       	in	r0, 0x3f	; 63
    40b0:	f8 94       	cli
    40b2:	de bf       	out	0x3e, r29	; 62
    40b4:	0f be       	out	0x3f, r0	; 63
    40b6:	cd bf       	out	0x3d, r28	; 61
    40b8:	cf 91       	pop	r28
    40ba:	df 91       	pop	r29
    40bc:	1f 91       	pop	r17
    40be:	0f 91       	pop	r16
    40c0:	08 95       	ret

000040c2 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    40c2:	df 93       	push	r29
    40c4:	cf 93       	push	r28
    40c6:	0f 92       	push	r0
    40c8:	cd b7       	in	r28, 0x3d	; 61
    40ca:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    40cc:	19 82       	std	Y+1, r1	; 0x01
    40ce:	13 c0       	rjmp	.+38     	; 0x40f6 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    40d0:	89 81       	ldd	r24, Y+1	; 0x01
    40d2:	28 2f       	mov	r18, r24
    40d4:	30 e0       	ldi	r19, 0x00	; 0
    40d6:	c9 01       	movw	r24, r18
    40d8:	88 0f       	add	r24, r24
    40da:	99 1f       	adc	r25, r25
    40dc:	88 0f       	add	r24, r24
    40de:	99 1f       	adc	r25, r25
    40e0:	88 0f       	add	r24, r24
    40e2:	99 1f       	adc	r25, r25
    40e4:	82 0f       	add	r24, r18
    40e6:	93 1f       	adc	r25, r19
    40e8:	80 55       	subi	r24, 0x50	; 80
    40ea:	9c 4f       	sbci	r25, 0xFC	; 252
    40ec:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    40f0:	89 81       	ldd	r24, Y+1	; 0x01
    40f2:	8f 5f       	subi	r24, 0xFF	; 255
    40f4:	89 83       	std	Y+1, r24	; 0x01
    40f6:	89 81       	ldd	r24, Y+1	; 0x01
    40f8:	83 30       	cpi	r24, 0x03	; 3
    40fa:	50 f3       	brcs	.-44     	; 0x40d0 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    40fc:	8b ec       	ldi	r24, 0xCB	; 203
    40fe:	93 e0       	ldi	r25, 0x03	; 3
    4100:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4104:	84 ed       	ldi	r24, 0xD4	; 212
    4106:	93 e0       	ldi	r25, 0x03	; 3
    4108:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    410c:	81 ee       	ldi	r24, 0xE1	; 225
    410e:	93 e0       	ldi	r25, 0x03	; 3
    4110:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4114:	8a ee       	ldi	r24, 0xEA	; 234
    4116:	93 e0       	ldi	r25, 0x03	; 3
    4118:	0e 94 04 12 	call	0x2408	; 0x2408 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    411c:	8b ec       	ldi	r24, 0xCB	; 203
    411e:	93 e0       	ldi	r25, 0x03	; 3
    4120:	90 93 de 03 	sts	0x03DE, r25
    4124:	80 93 dd 03 	sts	0x03DD, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4128:	84 ed       	ldi	r24, 0xD4	; 212
    412a:	93 e0       	ldi	r25, 0x03	; 3
    412c:	90 93 e0 03 	sts	0x03E0, r25
    4130:	80 93 df 03 	sts	0x03DF, r24
}
    4134:	0f 90       	pop	r0
    4136:	cf 91       	pop	r28
    4138:	df 91       	pop	r29
    413a:	08 95       	ret

0000413c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    413c:	df 93       	push	r29
    413e:	cf 93       	push	r28
    4140:	00 d0       	rcall	.+0      	; 0x4142 <prvCheckTasksWaitingTermination+0x6>
    4142:	0f 92       	push	r0
    4144:	cd b7       	in	r28, 0x3d	; 61
    4146:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4148:	80 91 a4 03 	lds	r24, 0x03A4
    414c:	88 23       	and	r24, r24
    414e:	71 f1       	breq	.+92     	; 0x41ac <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4150:	0e 94 dc 1c 	call	0x39b8	; 0x39b8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4154:	80 91 ea 03 	lds	r24, 0x03EA
    4158:	1b 82       	std	Y+3, r1	; 0x03
    415a:	88 23       	and	r24, r24
    415c:	11 f4       	brne	.+4      	; 0x4162 <prvCheckTasksWaitingTermination+0x26>
    415e:	81 e0       	ldi	r24, 0x01	; 1
    4160:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4162:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4166:	8b 81       	ldd	r24, Y+3	; 0x03
    4168:	88 23       	and	r24, r24
    416a:	01 f5       	brne	.+64     	; 0x41ac <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    416c:	0f b6       	in	r0, 0x3f	; 63
    416e:	f8 94       	cli
    4170:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4172:	e0 91 ef 03 	lds	r30, 0x03EF
    4176:	f0 91 f0 03 	lds	r31, 0x03F0
    417a:	86 81       	ldd	r24, Z+6	; 0x06
    417c:	97 81       	ldd	r25, Z+7	; 0x07
    417e:	9a 83       	std	Y+2, r25	; 0x02
    4180:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	9a 81       	ldd	r25, Y+2	; 0x02
    4186:	02 96       	adiw	r24, 0x02	; 2
    4188:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vListRemove>
					--uxCurrentNumberOfTasks;
    418c:	80 91 a5 03 	lds	r24, 0x03A5
    4190:	81 50       	subi	r24, 0x01	; 1
    4192:	80 93 a5 03 	sts	0x03A5, r24
					--uxTasksDeleted;
    4196:	80 91 a4 03 	lds	r24, 0x03A4
    419a:	81 50       	subi	r24, 0x01	; 1
    419c:	80 93 a4 03 	sts	0x03A4, r24
				}
				taskEXIT_CRITICAL();
    41a0:	0f 90       	pop	r0
    41a2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    41a4:	89 81       	ldd	r24, Y+1	; 0x01
    41a6:	9a 81       	ldd	r25, Y+2	; 0x02
    41a8:	0e 94 75 21 	call	0x42ea	; 0x42ea <prvDeleteTCB>
			}
		}
	}
	#endif
}
    41ac:	0f 90       	pop	r0
    41ae:	0f 90       	pop	r0
    41b0:	0f 90       	pop	r0
    41b2:	cf 91       	pop	r28
    41b4:	df 91       	pop	r29
    41b6:	08 95       	ret

000041b8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    41b8:	df 93       	push	r29
    41ba:	cf 93       	push	r28
    41bc:	00 d0       	rcall	.+0      	; 0x41be <prvAddCurrentTaskToDelayedList+0x6>
    41be:	cd b7       	in	r28, 0x3d	; 61
    41c0:	de b7       	in	r29, 0x3e	; 62
    41c2:	9a 83       	std	Y+2, r25	; 0x02
    41c4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    41c6:	e0 91 a2 03 	lds	r30, 0x03A2
    41ca:	f0 91 a3 03 	lds	r31, 0x03A3
    41ce:	89 81       	ldd	r24, Y+1	; 0x01
    41d0:	9a 81       	ldd	r25, Y+2	; 0x02
    41d2:	93 83       	std	Z+3, r25	; 0x03
    41d4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    41d6:	20 91 a6 03 	lds	r18, 0x03A6
    41da:	30 91 a7 03 	lds	r19, 0x03A7
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	9a 81       	ldd	r25, Y+2	; 0x02
    41e2:	82 17       	cp	r24, r18
    41e4:	93 07       	cpc	r25, r19
    41e6:	70 f4       	brcc	.+28     	; 0x4204 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    41e8:	80 91 df 03 	lds	r24, 0x03DF
    41ec:	90 91 e0 03 	lds	r25, 0x03E0
    41f0:	20 91 a2 03 	lds	r18, 0x03A2
    41f4:	30 91 a3 03 	lds	r19, 0x03A3
    41f8:	2e 5f       	subi	r18, 0xFE	; 254
    41fa:	3f 4f       	sbci	r19, 0xFF	; 255
    41fc:	b9 01       	movw	r22, r18
    41fe:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>
    4202:	1e c0       	rjmp	.+60     	; 0x4240 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4204:	40 91 dd 03 	lds	r20, 0x03DD
    4208:	50 91 de 03 	lds	r21, 0x03DE
    420c:	80 91 a2 03 	lds	r24, 0x03A2
    4210:	90 91 a3 03 	lds	r25, 0x03A3
    4214:	9c 01       	movw	r18, r24
    4216:	2e 5f       	subi	r18, 0xFE	; 254
    4218:	3f 4f       	sbci	r19, 0xFF	; 255
    421a:	ca 01       	movw	r24, r20
    421c:	b9 01       	movw	r22, r18
    421e:	0e 94 8a 12 	call	0x2514	; 0x2514 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4222:	20 91 0c 01 	lds	r18, 0x010C
    4226:	30 91 0d 01 	lds	r19, 0x010D
    422a:	89 81       	ldd	r24, Y+1	; 0x01
    422c:	9a 81       	ldd	r25, Y+2	; 0x02
    422e:	82 17       	cp	r24, r18
    4230:	93 07       	cpc	r25, r19
    4232:	30 f4       	brcc	.+12     	; 0x4240 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4234:	89 81       	ldd	r24, Y+1	; 0x01
    4236:	9a 81       	ldd	r25, Y+2	; 0x02
    4238:	90 93 0d 01 	sts	0x010D, r25
    423c:	80 93 0c 01 	sts	0x010C, r24
		}
	}
}
    4240:	0f 90       	pop	r0
    4242:	0f 90       	pop	r0
    4244:	cf 91       	pop	r28
    4246:	df 91       	pop	r29
    4248:	08 95       	ret

0000424a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    424a:	df 93       	push	r29
    424c:	cf 93       	push	r28
    424e:	cd b7       	in	r28, 0x3d	; 61
    4250:	de b7       	in	r29, 0x3e	; 62
    4252:	28 97       	sbiw	r28, 0x08	; 8
    4254:	0f b6       	in	r0, 0x3f	; 63
    4256:	f8 94       	cli
    4258:	de bf       	out	0x3e, r29	; 62
    425a:	0f be       	out	0x3f, r0	; 63
    425c:	cd bf       	out	0x3d, r28	; 61
    425e:	9c 83       	std	Y+4, r25	; 0x04
    4260:	8b 83       	std	Y+3, r24	; 0x03
    4262:	7e 83       	std	Y+6, r23	; 0x06
    4264:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4266:	8d e2       	ldi	r24, 0x2D	; 45
    4268:	90 e0       	ldi	r25, 0x00	; 0
    426a:	0e 94 98 11 	call	0x2330	; 0x2330 <pvPortMalloc>
    426e:	9a 83       	std	Y+2, r25	; 0x02
    4270:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4272:	89 81       	ldd	r24, Y+1	; 0x01
    4274:	9a 81       	ldd	r25, Y+2	; 0x02
    4276:	00 97       	sbiw	r24, 0x00	; 0
    4278:	69 f1       	breq	.+90     	; 0x42d4 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    427a:	8d 81       	ldd	r24, Y+5	; 0x05
    427c:	9e 81       	ldd	r25, Y+6	; 0x06
    427e:	00 97       	sbiw	r24, 0x00	; 0
    4280:	39 f4       	brne	.+14     	; 0x4290 <prvAllocateTCBAndStack+0x46>
    4282:	8b 81       	ldd	r24, Y+3	; 0x03
    4284:	9c 81       	ldd	r25, Y+4	; 0x04
    4286:	0e 94 98 11 	call	0x2330	; 0x2330 <pvPortMalloc>
    428a:	98 87       	std	Y+8, r25	; 0x08
    428c:	8f 83       	std	Y+7, r24	; 0x07
    428e:	04 c0       	rjmp	.+8      	; 0x4298 <prvAllocateTCBAndStack+0x4e>
    4290:	8d 81       	ldd	r24, Y+5	; 0x05
    4292:	9e 81       	ldd	r25, Y+6	; 0x06
    4294:	98 87       	std	Y+8, r25	; 0x08
    4296:	8f 83       	std	Y+7, r24	; 0x07
    4298:	e9 81       	ldd	r30, Y+1	; 0x01
    429a:	fa 81       	ldd	r31, Y+2	; 0x02
    429c:	8f 81       	ldd	r24, Y+7	; 0x07
    429e:	98 85       	ldd	r25, Y+8	; 0x08
    42a0:	90 8f       	std	Z+24, r25	; 0x18
    42a2:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    42a4:	e9 81       	ldd	r30, Y+1	; 0x01
    42a6:	fa 81       	ldd	r31, Y+2	; 0x02
    42a8:	87 89       	ldd	r24, Z+23	; 0x17
    42aa:	90 8d       	ldd	r25, Z+24	; 0x18
    42ac:	00 97       	sbiw	r24, 0x00	; 0
    42ae:	39 f4       	brne	.+14     	; 0x42be <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    42b0:	89 81       	ldd	r24, Y+1	; 0x01
    42b2:	9a 81       	ldd	r25, Y+2	; 0x02
    42b4:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
			pxNewTCB = NULL;
    42b8:	1a 82       	std	Y+2, r1	; 0x02
    42ba:	19 82       	std	Y+1, r1	; 0x01
    42bc:	0b c0       	rjmp	.+22     	; 0x42d4 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    42be:	e9 81       	ldd	r30, Y+1	; 0x01
    42c0:	fa 81       	ldd	r31, Y+2	; 0x02
    42c2:	87 89       	ldd	r24, Z+23	; 0x17
    42c4:	90 8d       	ldd	r25, Z+24	; 0x18
    42c6:	2b 81       	ldd	r18, Y+3	; 0x03
    42c8:	3c 81       	ldd	r19, Y+4	; 0x04
    42ca:	65 ea       	ldi	r22, 0xA5	; 165
    42cc:	70 e0       	ldi	r23, 0x00	; 0
    42ce:	a9 01       	movw	r20, r18
    42d0:	0e 94 32 24 	call	0x4864	; 0x4864 <memset>
		}
	}

	return pxNewTCB;
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    42d8:	28 96       	adiw	r28, 0x08	; 8
    42da:	0f b6       	in	r0, 0x3f	; 63
    42dc:	f8 94       	cli
    42de:	de bf       	out	0x3e, r29	; 62
    42e0:	0f be       	out	0x3f, r0	; 63
    42e2:	cd bf       	out	0x3d, r28	; 61
    42e4:	cf 91       	pop	r28
    42e6:	df 91       	pop	r29
    42e8:	08 95       	ret

000042ea <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    42ea:	df 93       	push	r29
    42ec:	cf 93       	push	r28
    42ee:	00 d0       	rcall	.+0      	; 0x42f0 <prvDeleteTCB+0x6>
    42f0:	cd b7       	in	r28, 0x3d	; 61
    42f2:	de b7       	in	r29, 0x3e	; 62
    42f4:	9a 83       	std	Y+2, r25	; 0x02
    42f6:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    42f8:	e9 81       	ldd	r30, Y+1	; 0x01
    42fa:	fa 81       	ldd	r31, Y+2	; 0x02
    42fc:	87 89       	ldd	r24, Z+23	; 0x17
    42fe:	90 8d       	ldd	r25, Z+24	; 0x18
    4300:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
		vPortFree( pxTCB );
    4304:	89 81       	ldd	r24, Y+1	; 0x01
    4306:	9a 81       	ldd	r25, Y+2	; 0x02
    4308:	0e 94 de 11 	call	0x23bc	; 0x23bc <vPortFree>
	}
    430c:	0f 90       	pop	r0
    430e:	0f 90       	pop	r0
    4310:	cf 91       	pop	r28
    4312:	df 91       	pop	r29
    4314:	08 95       	ret

00004316 <__subsf3>:
    4316:	50 58       	subi	r21, 0x80	; 128

00004318 <__addsf3>:
    4318:	bb 27       	eor	r27, r27
    431a:	aa 27       	eor	r26, r26
    431c:	0e d0       	rcall	.+28     	; 0x433a <__addsf3x>
    431e:	47 c1       	rjmp	.+654    	; 0x45ae <__fp_round>
    4320:	10 d1       	rcall	.+544    	; 0x4542 <__fp_pscA>
    4322:	30 f0       	brcs	.+12     	; 0x4330 <__addsf3+0x18>
    4324:	15 d1       	rcall	.+554    	; 0x4550 <__fp_pscB>
    4326:	20 f0       	brcs	.+8      	; 0x4330 <__addsf3+0x18>
    4328:	31 f4       	brne	.+12     	; 0x4336 <__addsf3+0x1e>
    432a:	9f 3f       	cpi	r25, 0xFF	; 255
    432c:	11 f4       	brne	.+4      	; 0x4332 <__addsf3+0x1a>
    432e:	1e f4       	brtc	.+6      	; 0x4336 <__addsf3+0x1e>
    4330:	05 c1       	rjmp	.+522    	; 0x453c <__fp_nan>
    4332:	0e f4       	brtc	.+2      	; 0x4336 <__addsf3+0x1e>
    4334:	e0 95       	com	r30
    4336:	e7 fb       	bst	r30, 7
    4338:	fb c0       	rjmp	.+502    	; 0x4530 <__fp_inf>

0000433a <__addsf3x>:
    433a:	e9 2f       	mov	r30, r25
    433c:	5a d1       	rcall	.+692    	; 0x45f2 <__fp_split3>
    433e:	80 f3       	brcs	.-32     	; 0x4320 <__addsf3+0x8>
    4340:	ba 17       	cp	r27, r26
    4342:	62 07       	cpc	r22, r18
    4344:	73 07       	cpc	r23, r19
    4346:	84 07       	cpc	r24, r20
    4348:	95 07       	cpc	r25, r21
    434a:	18 f0       	brcs	.+6      	; 0x4352 <__addsf3x+0x18>
    434c:	71 f4       	brne	.+28     	; 0x436a <__addsf3x+0x30>
    434e:	9e f5       	brtc	.+102    	; 0x43b6 <__addsf3x+0x7c>
    4350:	72 c1       	rjmp	.+740    	; 0x4636 <__fp_zero>
    4352:	0e f4       	brtc	.+2      	; 0x4356 <__addsf3x+0x1c>
    4354:	e0 95       	com	r30
    4356:	0b 2e       	mov	r0, r27
    4358:	ba 2f       	mov	r27, r26
    435a:	a0 2d       	mov	r26, r0
    435c:	0b 01       	movw	r0, r22
    435e:	b9 01       	movw	r22, r18
    4360:	90 01       	movw	r18, r0
    4362:	0c 01       	movw	r0, r24
    4364:	ca 01       	movw	r24, r20
    4366:	a0 01       	movw	r20, r0
    4368:	11 24       	eor	r1, r1
    436a:	ff 27       	eor	r31, r31
    436c:	59 1b       	sub	r21, r25
    436e:	99 f0       	breq	.+38     	; 0x4396 <__addsf3x+0x5c>
    4370:	59 3f       	cpi	r21, 0xF9	; 249
    4372:	50 f4       	brcc	.+20     	; 0x4388 <__addsf3x+0x4e>
    4374:	50 3e       	cpi	r21, 0xE0	; 224
    4376:	68 f1       	brcs	.+90     	; 0x43d2 <__addsf3x+0x98>
    4378:	1a 16       	cp	r1, r26
    437a:	f0 40       	sbci	r31, 0x00	; 0
    437c:	a2 2f       	mov	r26, r18
    437e:	23 2f       	mov	r18, r19
    4380:	34 2f       	mov	r19, r20
    4382:	44 27       	eor	r20, r20
    4384:	58 5f       	subi	r21, 0xF8	; 248
    4386:	f3 cf       	rjmp	.-26     	; 0x436e <__addsf3x+0x34>
    4388:	46 95       	lsr	r20
    438a:	37 95       	ror	r19
    438c:	27 95       	ror	r18
    438e:	a7 95       	ror	r26
    4390:	f0 40       	sbci	r31, 0x00	; 0
    4392:	53 95       	inc	r21
    4394:	c9 f7       	brne	.-14     	; 0x4388 <__addsf3x+0x4e>
    4396:	7e f4       	brtc	.+30     	; 0x43b6 <__addsf3x+0x7c>
    4398:	1f 16       	cp	r1, r31
    439a:	ba 0b       	sbc	r27, r26
    439c:	62 0b       	sbc	r22, r18
    439e:	73 0b       	sbc	r23, r19
    43a0:	84 0b       	sbc	r24, r20
    43a2:	ba f0       	brmi	.+46     	; 0x43d2 <__addsf3x+0x98>
    43a4:	91 50       	subi	r25, 0x01	; 1
    43a6:	a1 f0       	breq	.+40     	; 0x43d0 <__addsf3x+0x96>
    43a8:	ff 0f       	add	r31, r31
    43aa:	bb 1f       	adc	r27, r27
    43ac:	66 1f       	adc	r22, r22
    43ae:	77 1f       	adc	r23, r23
    43b0:	88 1f       	adc	r24, r24
    43b2:	c2 f7       	brpl	.-16     	; 0x43a4 <__addsf3x+0x6a>
    43b4:	0e c0       	rjmp	.+28     	; 0x43d2 <__addsf3x+0x98>
    43b6:	ba 0f       	add	r27, r26
    43b8:	62 1f       	adc	r22, r18
    43ba:	73 1f       	adc	r23, r19
    43bc:	84 1f       	adc	r24, r20
    43be:	48 f4       	brcc	.+18     	; 0x43d2 <__addsf3x+0x98>
    43c0:	87 95       	ror	r24
    43c2:	77 95       	ror	r23
    43c4:	67 95       	ror	r22
    43c6:	b7 95       	ror	r27
    43c8:	f7 95       	ror	r31
    43ca:	9e 3f       	cpi	r25, 0xFE	; 254
    43cc:	08 f0       	brcs	.+2      	; 0x43d0 <__addsf3x+0x96>
    43ce:	b3 cf       	rjmp	.-154    	; 0x4336 <__addsf3+0x1e>
    43d0:	93 95       	inc	r25
    43d2:	88 0f       	add	r24, r24
    43d4:	08 f0       	brcs	.+2      	; 0x43d8 <__addsf3x+0x9e>
    43d6:	99 27       	eor	r25, r25
    43d8:	ee 0f       	add	r30, r30
    43da:	97 95       	ror	r25
    43dc:	87 95       	ror	r24
    43de:	08 95       	ret

000043e0 <cos>:
    43e0:	bf d0       	rcall	.+382    	; 0x4560 <__fp_rempio2>
    43e2:	e3 95       	inc	r30
    43e4:	f5 c0       	rjmp	.+490    	; 0x45d0 <__fp_sinus>

000043e6 <__divsf3>:
    43e6:	0c d0       	rcall	.+24     	; 0x4400 <__divsf3x>
    43e8:	e2 c0       	rjmp	.+452    	; 0x45ae <__fp_round>
    43ea:	b2 d0       	rcall	.+356    	; 0x4550 <__fp_pscB>
    43ec:	40 f0       	brcs	.+16     	; 0x43fe <__divsf3+0x18>
    43ee:	a9 d0       	rcall	.+338    	; 0x4542 <__fp_pscA>
    43f0:	30 f0       	brcs	.+12     	; 0x43fe <__divsf3+0x18>
    43f2:	21 f4       	brne	.+8      	; 0x43fc <__divsf3+0x16>
    43f4:	5f 3f       	cpi	r21, 0xFF	; 255
    43f6:	19 f0       	breq	.+6      	; 0x43fe <__divsf3+0x18>
    43f8:	9b c0       	rjmp	.+310    	; 0x4530 <__fp_inf>
    43fa:	51 11       	cpse	r21, r1
    43fc:	1d c1       	rjmp	.+570    	; 0x4638 <__fp_szero>
    43fe:	9e c0       	rjmp	.+316    	; 0x453c <__fp_nan>

00004400 <__divsf3x>:
    4400:	f8 d0       	rcall	.+496    	; 0x45f2 <__fp_split3>
    4402:	98 f3       	brcs	.-26     	; 0x43ea <__divsf3+0x4>

00004404 <__divsf3_pse>:
    4404:	99 23       	and	r25, r25
    4406:	c9 f3       	breq	.-14     	; 0x43fa <__divsf3+0x14>
    4408:	55 23       	and	r21, r21
    440a:	b1 f3       	breq	.-20     	; 0x43f8 <__divsf3+0x12>
    440c:	95 1b       	sub	r25, r21
    440e:	55 0b       	sbc	r21, r21
    4410:	bb 27       	eor	r27, r27
    4412:	aa 27       	eor	r26, r26
    4414:	62 17       	cp	r22, r18
    4416:	73 07       	cpc	r23, r19
    4418:	84 07       	cpc	r24, r20
    441a:	38 f0       	brcs	.+14     	; 0x442a <__divsf3_pse+0x26>
    441c:	9f 5f       	subi	r25, 0xFF	; 255
    441e:	5f 4f       	sbci	r21, 0xFF	; 255
    4420:	22 0f       	add	r18, r18
    4422:	33 1f       	adc	r19, r19
    4424:	44 1f       	adc	r20, r20
    4426:	aa 1f       	adc	r26, r26
    4428:	a9 f3       	breq	.-22     	; 0x4414 <__divsf3_pse+0x10>
    442a:	33 d0       	rcall	.+102    	; 0x4492 <__divsf3_pse+0x8e>
    442c:	0e 2e       	mov	r0, r30
    442e:	3a f0       	brmi	.+14     	; 0x443e <__divsf3_pse+0x3a>
    4430:	e0 e8       	ldi	r30, 0x80	; 128
    4432:	30 d0       	rcall	.+96     	; 0x4494 <__divsf3_pse+0x90>
    4434:	91 50       	subi	r25, 0x01	; 1
    4436:	50 40       	sbci	r21, 0x00	; 0
    4438:	e6 95       	lsr	r30
    443a:	00 1c       	adc	r0, r0
    443c:	ca f7       	brpl	.-14     	; 0x4430 <__divsf3_pse+0x2c>
    443e:	29 d0       	rcall	.+82     	; 0x4492 <__divsf3_pse+0x8e>
    4440:	fe 2f       	mov	r31, r30
    4442:	27 d0       	rcall	.+78     	; 0x4492 <__divsf3_pse+0x8e>
    4444:	66 0f       	add	r22, r22
    4446:	77 1f       	adc	r23, r23
    4448:	88 1f       	adc	r24, r24
    444a:	bb 1f       	adc	r27, r27
    444c:	26 17       	cp	r18, r22
    444e:	37 07       	cpc	r19, r23
    4450:	48 07       	cpc	r20, r24
    4452:	ab 07       	cpc	r26, r27
    4454:	b0 e8       	ldi	r27, 0x80	; 128
    4456:	09 f0       	breq	.+2      	; 0x445a <__divsf3_pse+0x56>
    4458:	bb 0b       	sbc	r27, r27
    445a:	80 2d       	mov	r24, r0
    445c:	bf 01       	movw	r22, r30
    445e:	ff 27       	eor	r31, r31
    4460:	93 58       	subi	r25, 0x83	; 131
    4462:	5f 4f       	sbci	r21, 0xFF	; 255
    4464:	2a f0       	brmi	.+10     	; 0x4470 <__divsf3_pse+0x6c>
    4466:	9e 3f       	cpi	r25, 0xFE	; 254
    4468:	51 05       	cpc	r21, r1
    446a:	68 f0       	brcs	.+26     	; 0x4486 <__divsf3_pse+0x82>
    446c:	61 c0       	rjmp	.+194    	; 0x4530 <__fp_inf>
    446e:	e4 c0       	rjmp	.+456    	; 0x4638 <__fp_szero>
    4470:	5f 3f       	cpi	r21, 0xFF	; 255
    4472:	ec f3       	brlt	.-6      	; 0x446e <__divsf3_pse+0x6a>
    4474:	98 3e       	cpi	r25, 0xE8	; 232
    4476:	dc f3       	brlt	.-10     	; 0x446e <__divsf3_pse+0x6a>
    4478:	86 95       	lsr	r24
    447a:	77 95       	ror	r23
    447c:	67 95       	ror	r22
    447e:	b7 95       	ror	r27
    4480:	f7 95       	ror	r31
    4482:	9f 5f       	subi	r25, 0xFF	; 255
    4484:	c9 f7       	brne	.-14     	; 0x4478 <__divsf3_pse+0x74>
    4486:	88 0f       	add	r24, r24
    4488:	91 1d       	adc	r25, r1
    448a:	96 95       	lsr	r25
    448c:	87 95       	ror	r24
    448e:	97 f9       	bld	r25, 7
    4490:	08 95       	ret
    4492:	e1 e0       	ldi	r30, 0x01	; 1
    4494:	66 0f       	add	r22, r22
    4496:	77 1f       	adc	r23, r23
    4498:	88 1f       	adc	r24, r24
    449a:	bb 1f       	adc	r27, r27
    449c:	62 17       	cp	r22, r18
    449e:	73 07       	cpc	r23, r19
    44a0:	84 07       	cpc	r24, r20
    44a2:	ba 07       	cpc	r27, r26
    44a4:	20 f0       	brcs	.+8      	; 0x44ae <__divsf3_pse+0xaa>
    44a6:	62 1b       	sub	r22, r18
    44a8:	73 0b       	sbc	r23, r19
    44aa:	84 0b       	sbc	r24, r20
    44ac:	ba 0b       	sbc	r27, r26
    44ae:	ee 1f       	adc	r30, r30
    44b0:	88 f7       	brcc	.-30     	; 0x4494 <__divsf3_pse+0x90>
    44b2:	e0 95       	com	r30
    44b4:	08 95       	ret

000044b6 <__floatunsisf>:
    44b6:	e8 94       	clt
    44b8:	09 c0       	rjmp	.+18     	; 0x44cc <__floatsisf+0x12>

000044ba <__floatsisf>:
    44ba:	97 fb       	bst	r25, 7
    44bc:	3e f4       	brtc	.+14     	; 0x44cc <__floatsisf+0x12>
    44be:	90 95       	com	r25
    44c0:	80 95       	com	r24
    44c2:	70 95       	com	r23
    44c4:	61 95       	neg	r22
    44c6:	7f 4f       	sbci	r23, 0xFF	; 255
    44c8:	8f 4f       	sbci	r24, 0xFF	; 255
    44ca:	9f 4f       	sbci	r25, 0xFF	; 255
    44cc:	99 23       	and	r25, r25
    44ce:	a9 f0       	breq	.+42     	; 0x44fa <__floatsisf+0x40>
    44d0:	f9 2f       	mov	r31, r25
    44d2:	96 e9       	ldi	r25, 0x96	; 150
    44d4:	bb 27       	eor	r27, r27
    44d6:	93 95       	inc	r25
    44d8:	f6 95       	lsr	r31
    44da:	87 95       	ror	r24
    44dc:	77 95       	ror	r23
    44de:	67 95       	ror	r22
    44e0:	b7 95       	ror	r27
    44e2:	f1 11       	cpse	r31, r1
    44e4:	f8 cf       	rjmp	.-16     	; 0x44d6 <__floatsisf+0x1c>
    44e6:	fa f4       	brpl	.+62     	; 0x4526 <__floatsisf+0x6c>
    44e8:	bb 0f       	add	r27, r27
    44ea:	11 f4       	brne	.+4      	; 0x44f0 <__floatsisf+0x36>
    44ec:	60 ff       	sbrs	r22, 0
    44ee:	1b c0       	rjmp	.+54     	; 0x4526 <__floatsisf+0x6c>
    44f0:	6f 5f       	subi	r22, 0xFF	; 255
    44f2:	7f 4f       	sbci	r23, 0xFF	; 255
    44f4:	8f 4f       	sbci	r24, 0xFF	; 255
    44f6:	9f 4f       	sbci	r25, 0xFF	; 255
    44f8:	16 c0       	rjmp	.+44     	; 0x4526 <__floatsisf+0x6c>
    44fa:	88 23       	and	r24, r24
    44fc:	11 f0       	breq	.+4      	; 0x4502 <__floatsisf+0x48>
    44fe:	96 e9       	ldi	r25, 0x96	; 150
    4500:	11 c0       	rjmp	.+34     	; 0x4524 <__floatsisf+0x6a>
    4502:	77 23       	and	r23, r23
    4504:	21 f0       	breq	.+8      	; 0x450e <__floatsisf+0x54>
    4506:	9e e8       	ldi	r25, 0x8E	; 142
    4508:	87 2f       	mov	r24, r23
    450a:	76 2f       	mov	r23, r22
    450c:	05 c0       	rjmp	.+10     	; 0x4518 <__floatsisf+0x5e>
    450e:	66 23       	and	r22, r22
    4510:	71 f0       	breq	.+28     	; 0x452e <__floatsisf+0x74>
    4512:	96 e8       	ldi	r25, 0x86	; 134
    4514:	86 2f       	mov	r24, r22
    4516:	70 e0       	ldi	r23, 0x00	; 0
    4518:	60 e0       	ldi	r22, 0x00	; 0
    451a:	2a f0       	brmi	.+10     	; 0x4526 <__floatsisf+0x6c>
    451c:	9a 95       	dec	r25
    451e:	66 0f       	add	r22, r22
    4520:	77 1f       	adc	r23, r23
    4522:	88 1f       	adc	r24, r24
    4524:	da f7       	brpl	.-10     	; 0x451c <__floatsisf+0x62>
    4526:	88 0f       	add	r24, r24
    4528:	96 95       	lsr	r25
    452a:	87 95       	ror	r24
    452c:	97 f9       	bld	r25, 7
    452e:	08 95       	ret

00004530 <__fp_inf>:
    4530:	97 f9       	bld	r25, 7
    4532:	9f 67       	ori	r25, 0x7F	; 127
    4534:	80 e8       	ldi	r24, 0x80	; 128
    4536:	70 e0       	ldi	r23, 0x00	; 0
    4538:	60 e0       	ldi	r22, 0x00	; 0
    453a:	08 95       	ret

0000453c <__fp_nan>:
    453c:	9f ef       	ldi	r25, 0xFF	; 255
    453e:	80 ec       	ldi	r24, 0xC0	; 192
    4540:	08 95       	ret

00004542 <__fp_pscA>:
    4542:	00 24       	eor	r0, r0
    4544:	0a 94       	dec	r0
    4546:	16 16       	cp	r1, r22
    4548:	17 06       	cpc	r1, r23
    454a:	18 06       	cpc	r1, r24
    454c:	09 06       	cpc	r0, r25
    454e:	08 95       	ret

00004550 <__fp_pscB>:
    4550:	00 24       	eor	r0, r0
    4552:	0a 94       	dec	r0
    4554:	12 16       	cp	r1, r18
    4556:	13 06       	cpc	r1, r19
    4558:	14 06       	cpc	r1, r20
    455a:	05 06       	cpc	r0, r21
    455c:	08 95       	ret
    455e:	ee cf       	rjmp	.-36     	; 0x453c <__fp_nan>

00004560 <__fp_rempio2>:
    4560:	50 d0       	rcall	.+160    	; 0x4602 <__fp_splitA>
    4562:	e8 f3       	brcs	.-6      	; 0x455e <__fp_pscB+0xe>
    4564:	e8 94       	clt
    4566:	e0 e0       	ldi	r30, 0x00	; 0
    4568:	bb 27       	eor	r27, r27
    456a:	9f 57       	subi	r25, 0x7F	; 127
    456c:	f0 f0       	brcs	.+60     	; 0x45aa <__fp_rempio2+0x4a>
    456e:	2a ed       	ldi	r18, 0xDA	; 218
    4570:	3f e0       	ldi	r19, 0x0F	; 15
    4572:	49 ec       	ldi	r20, 0xC9	; 201
    4574:	06 c0       	rjmp	.+12     	; 0x4582 <__fp_rempio2+0x22>
    4576:	ee 0f       	add	r30, r30
    4578:	bb 0f       	add	r27, r27
    457a:	66 1f       	adc	r22, r22
    457c:	77 1f       	adc	r23, r23
    457e:	88 1f       	adc	r24, r24
    4580:	28 f0       	brcs	.+10     	; 0x458c <__fp_rempio2+0x2c>
    4582:	b2 3a       	cpi	r27, 0xA2	; 162
    4584:	62 07       	cpc	r22, r18
    4586:	73 07       	cpc	r23, r19
    4588:	84 07       	cpc	r24, r20
    458a:	28 f0       	brcs	.+10     	; 0x4596 <__fp_rempio2+0x36>
    458c:	b2 5a       	subi	r27, 0xA2	; 162
    458e:	62 0b       	sbc	r22, r18
    4590:	73 0b       	sbc	r23, r19
    4592:	84 0b       	sbc	r24, r20
    4594:	e3 95       	inc	r30
    4596:	9a 95       	dec	r25
    4598:	72 f7       	brpl	.-36     	; 0x4576 <__fp_rempio2+0x16>
    459a:	80 38       	cpi	r24, 0x80	; 128
    459c:	30 f4       	brcc	.+12     	; 0x45aa <__fp_rempio2+0x4a>
    459e:	9a 95       	dec	r25
    45a0:	bb 0f       	add	r27, r27
    45a2:	66 1f       	adc	r22, r22
    45a4:	77 1f       	adc	r23, r23
    45a6:	88 1f       	adc	r24, r24
    45a8:	d2 f7       	brpl	.-12     	; 0x459e <__fp_rempio2+0x3e>
    45aa:	90 48       	sbci	r25, 0x80	; 128
    45ac:	d6 c0       	rjmp	.+428    	; 0x475a <__fp_mpack_finite>

000045ae <__fp_round>:
    45ae:	09 2e       	mov	r0, r25
    45b0:	03 94       	inc	r0
    45b2:	00 0c       	add	r0, r0
    45b4:	11 f4       	brne	.+4      	; 0x45ba <__fp_round+0xc>
    45b6:	88 23       	and	r24, r24
    45b8:	52 f0       	brmi	.+20     	; 0x45ce <__fp_round+0x20>
    45ba:	bb 0f       	add	r27, r27
    45bc:	40 f4       	brcc	.+16     	; 0x45ce <__fp_round+0x20>
    45be:	bf 2b       	or	r27, r31
    45c0:	11 f4       	brne	.+4      	; 0x45c6 <__fp_round+0x18>
    45c2:	60 ff       	sbrs	r22, 0
    45c4:	04 c0       	rjmp	.+8      	; 0x45ce <__fp_round+0x20>
    45c6:	6f 5f       	subi	r22, 0xFF	; 255
    45c8:	7f 4f       	sbci	r23, 0xFF	; 255
    45ca:	8f 4f       	sbci	r24, 0xFF	; 255
    45cc:	9f 4f       	sbci	r25, 0xFF	; 255
    45ce:	08 95       	ret

000045d0 <__fp_sinus>:
    45d0:	ef 93       	push	r30
    45d2:	e0 ff       	sbrs	r30, 0
    45d4:	06 c0       	rjmp	.+12     	; 0x45e2 <__fp_sinus+0x12>
    45d6:	a2 ea       	ldi	r26, 0xA2	; 162
    45d8:	2a ed       	ldi	r18, 0xDA	; 218
    45da:	3f e0       	ldi	r19, 0x0F	; 15
    45dc:	49 ec       	ldi	r20, 0xC9	; 201
    45de:	5f eb       	ldi	r21, 0xBF	; 191
    45e0:	ac de       	rcall	.-680    	; 0x433a <__addsf3x>
    45e2:	e5 df       	rcall	.-54     	; 0x45ae <__fp_round>
    45e4:	0f 90       	pop	r0
    45e6:	03 94       	inc	r0
    45e8:	01 fc       	sbrc	r0, 1
    45ea:	90 58       	subi	r25, 0x80	; 128
    45ec:	ec e8       	ldi	r30, 0x8C	; 140
    45ee:	f0 e0       	ldi	r31, 0x00	; 0
    45f0:	c0 c0       	rjmp	.+384    	; 0x4772 <__fp_powsodd>

000045f2 <__fp_split3>:
    45f2:	57 fd       	sbrc	r21, 7
    45f4:	90 58       	subi	r25, 0x80	; 128
    45f6:	44 0f       	add	r20, r20
    45f8:	55 1f       	adc	r21, r21
    45fa:	59 f0       	breq	.+22     	; 0x4612 <__fp_splitA+0x10>
    45fc:	5f 3f       	cpi	r21, 0xFF	; 255
    45fe:	71 f0       	breq	.+28     	; 0x461c <__fp_splitA+0x1a>
    4600:	47 95       	ror	r20

00004602 <__fp_splitA>:
    4602:	88 0f       	add	r24, r24
    4604:	97 fb       	bst	r25, 7
    4606:	99 1f       	adc	r25, r25
    4608:	61 f0       	breq	.+24     	; 0x4622 <__fp_splitA+0x20>
    460a:	9f 3f       	cpi	r25, 0xFF	; 255
    460c:	79 f0       	breq	.+30     	; 0x462c <__fp_splitA+0x2a>
    460e:	87 95       	ror	r24
    4610:	08 95       	ret
    4612:	12 16       	cp	r1, r18
    4614:	13 06       	cpc	r1, r19
    4616:	14 06       	cpc	r1, r20
    4618:	55 1f       	adc	r21, r21
    461a:	f2 cf       	rjmp	.-28     	; 0x4600 <__fp_split3+0xe>
    461c:	46 95       	lsr	r20
    461e:	f1 df       	rcall	.-30     	; 0x4602 <__fp_splitA>
    4620:	08 c0       	rjmp	.+16     	; 0x4632 <__fp_splitA+0x30>
    4622:	16 16       	cp	r1, r22
    4624:	17 06       	cpc	r1, r23
    4626:	18 06       	cpc	r1, r24
    4628:	99 1f       	adc	r25, r25
    462a:	f1 cf       	rjmp	.-30     	; 0x460e <__fp_splitA+0xc>
    462c:	86 95       	lsr	r24
    462e:	71 05       	cpc	r23, r1
    4630:	61 05       	cpc	r22, r1
    4632:	08 94       	sec
    4634:	08 95       	ret

00004636 <__fp_zero>:
    4636:	e8 94       	clt

00004638 <__fp_szero>:
    4638:	bb 27       	eor	r27, r27
    463a:	66 27       	eor	r22, r22
    463c:	77 27       	eor	r23, r23
    463e:	cb 01       	movw	r24, r22
    4640:	97 f9       	bld	r25, 7
    4642:	08 95       	ret

00004644 <__mulsf3>:
    4644:	0b d0       	rcall	.+22     	; 0x465c <__mulsf3x>
    4646:	b3 cf       	rjmp	.-154    	; 0x45ae <__fp_round>
    4648:	7c df       	rcall	.-264    	; 0x4542 <__fp_pscA>
    464a:	28 f0       	brcs	.+10     	; 0x4656 <__mulsf3+0x12>
    464c:	81 df       	rcall	.-254    	; 0x4550 <__fp_pscB>
    464e:	18 f0       	brcs	.+6      	; 0x4656 <__mulsf3+0x12>
    4650:	95 23       	and	r25, r21
    4652:	09 f0       	breq	.+2      	; 0x4656 <__mulsf3+0x12>
    4654:	6d cf       	rjmp	.-294    	; 0x4530 <__fp_inf>
    4656:	72 cf       	rjmp	.-284    	; 0x453c <__fp_nan>
    4658:	11 24       	eor	r1, r1
    465a:	ee cf       	rjmp	.-36     	; 0x4638 <__fp_szero>

0000465c <__mulsf3x>:
    465c:	ca df       	rcall	.-108    	; 0x45f2 <__fp_split3>
    465e:	a0 f3       	brcs	.-24     	; 0x4648 <__mulsf3+0x4>

00004660 <__mulsf3_pse>:
    4660:	95 9f       	mul	r25, r21
    4662:	d1 f3       	breq	.-12     	; 0x4658 <__mulsf3+0x14>
    4664:	95 0f       	add	r25, r21
    4666:	50 e0       	ldi	r21, 0x00	; 0
    4668:	55 1f       	adc	r21, r21
    466a:	62 9f       	mul	r22, r18
    466c:	f0 01       	movw	r30, r0
    466e:	72 9f       	mul	r23, r18
    4670:	bb 27       	eor	r27, r27
    4672:	f0 0d       	add	r31, r0
    4674:	b1 1d       	adc	r27, r1
    4676:	63 9f       	mul	r22, r19
    4678:	aa 27       	eor	r26, r26
    467a:	f0 0d       	add	r31, r0
    467c:	b1 1d       	adc	r27, r1
    467e:	aa 1f       	adc	r26, r26
    4680:	64 9f       	mul	r22, r20
    4682:	66 27       	eor	r22, r22
    4684:	b0 0d       	add	r27, r0
    4686:	a1 1d       	adc	r26, r1
    4688:	66 1f       	adc	r22, r22
    468a:	82 9f       	mul	r24, r18
    468c:	22 27       	eor	r18, r18
    468e:	b0 0d       	add	r27, r0
    4690:	a1 1d       	adc	r26, r1
    4692:	62 1f       	adc	r22, r18
    4694:	73 9f       	mul	r23, r19
    4696:	b0 0d       	add	r27, r0
    4698:	a1 1d       	adc	r26, r1
    469a:	62 1f       	adc	r22, r18
    469c:	83 9f       	mul	r24, r19
    469e:	a0 0d       	add	r26, r0
    46a0:	61 1d       	adc	r22, r1
    46a2:	22 1f       	adc	r18, r18
    46a4:	74 9f       	mul	r23, r20
    46a6:	33 27       	eor	r19, r19
    46a8:	a0 0d       	add	r26, r0
    46aa:	61 1d       	adc	r22, r1
    46ac:	23 1f       	adc	r18, r19
    46ae:	84 9f       	mul	r24, r20
    46b0:	60 0d       	add	r22, r0
    46b2:	21 1d       	adc	r18, r1
    46b4:	82 2f       	mov	r24, r18
    46b6:	76 2f       	mov	r23, r22
    46b8:	6a 2f       	mov	r22, r26
    46ba:	11 24       	eor	r1, r1
    46bc:	9f 57       	subi	r25, 0x7F	; 127
    46be:	50 40       	sbci	r21, 0x00	; 0
    46c0:	8a f0       	brmi	.+34     	; 0x46e4 <__mulsf3_pse+0x84>
    46c2:	e1 f0       	breq	.+56     	; 0x46fc <__mulsf3_pse+0x9c>
    46c4:	88 23       	and	r24, r24
    46c6:	4a f0       	brmi	.+18     	; 0x46da <__mulsf3_pse+0x7a>
    46c8:	ee 0f       	add	r30, r30
    46ca:	ff 1f       	adc	r31, r31
    46cc:	bb 1f       	adc	r27, r27
    46ce:	66 1f       	adc	r22, r22
    46d0:	77 1f       	adc	r23, r23
    46d2:	88 1f       	adc	r24, r24
    46d4:	91 50       	subi	r25, 0x01	; 1
    46d6:	50 40       	sbci	r21, 0x00	; 0
    46d8:	a9 f7       	brne	.-22     	; 0x46c4 <__mulsf3_pse+0x64>
    46da:	9e 3f       	cpi	r25, 0xFE	; 254
    46dc:	51 05       	cpc	r21, r1
    46de:	70 f0       	brcs	.+28     	; 0x46fc <__mulsf3_pse+0x9c>
    46e0:	27 cf       	rjmp	.-434    	; 0x4530 <__fp_inf>
    46e2:	aa cf       	rjmp	.-172    	; 0x4638 <__fp_szero>
    46e4:	5f 3f       	cpi	r21, 0xFF	; 255
    46e6:	ec f3       	brlt	.-6      	; 0x46e2 <__mulsf3_pse+0x82>
    46e8:	98 3e       	cpi	r25, 0xE8	; 232
    46ea:	dc f3       	brlt	.-10     	; 0x46e2 <__mulsf3_pse+0x82>
    46ec:	86 95       	lsr	r24
    46ee:	77 95       	ror	r23
    46f0:	67 95       	ror	r22
    46f2:	b7 95       	ror	r27
    46f4:	f7 95       	ror	r31
    46f6:	e7 95       	ror	r30
    46f8:	9f 5f       	subi	r25, 0xFF	; 255
    46fa:	c1 f7       	brne	.-16     	; 0x46ec <__mulsf3_pse+0x8c>
    46fc:	fe 2b       	or	r31, r30
    46fe:	88 0f       	add	r24, r24
    4700:	91 1d       	adc	r25, r1
    4702:	96 95       	lsr	r25
    4704:	87 95       	ror	r24
    4706:	97 f9       	bld	r25, 7
    4708:	08 95       	ret

0000470a <sin>:
    470a:	9f 93       	push	r25
    470c:	29 df       	rcall	.-430    	; 0x4560 <__fp_rempio2>
    470e:	0f 90       	pop	r0
    4710:	07 fc       	sbrc	r0, 7
    4712:	ee 5f       	subi	r30, 0xFE	; 254
    4714:	5d cf       	rjmp	.-326    	; 0x45d0 <__fp_sinus>

00004716 <tan>:
    4716:	df 93       	push	r29
    4718:	d9 2f       	mov	r29, r25
    471a:	22 df       	rcall	.-444    	; 0x4560 <__fp_rempio2>
    471c:	e6 95       	lsr	r30
    471e:	d7 95       	ror	r29
    4720:	2a ed       	ldi	r18, 0xDA	; 218
    4722:	3f e0       	ldi	r19, 0x0F	; 15
    4724:	49 e4       	ldi	r20, 0x49	; 73
    4726:	5f e3       	ldi	r21, 0x3F	; 63
    4728:	b3 3a       	cpi	r27, 0xA3	; 163
    472a:	62 07       	cpc	r22, r18
    472c:	73 07       	cpc	r23, r19
    472e:	84 07       	cpc	r24, r20
    4730:	95 07       	cpc	r25, r21
    4732:	d7 95       	ror	r29
    4734:	2a f0       	brmi	.+10     	; 0x4740 <tan+0x2a>
    4736:	a2 ea       	ldi	r26, 0xA2	; 162
    4738:	49 ec       	ldi	r20, 0xC9	; 201
    473a:	90 68       	ori	r25, 0x80	; 128
    473c:	fe dd       	rcall	.-1028   	; 0x433a <__addsf3x>
    473e:	37 df       	rcall	.-402    	; 0x45ae <__fp_round>
    4740:	ea ea       	ldi	r30, 0xAA	; 170
    4742:	f0 e0       	ldi	r31, 0x00	; 0
    4744:	16 d0       	rcall	.+44     	; 0x4772 <__fp_powsodd>
    4746:	dd 0f       	add	r29, r29
    4748:	0b f0       	brvs	.+2      	; 0x474c <tan+0x36>
    474a:	24 d0       	rcall	.+72     	; 0x4794 <inverse>
    474c:	dd 0f       	add	r29, r29
    474e:	0b f4       	brvc	.+2      	; 0x4752 <tan+0x3c>
    4750:	90 58       	subi	r25, 0x80	; 128
    4752:	df 91       	pop	r29
    4754:	08 95       	ret

00004756 <__fp_mpack>:
    4756:	9f 3f       	cpi	r25, 0xFF	; 255
    4758:	31 f0       	breq	.+12     	; 0x4766 <__fp_mpack_finite+0xc>

0000475a <__fp_mpack_finite>:
    475a:	91 50       	subi	r25, 0x01	; 1
    475c:	20 f4       	brcc	.+8      	; 0x4766 <__fp_mpack_finite+0xc>
    475e:	87 95       	ror	r24
    4760:	77 95       	ror	r23
    4762:	67 95       	ror	r22
    4764:	b7 95       	ror	r27
    4766:	88 0f       	add	r24, r24
    4768:	91 1d       	adc	r25, r1
    476a:	96 95       	lsr	r25
    476c:	87 95       	ror	r24
    476e:	97 f9       	bld	r25, 7
    4770:	08 95       	ret

00004772 <__fp_powsodd>:
    4772:	9f 93       	push	r25
    4774:	8f 93       	push	r24
    4776:	7f 93       	push	r23
    4778:	6f 93       	push	r22
    477a:	ff 93       	push	r31
    477c:	ef 93       	push	r30
    477e:	9b 01       	movw	r18, r22
    4780:	ac 01       	movw	r20, r24
    4782:	60 df       	rcall	.-320    	; 0x4644 <__mulsf3>
    4784:	ef 91       	pop	r30
    4786:	ff 91       	pop	r31
    4788:	0c d0       	rcall	.+24     	; 0x47a2 <__fp_powser>
    478a:	2f 91       	pop	r18
    478c:	3f 91       	pop	r19
    478e:	4f 91       	pop	r20
    4790:	5f 91       	pop	r21
    4792:	58 cf       	rjmp	.-336    	; 0x4644 <__mulsf3>

00004794 <inverse>:
    4794:	9b 01       	movw	r18, r22
    4796:	ac 01       	movw	r20, r24
    4798:	60 e0       	ldi	r22, 0x00	; 0
    479a:	70 e0       	ldi	r23, 0x00	; 0
    479c:	80 e8       	ldi	r24, 0x80	; 128
    479e:	9f e3       	ldi	r25, 0x3F	; 63
    47a0:	22 ce       	rjmp	.-956    	; 0x43e6 <__divsf3>

000047a2 <__fp_powser>:
    47a2:	df 93       	push	r29
    47a4:	cf 93       	push	r28
    47a6:	1f 93       	push	r17
    47a8:	0f 93       	push	r16
    47aa:	ff 92       	push	r15
    47ac:	ef 92       	push	r14
    47ae:	df 92       	push	r13
    47b0:	7b 01       	movw	r14, r22
    47b2:	8c 01       	movw	r16, r24
    47b4:	68 94       	set
    47b6:	05 c0       	rjmp	.+10     	; 0x47c2 <__fp_powser+0x20>
    47b8:	da 2e       	mov	r13, r26
    47ba:	ef 01       	movw	r28, r30
    47bc:	4f df       	rcall	.-354    	; 0x465c <__mulsf3x>
    47be:	fe 01       	movw	r30, r28
    47c0:	e8 94       	clt
    47c2:	a5 91       	lpm	r26, Z+
    47c4:	25 91       	lpm	r18, Z+
    47c6:	35 91       	lpm	r19, Z+
    47c8:	45 91       	lpm	r20, Z+
    47ca:	55 91       	lpm	r21, Z+
    47cc:	ae f3       	brts	.-22     	; 0x47b8 <__fp_powser+0x16>
    47ce:	ef 01       	movw	r28, r30
    47d0:	b4 dd       	rcall	.-1176   	; 0x433a <__addsf3x>
    47d2:	fe 01       	movw	r30, r28
    47d4:	97 01       	movw	r18, r14
    47d6:	a8 01       	movw	r20, r16
    47d8:	da 94       	dec	r13
    47da:	79 f7       	brne	.-34     	; 0x47ba <__fp_powser+0x18>
    47dc:	df 90       	pop	r13
    47de:	ef 90       	pop	r14
    47e0:	ff 90       	pop	r15
    47e2:	0f 91       	pop	r16
    47e4:	1f 91       	pop	r17
    47e6:	cf 91       	pop	r28
    47e8:	df 91       	pop	r29
    47ea:	08 95       	ret

000047ec <__udivmodqi4>:
    47ec:	99 1b       	sub	r25, r25
    47ee:	79 e0       	ldi	r23, 0x09	; 9
    47f0:	04 c0       	rjmp	.+8      	; 0x47fa <__udivmodqi4_ep>

000047f2 <__udivmodqi4_loop>:
    47f2:	99 1f       	adc	r25, r25
    47f4:	96 17       	cp	r25, r22
    47f6:	08 f0       	brcs	.+2      	; 0x47fa <__udivmodqi4_ep>
    47f8:	96 1b       	sub	r25, r22

000047fa <__udivmodqi4_ep>:
    47fa:	88 1f       	adc	r24, r24
    47fc:	7a 95       	dec	r23
    47fe:	c9 f7       	brne	.-14     	; 0x47f2 <__udivmodqi4_loop>
    4800:	80 95       	com	r24
    4802:	08 95       	ret

00004804 <__divmodhi4>:
    4804:	97 fb       	bst	r25, 7
    4806:	09 2e       	mov	r0, r25
    4808:	07 26       	eor	r0, r23
    480a:	0a d0       	rcall	.+20     	; 0x4820 <__divmodhi4_neg1>
    480c:	77 fd       	sbrc	r23, 7
    480e:	04 d0       	rcall	.+8      	; 0x4818 <__divmodhi4_neg2>
    4810:	0c d0       	rcall	.+24     	; 0x482a <__udivmodhi4>
    4812:	06 d0       	rcall	.+12     	; 0x4820 <__divmodhi4_neg1>
    4814:	00 20       	and	r0, r0
    4816:	1a f4       	brpl	.+6      	; 0x481e <__divmodhi4_exit>

00004818 <__divmodhi4_neg2>:
    4818:	70 95       	com	r23
    481a:	61 95       	neg	r22
    481c:	7f 4f       	sbci	r23, 0xFF	; 255

0000481e <__divmodhi4_exit>:
    481e:	08 95       	ret

00004820 <__divmodhi4_neg1>:
    4820:	f6 f7       	brtc	.-4      	; 0x481e <__divmodhi4_exit>
    4822:	90 95       	com	r25
    4824:	81 95       	neg	r24
    4826:	9f 4f       	sbci	r25, 0xFF	; 255
    4828:	08 95       	ret

0000482a <__udivmodhi4>:
    482a:	aa 1b       	sub	r26, r26
    482c:	bb 1b       	sub	r27, r27
    482e:	51 e1       	ldi	r21, 0x11	; 17
    4830:	07 c0       	rjmp	.+14     	; 0x4840 <__udivmodhi4_ep>

00004832 <__udivmodhi4_loop>:
    4832:	aa 1f       	adc	r26, r26
    4834:	bb 1f       	adc	r27, r27
    4836:	a6 17       	cp	r26, r22
    4838:	b7 07       	cpc	r27, r23
    483a:	10 f0       	brcs	.+4      	; 0x4840 <__udivmodhi4_ep>
    483c:	a6 1b       	sub	r26, r22
    483e:	b7 0b       	sbc	r27, r23

00004840 <__udivmodhi4_ep>:
    4840:	88 1f       	adc	r24, r24
    4842:	99 1f       	adc	r25, r25
    4844:	5a 95       	dec	r21
    4846:	a9 f7       	brne	.-22     	; 0x4832 <__udivmodhi4_loop>
    4848:	80 95       	com	r24
    484a:	90 95       	com	r25
    484c:	bc 01       	movw	r22, r24
    484e:	cd 01       	movw	r24, r26
    4850:	08 95       	ret

00004852 <memcpy>:
    4852:	fb 01       	movw	r30, r22
    4854:	dc 01       	movw	r26, r24
    4856:	02 c0       	rjmp	.+4      	; 0x485c <memcpy+0xa>
    4858:	01 90       	ld	r0, Z+
    485a:	0d 92       	st	X+, r0
    485c:	41 50       	subi	r20, 0x01	; 1
    485e:	50 40       	sbci	r21, 0x00	; 0
    4860:	d8 f7       	brcc	.-10     	; 0x4858 <memcpy+0x6>
    4862:	08 95       	ret

00004864 <memset>:
    4864:	dc 01       	movw	r26, r24
    4866:	01 c0       	rjmp	.+2      	; 0x486a <memset+0x6>
    4868:	6d 93       	st	X+, r22
    486a:	41 50       	subi	r20, 0x01	; 1
    486c:	50 40       	sbci	r21, 0x00	; 0
    486e:	e0 f7       	brcc	.-8      	; 0x4868 <memset+0x4>
    4870:	08 95       	ret

00004872 <strncpy>:
    4872:	fb 01       	movw	r30, r22
    4874:	dc 01       	movw	r26, r24
    4876:	41 50       	subi	r20, 0x01	; 1
    4878:	50 40       	sbci	r21, 0x00	; 0
    487a:	48 f0       	brcs	.+18     	; 0x488e <strncpy+0x1c>
    487c:	01 90       	ld	r0, Z+
    487e:	0d 92       	st	X+, r0
    4880:	00 20       	and	r0, r0
    4882:	c9 f7       	brne	.-14     	; 0x4876 <strncpy+0x4>
    4884:	01 c0       	rjmp	.+2      	; 0x4888 <strncpy+0x16>
    4886:	1d 92       	st	X+, r1
    4888:	41 50       	subi	r20, 0x01	; 1
    488a:	50 40       	sbci	r21, 0x00	; 0
    488c:	e0 f7       	brcc	.-8      	; 0x4886 <strncpy+0x14>
    488e:	08 95       	ret

00004890 <_exit>:
    4890:	f8 94       	cli

00004892 <__stop_program>:
    4892:	ff cf       	rjmp	.-2      	; 0x4892 <__stop_program>
